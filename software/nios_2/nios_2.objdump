
nios_2.elf:     file format elf32-littlenios2
nios_2.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x0b000210

Program Header:
    LOAD off    0x00001060 vaddr 0x04000060 paddr 0x04000060 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00002000 vaddr 0x0b000000 paddr 0x0b000000 align 2**12
         filesz 0x0000833c memsz 0x0000833c flags r-x
    LOAD off    0x0000a33c vaddr 0x0b00833c paddr 0x0b009b5c align 2**12
         filesz 0x00001820 memsz 0x00001820 flags rw-
    LOAD off    0x0000c37c vaddr 0x0b00b37c paddr 0x0b00b37c align 2**12
         filesz 0x00000000 memsz 0x00000120 flags rw-
    LOAD off    0x0000c3b0 vaddr 0x0bff63b0 paddr 0x0bff63b0 align 2**12
         filesz 0x00000004 memsz 0x00000004 flags rw-
    LOAD off    0x0000c3b8 vaddr 0x0bff63b8 paddr 0x0bff63b8 align 2**12
         filesz 0x00000004 memsz 0x00000004 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  04000060  04000060  00001060  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000210  0b000000  0b000000  00002000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 RadMemory     00000000  0bff63c0  0bff63c0  0000c3bc  2**0
                  CONTENTS
  3 TempMemory    00000004  0bff63b8  0bff63b8  0000c3b8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 PressureMemory 00000004  0bff63b0  0bff63b0  0000c3b0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .text         00007fb0  0b000210  0b000210  00002210  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .rodata       0000017c  0b0081c0  0b0081c0  0000a1c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .rwdata       00001820  0b00833c  0b009b5c  0000a33c  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  8 .bss          00000120  0b00b37c  0b00b37c  0000c37c  2**2
                  ALLOC, SMALL_DATA
  9 .onchip       00000000  04000120  04000120  0000c3bc  2**0
                  CONTENTS
 10 .sdram        00000000  0b00b49c  0b00b49c  0000c3bc  2**0
                  CONTENTS
 11 .flash        00000000  0c001000  0c001000  0000c3bc  2**0
                  CONTENTS
 12 .comment      00000023  00000000  00000000  0000c3bc  2**0
                  CONTENTS, READONLY
 13 .debug_aranges 00000988  00000000  00000000  0000c3e0  2**3
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_info   0000d934  00000000  00000000  0000cd68  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_abbrev 00004a23  00000000  00000000  0001a69c  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_line   00005469  00000000  00000000  0001f0bf  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_frame  000015e4  00000000  00000000  00024528  2**2
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_str    0000307b  00000000  00000000  00025b0c  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_loc    00007d7a  00000000  00000000  00028b87  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_alt_sim_info 00000040  00000000  00000000  00030904  2**2
                  CONTENTS, READONLY, DEBUGGING
 21 .debug_ranges 00000be8  00000000  00000000  00030948  2**3
                  CONTENTS, READONLY, DEBUGGING
 22 .thread_model 00000003  00000000  00000000  00033dfa  2**0
                  CONTENTS, READONLY
 23 .cpu          00000006  00000000  00000000  00033dfd  2**0
                  CONTENTS, READONLY
 24 .qsys         00000001  00000000  00000000  00033e03  2**0
                  CONTENTS, READONLY
 25 .simulation_enabled 00000001  00000000  00000000  00033e04  2**0
                  CONTENTS, READONLY
 26 .sysid_hash   00000004  00000000  00000000  00033e05  2**0
                  CONTENTS, READONLY
 27 .sysid_base   00000004  00000000  00000000  00033e09  2**0
                  CONTENTS, READONLY
 28 .sysid_time   00000004  00000000  00000000  00033e0d  2**0
                  CONTENTS, READONLY
 29 .stderr_dev   0000000b  00000000  00000000  00033e11  2**0
                  CONTENTS, READONLY
 30 .stdin_dev    0000000b  00000000  00000000  00033e1c  2**0
                  CONTENTS, READONLY
 31 .stdout_dev   00000004  00000000  00000000  00033e27  2**0
                  CONTENTS, READONLY
 32 .sopc_system_name 00000005  00000000  00000000  00033e2b  2**0
                  CONTENTS, READONLY
 33 .quartus_project_dir 0000002d  00000000  00000000  00033e30  2**0
                  CONTENTS, READONLY
 34 .jdi          00007c1c  00000000  00000000  00033e5d  2**0
                  CONTENTS, READONLY
 35 .sopcinfo     0008a1be  00000000  00000000  0003ba79  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
04000060 l    d  .entry	00000000 .entry
0b000000 l    d  .exceptions	00000000 .exceptions
0bff63c0 l    d  RadMemory	00000000 RadMemory
0bff63b8 l    d  TempMemory	00000000 TempMemory
0bff63b0 l    d  PressureMemory	00000000 PressureMemory
0b000210 l    d  .text	00000000 .text
0b0081c0 l    d  .rodata	00000000 .rodata
0b00833c l    d  .rwdata	00000000 .rwdata
0b00b37c l    d  .bss	00000000 .bss
04000120 l    d  .onchip	00000000 .onchip
0b00b49c l    d  .sdram	00000000 .sdram
0c001000 l    d  .flash	00000000 .flash
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../nios_2_bsp//obj/HAL/src/crt0.o
0b000248 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 hello_world.c
00000000 l    df *ABS*	00000000 w_log.c
00000000 l    df *ABS*	00000000 e_log.c
00000000 l    df *ABS*	00000000 s_fpclassify.c
00000000 l    df *ABS*	00000000 s_lib_ver.c
00000000 l    df *ABS*	00000000 s_matherr.c
00000000 l    df *ABS*	00000000 s_nan.c
00000000 l    df *ABS*	00000000 divsf3.c
00000000 l    df *ABS*	00000000 adddf3.c
00000000 l    df *ABS*	00000000 divdf3.c
00000000 l    df *ABS*	00000000 eqdf2.c
00000000 l    df *ABS*	00000000 gedf2.c
00000000 l    df *ABS*	00000000 muldf3.c
00000000 l    df *ABS*	00000000 subdf3.c
00000000 l    df *ABS*	00000000 floatsidf.c
00000000 l    df *ABS*	00000000 extendsfdf2.c
00000000 l    df *ABS*	00000000 truncdfsf2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 lib2-mul.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 errno.c
00000000 l    df *ABS*	00000000 impure.c
0b00833c l     O .rwdata	00000424 impure_data
00000000 l    df *ABS*	00000000 alt_load.c
0b003ff0 l     F .text	00000068 alt_load_section
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
0b004188 l     F .text	00000034 alt_dev_reg
0b008760 l     O .rwdata	000000cc flash
0b00882c l     O .rwdata	00001060 jtag_uart_0
0b00988c l     O .rwdata	000000c4 uart
0b009950 l     O .rwdata	0000002c adc
00000000 l    df *ABS*	00000000 altera_avalon_epcs_flash_controller.c
0b00425c l     F .text	00000034 alt_flash_device_register
0b0042e4 l     F .text	000003f8 alt_epcs_flash_query
0b0046dc l     F .text	000000ec alt_epcs_flash_memcmp
0b004ab4 l     F .text	00000094 alt_epcs_test_address
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
0b004f7c l     F .text	0000020c altera_avalon_jtag_uart_irq
0b005188 l     F .text	000000a0 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_uart_init.c
0b00597c l     F .text	0000009c altera_avalon_uart_irq
0b005a18 l     F .text	000000e4 altera_avalon_uart_rxirq
0b005afc l     F .text	00000148 altera_avalon_uart_txirq
00000000 l    df *ABS*	00000000 altera_avalon_uart_read.c
0b005c98 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 altera_avalon_uart_write.c
0b005eb0 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 altera_up_avalon_adc.c
00000000 l    df *ABS*	00000000 epcs_commands.c
0b006248 l     F .text	00000038 epcs_test_wip
0b006280 l     F .text	0000003c epcs_await_wip_released
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_close.c
0b006aac l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
0b006be0 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
0b006c0c l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_flash_dev.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
0b0071b8 l     F .text	000000e4 alt_open_fd
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_open.c
0b007318 l     F .text	0000003c alt_get_errno
0b007354 l     F .text	000000ec alt_file_locked
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 altera_avalon_spi.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_exit.c
0b00b394 g     O .bss	00000004 alt_instruction_exception_handler
0b004a28 g     F .text	0000008c alt_epcs_flash_get_info
0b0040dc g     F .text	0000007c alt_main
0b00b39c g     O .bss	00000100 alt_irq
0b000744 g     F .text	0000019c log
0b009b5c g       *ABS*	00000000 __flash_rwdata_start
0b002740 g     F .text	00000088 .hidden __eqdf2
0c001000 g       *ABS*	00000000 __alt_mem_flash
0b001084 g     F .text	00000440 .hidden __divsf3
0b0027c8 g     F .text	000000dc .hidden __gtdf2
0b0077c4 g     F .text	00000024 altera_nios2_gen2_irq_init
0b003fe0 g     F .text	00000010 __errno
0b0062bc g     F .text	000000fc epcs_sector_erase
04000060 g     F .entry	0000000c __reset
0b000000 g       *ABS*	00000000 __flash_exceptions_start
0b00b398 g     O .bss	00000004 errno
0b00b380 g     O .bss	00000004 alt_argv
0b011b24 g       *ABS*	00000000 _gp
0b004158 g     F .text	00000030 usleep
0b0099a4 g     O .rwdata	00000180 alt_fd_list
0b000364 g     F .text	000003b8 getTemperature
0b006500 g     F .text	0000006c epcs_write_status_register
0b006dac g     F .text	00000090 alt_find_dev
0b007d14 g     F .text	00000148 memcpy
0b003a0c g     F .text	000000dc .hidden __floatsidf
0b00729c g     F .text	0000007c alt_io_redirect
0b0081c0 g       *ABS*	00000000 __DTOR_END__
0b007bb0 g     F .text	0000009c alt_exception_cause_generated_bad_addr
0b004bc0 g     F .text	00000100 alt_epcs_flash_write_block
0b000ffc g     F .text	00000074 __fpclassifyd
0b005380 g     F .text	0000021c altera_avalon_jtag_uart_read
0b003efc g     F .text	00000064 .hidden __udivsi3
0b009b40 g     O .rwdata	00000004 alt_max_fd
0b003ae8 g     F .text	00000110 .hidden __extendsfdf2
0bff63b8 g     O TempMemory	00000004 temp
0b0014c4 g     F .text	000008ac .hidden __adddf3
0b004b48 g     F .text	00000078 alt_epcs_flash_erase_block
0b009b24 g     O .rwdata	00000004 __fdlib_version
0b009b28 g     O .rwdata	00000004 _global_impure_ptr
0b0067cc g     F .text	0000005c epcs_exit_4_bytes_mode
0b00b49c g       *ABS*	00000000 __bss_end
0b0070c8 g     F .text	000000f0 alt_iic_isr_register
0b006098 g     F .text	0000003c alt_up_adc_open_dev
0b0076bc g     F .text	00000108 alt_tick
0b0058d0 g     F .text	000000ac altera_avalon_uart_init
0b00707c g     F .text	0000004c alt_ic_irq_enabled
0b007620 g     F .text	0000009c alt_alarm_stop
0b00b388 g     O .bss	00000004 alt_irq_active
0b0000dc g     F .exceptions	000000d4 alt_irq_handler
0b00997c g     O .rwdata	00000028 alt_dev_null
0b00071c g     F .text	00000028 getPressure
0b006bc0 g     F .text	00000020 alt_dcache_flush_all
0bff63b0 g     O PressureMemory	00000004 pressure
0b009b5c g       *ABS*	00000000 __ram_rwdata_end
0b009b38 g     O .rwdata	00000008 alt_dev_list
0b00833c g       *ABS*	00000000 __ram_rodata_end
0b003f60 g     F .text	00000058 .hidden __umodsi3
0b006688 g     F .text	00000068 epcs_read_electronic_signature
0b00b49c g       *ABS*	00000000 end
0b005eec g     F .text	000001ac altera_avalon_uart_write
0b004ebc g     F .text	000000c0 altera_avalon_jtag_uart_init
0b0001b0 g     F .exceptions	00000060 alt_instruction_exception_entry
0b0081c0 g       *ABS*	00000000 __CTOR_LIST__
0bff63b0 g       *ABS*	00000000 __alt_stack_pointer
0b005820 g     F .text	00000060 altera_avalon_uart_write_fd
0b003da0 g     F .text	00000064 .hidden __clzsi2
0b005880 g     F .text	00000050 altera_avalon_uart_close_fd
0b00559c g     F .text	00000224 altera_avalon_jtag_uart_write
0b00800c g     F .text	00000180 __call_exitprocs
0b000210 g     F .text	0000003c _start
0b00b38c g     O .bss	00000004 _alt_tick_rate
0b0077e8 g     F .text	000001fc alt_avalon_spi_command
0b00b390 g     O .bss	00000004 _alt_nticks
0b0041f4 g     F .text	00000068 alt_sys_init
0b007ef4 g     F .text	00000118 __register_exitproc
0b005228 g     F .text	00000068 altera_avalon_jtag_uart_close
0b003fb8 g     F .text	00000028 .hidden __mulsi3
0b00833c g       *ABS*	00000000 __ram_rwdata_start
0b0081c0 g       *ABS*	00000000 __ram_rodata_start
0b0061ec g     F .text	0000005c epcs_read_status_register
0b004d58 g     F .text	00000060 altera_avalon_jtag_uart_read_fd
0b007aec g     F .text	000000c4 alt_get_fd
0b006954 g     F .text	00000158 alt_busy_sleep
0b0066f0 g     F .text	00000080 epcs_read_device_id
0b007c98 g     F .text	0000007c memcmp
0b004e18 g     F .text	00000050 altera_avalon_jtag_uart_close_fd
0b00b49c g       *ABS*	00000000 __alt_stack_base
0b004e68 g     F .text	00000054 altera_avalon_jtag_uart_ioctl_fd
0b001d70 g     F .text	000009d0 .hidden __divdf3
0b0028a4 g     F .text	0000086c .hidden __muldf3
0b0079e4 g     F .text	00000108 alt_find_file
0b006c48 g     F .text	000000a4 alt_dev_llist_insert
0b009b48 g     O .rwdata	00000008 alt_flash_dev_list
0b00b37c g       *ABS*	00000000 __bss_start
0b00024c g     F .text	00000118 main
0b00b384 g     O .bss	00000004 alt_envp
0b004db8 g     F .text	00000060 altera_avalon_jtag_uart_write_fd
0b001070 g     F .text	00000008 matherr
0b003bf8 g     F .text	000001a8 .hidden __truncdfsf2
0b009b44 g     O .rwdata	00000004 alt_errno
0b0060d4 g     F .text	00000118 alt_up_adc_read
0b003e04 g     F .text	00000084 .hidden __divsi3
0b0081c0 g       *ABS*	00000000 __CTOR_END__
0b0047c8 g     F .text	00000260 alt_epcs_flash_write
0b0081c0 g       *ABS*	00000000 __flash_rodata_start
0b0081c0 g       *ABS*	00000000 __DTOR_LIST__
0b002740 g     F .text	00000088 .hidden __nedf2
0b0041bc g     F .text	00000038 alt_irq_init
0b00759c g     F .text	00000084 alt_release_fd
0b0081d1 g     O .rodata	00000100 .hidden __clz_tab
0b007c4c g     F .text	00000014 atexit
0b009b2c g     O .rwdata	00000004 _impure_ptr
0b00b37c g     O .bss	00000004 alt_argc
0b006d4c g     F .text	00000060 _do_dtors
0b0008e0 g     F .text	0000071c __ieee754_log
0b000000 g       .exceptions	00000000 alt_irq_entry
0b009b30 g     O .rwdata	00000008 alt_fs_list
0b001078 g     F .text	0000000c nan
0b000000 g       *ABS*	00000000 __ram_exceptions_start
0b0063b8 g     F .text	000000f4 epcs_read_buffer
0b004290 g     F .text	00000054 alt_epcs_flash_init
0b006f18 g     F .text	00000050 alt_ic_isr_register
0b009b5c g       *ABS*	00000000 _edata
0b0057c0 g     F .text	00000060 altera_avalon_uart_read_fd
0b00b49c g       *ABS*	00000000 _end
0b006e3c g     F .text	00000068 alt_flash_open_dev
0b000210 g       *ABS*	00000000 __ram_exceptions_end
0b005290 g     F .text	000000f0 altera_avalon_jtag_uart_ioctl
0b006ff0 g     F .text	0000008c alt_ic_irq_disable
0b006770 g     F .text	0000005c epcs_enter_4_bytes_mode
04000000 g       *ABS*	00000000 __alt_mem_onchip
0b007c60 g     F .text	00000038 exit
0b006ea4 g     F .text	00000054 alt_flash_close_dev
0b003e88 g     F .text	00000074 .hidden __modsi3
0bff63b0 g       *ABS*	00000000 __alt_data_end
0b000000 g     F .exceptions	00000000 alt_exception
0a000000 g       *ABS*	00000000 __alt_mem_sdram
0b005c44 g     F .text	00000054 altera_avalon_uart_close
0b00818c g     F .text	00000034 _exit
0b006828 g     F .text	0000012c alt_alarm_start
0b007e5c g     F .text	00000098 strlen
0b0064ac g     F .text	00000054 epcs_write_enable
0b007440 g     F .text	0000015c open
0b0027c8 g     F .text	000000dc .hidden __gedf2
0b006ef8 g     F .text	00000020 alt_icache_flush_all
0b009b50 g     O .rwdata	00000004 alt_priority_mask
0b006f68 g     F .text	00000088 alt_ic_irq_enable
0b005cd4 g     F .text	000001dc altera_avalon_uart_read
0b003110 g     F .text	000008fc .hidden __subdf3
0b004cc0 g     F .text	00000098 alt_epcs_flash_read
0b009b54 g     O .rwdata	00000008 alt_alarm_list
0b006cec g     F .text	00000060 _do_ctors
0b006ae8 g     F .text	000000d8 close
0b004058 g     F .text	00000084 alt_load
0b00656c g     F .text	0000011c epcs_write_buffer



Disassembly of section .entry:

04000060 <__reset>:
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
 4000060:	0042c034 	movhi	at,2816
    ori r1, r1, %lo(_start)
 4000064:	08408414 	ori	at,at,528
    jmp r1
 4000068:	0800683a 	jmp	at
	...

Disassembly of section .exceptions:

0b000000 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
 b000000:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
 b000004:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
 b000008:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
 b00000c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
 b000010:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
 b000014:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
 b000018:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
 b00001c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
 b000020:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
 b000024:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
 b000028:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
 b00002c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
 b000030:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
 b000034:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
 b000038:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
 b00003c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
 b000040:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
 b000044:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
 b000048:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
 b00004c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
 b000050:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
 b000054:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
 b000058:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
 b00005c:	10000326 	beq	r2,zero,b00006c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
 b000060:	20000226 	beq	r4,zero,b00006c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
 b000064:	b0000dc0 	call	b0000dc <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
 b000068:	00000706 	br	b000088 <alt_exception+0x88>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
 b00006c:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
 b000070:	e8bfff17 	ldw	r2,-4(ea)
         * debugger is present) or go into an infinite loop since the
         * handling behavior is undefined; in that case we will not return here.
         */

        /* Load exception-causing address as first argument (r4) */
        addi   r4, ea, -4
 b000074:	e93fff04 	addi	r4,ea,-4

        /* Call the instruction-exception entry */
        call   alt_instruction_exception_entry
 b000078:	b0001b00 	call	b0001b0 <alt_instruction_exception_entry>
         * instruction
         *
         * Return code was 0: Skip. The instruction after the exception is
         * already stored in 72(sp).
         */
        bne   r2, r0, .Lexception_exit
 b00007c:	1000021e 	bne	r2,zero,b000088 <alt_exception+0x88>

        /*
         * Otherwise, modify 72(sp) to re-issue the instruction that caused the
         * exception.
         */
        addi  r15, ea, -4  /* instruction that caused exception */
 b000080:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
 b000084:	dbc01215 	stw	r15,72(sp)
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
 b000088:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
 b00008c:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
 b000090:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
 b000094:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
 b000098:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
 b00009c:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
 b0000a0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
 b0000a4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
 b0000a8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
 b0000ac:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
 b0000b0:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
 b0000b4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
 b0000b8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
 b0000bc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
 b0000c0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
 b0000c4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
 b0000c8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
 b0000cc:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
 b0000d0:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
 b0000d4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
 b0000d8:	ef80083a 	eret

0b0000dc <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
 b0000dc:	defff904 	addi	sp,sp,-28
 b0000e0:	dfc00615 	stw	ra,24(sp)
 b0000e4:	df000515 	stw	fp,20(sp)
 b0000e8:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
 b0000ec:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 b0000f0:	0005313a 	rdctl	r2,ipending
 b0000f4:	e0bffe15 	stw	r2,-8(fp)

  return active;
 b0000f8:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
 b0000fc:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
 b000100:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
 b000104:	00800044 	movi	r2,1
 b000108:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
 b00010c:	e0fffb17 	ldw	r3,-20(fp)
 b000110:	e0bffc17 	ldw	r2,-16(fp)
 b000114:	1884703a 	and	r2,r3,r2
 b000118:	10001426 	beq	r2,zero,b00016c <alt_irq_handler+0x90>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
 b00011c:	0082c074 	movhi	r2,2817
 b000120:	10ace704 	addi	r2,r2,-19556
 b000124:	e0fffd17 	ldw	r3,-12(fp)
 b000128:	180690fa 	slli	r3,r3,3
 b00012c:	10c5883a 	add	r2,r2,r3
 b000130:	10c00017 	ldw	r3,0(r2)
 b000134:	0082c074 	movhi	r2,2817
 b000138:	10ace704 	addi	r2,r2,-19556
 b00013c:	e13ffd17 	ldw	r4,-12(fp)
 b000140:	200890fa 	slli	r4,r4,3
 b000144:	1105883a 	add	r2,r2,r4
 b000148:	10800104 	addi	r2,r2,4
 b00014c:	10800017 	ldw	r2,0(r2)
 b000150:	1009883a 	mov	r4,r2
 b000154:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
 b000158:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 b00015c:	0005313a 	rdctl	r2,ipending
 b000160:	e0bfff15 	stw	r2,-4(fp)

  return active;
 b000164:	e0bfff17 	ldw	r2,-4(fp)
 b000168:	00000706 	br	b000188 <alt_irq_handler+0xac>
      }
      mask <<= 1;
 b00016c:	e0bffc17 	ldw	r2,-16(fp)
 b000170:	1085883a 	add	r2,r2,r2
 b000174:	e0bffc15 	stw	r2,-16(fp)
      i++;
 b000178:	e0bffd17 	ldw	r2,-12(fp)
 b00017c:	10800044 	addi	r2,r2,1
 b000180:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
 b000184:	003fe106 	br	b00010c <__alt_mem_flash+0xfefff10c>

    active = alt_irq_pending ();
 b000188:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
 b00018c:	e0bffb17 	ldw	r2,-20(fp)
 b000190:	103fdb1e 	bne	r2,zero,b000100 <__alt_mem_flash+0xfefff100>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
 b000194:	0001883a 	nop
}
 b000198:	0001883a 	nop
 b00019c:	e037883a 	mov	sp,fp
 b0001a0:	dfc00117 	ldw	ra,4(sp)
 b0001a4:	df000017 	ldw	fp,0(sp)
 b0001a8:	dec00204 	addi	sp,sp,8
 b0001ac:	f800283a 	ret

0b0001b0 <alt_instruction_exception_entry>:
 * that handler if it has been registered. Absent a handler, it will
 * break break or hang as discussed below.
 */
int 
alt_instruction_exception_entry (alt_u32 exception_pc)
{
 b0001b0:	defffb04 	addi	sp,sp,-20
 b0001b4:	dfc00415 	stw	ra,16(sp)
 b0001b8:	df000315 	stw	fp,12(sp)
 b0001bc:	df000304 	addi	fp,sp,12
 b0001c0:	e13fff15 	stw	r4,-4(fp)
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
              NIOS2_EXCEPTION_REG_CAUSE_OFST );

  NIOS2_READ_BADADDR(badaddr);
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
 b0001c4:	00bfffc4 	movi	r2,-1
 b0001c8:	e0bffd15 	stw	r2,-12(fp)
  badaddr = 0;
 b0001cc:	e03ffe15 	stw	zero,-8(fp)
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
 b0001d0:	d0a61c17 	ldw	r2,-26512(gp)
 b0001d4:	10000726 	beq	r2,zero,b0001f4 <alt_instruction_exception_entry+0x44>
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
 b0001d8:	d0a61c17 	ldw	r2,-26512(gp)
 b0001dc:	e0fffd17 	ldw	r3,-12(fp)
 b0001e0:	e1bffe17 	ldw	r6,-8(fp)
 b0001e4:	e17fff17 	ldw	r5,-4(fp)
 b0001e8:	1809883a 	mov	r4,r3
 b0001ec:	103ee83a 	callr	r2
 b0001f0:	00000206 	br	b0001fc <alt_instruction_exception_entry+0x4c>
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
 b0001f4:	003da03a 	break	0
      ;
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
 b0001f8:	0005883a 	mov	r2,zero
}
 b0001fc:	e037883a 	mov	sp,fp
 b000200:	dfc00117 	ldw	ra,4(sp)
 b000204:	df000017 	ldw	fp,0(sp)
 b000208:	dec00204 	addi	sp,sp,8
 b00020c:	f800283a 	ret

Disassembly of section .text:

0b000210 <_start>:

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
 b000210:	06c2fff4 	movhi	sp,3071
    ori sp, sp, %lo(__alt_stack_pointer)
 b000214:	ded8ec14 	ori	sp,sp,25520
    movhi gp, %hi(_gp)
 b000218:	0682c074 	movhi	gp,2817
    ori gp, gp, %lo(_gp)
 b00021c:	d686c914 	ori	gp,gp,6948
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
 b000220:	0082c034 	movhi	r2,2816
    ori r2, r2, %lo(__bss_start)
 b000224:	10acdf14 	ori	r2,r2,45948

    movhi r3, %hi(__bss_end)
 b000228:	00c2c034 	movhi	r3,2816
    ori r3, r3, %lo(__bss_end)
 b00022c:	18ed2714 	ori	r3,r3,46236

    beq r2, r3, 1f
 b000230:	10c00326 	beq	r2,r3,b000240 <_start+0x30>

0:
    stw zero, (r2)
 b000234:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
 b000238:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
 b00023c:	10fffd36 	bltu	r2,r3,b000234 <__alt_mem_flash+0xfefff234>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
 b000240:	b0040580 	call	b004058 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
 b000244:	b0040dc0 	call	b0040dc <alt_main>

0b000248 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
 b000248:	003fff06 	br	b000248 <__alt_mem_flash+0xfefff248>

0b00024c <main>:

float getTemperature(int);
float getPressure(int);

int main()
{
 b00024c:	defff504 	addi	sp,sp,-44
 b000250:	dfc00a15 	stw	ra,40(sp)
 b000254:	df000915 	stw	fp,36(sp)
 b000258:	df000904 	addi	fp,sp,36
	int *tailIndex = (int *)SHARED_RAD_BASE;
 b00025c:	0082fff4 	movhi	r2,3071
 b000260:	1098f004 	addi	r2,r2,25536
 b000264:	e0bff715 	stw	r2,-36(fp)
	int radData = 0;
 b000268:	e03ff815 	stw	zero,-32(fp)
	int presData = 0;
 b00026c:	e03ff915 	stw	zero,-28(fp)
	int tempData = 0;
 b000270:	e03ffa15 	stw	zero,-24(fp)
	int radChannel = 1;
 b000274:	00800044 	movi	r2,1
 b000278:	e0bffb15 	stw	r2,-20(fp)
	int presChannel = 3;
 b00027c:	008000c4 	movi	r2,3
 b000280:	e0bffc15 	stw	r2,-16(fp)
	int tempChannel = 5;
 b000284:	00800144 	movi	r2,5
 b000288:	e0bffd15 	stw	r2,-12(fp)
	int count = 0;
 b00028c:	e03ffe15 	stw	zero,-8(fp)
	alt_up_adc_dev *adc = alt_up_adc_open_dev(ADC_NAME);
 b000290:	0102c074 	movhi	r4,2817
 b000294:	21207004 	addi	r4,r4,-32320
 b000298:	b0060980 	call	b006098 <alt_up_adc_open_dev>
 b00029c:	e0bfff15 	stw	r2,-4(fp)
	while (tailIndex < (int *)SHARED_RAD_END) {
 b0002a0:	00000706 	br	b0002c0 <main+0x74>
		*tailIndex = FLAG;
 b0002a4:	e0fff717 	ldw	r3,-36(fp)
 b0002a8:	00a00034 	movhi	r2,32768
 b0002ac:	10bfffc4 	addi	r2,r2,-1
 b0002b0:	18800015 	stw	r2,0(r3)
		tailIndex ++;
 b0002b4:	e0bff717 	ldw	r2,-36(fp)
 b0002b8:	10800104 	addi	r2,r2,4
 b0002bc:	e0bff715 	stw	r2,-36(fp)
	int radChannel = 1;
	int presChannel = 3;
	int tempChannel = 5;
	int count = 0;
	alt_up_adc_dev *adc = alt_up_adc_open_dev(ADC_NAME);
	while (tailIndex < (int *)SHARED_RAD_END) {
 b0002c0:	e0fff717 	ldw	r3,-36(fp)
 b0002c4:	00830034 	movhi	r2,3072
 b0002c8:	10bfff84 	addi	r2,r2,-2
 b0002cc:	10fff52e 	bgeu	r2,r3,b0002a4 <__alt_mem_flash+0xfefff2a4>
		*tailIndex = FLAG;
		tailIndex ++;
	}
	temp = FLAG;
 b0002d0:	0082fff4 	movhi	r2,3071
 b0002d4:	1098ee04 	addi	r2,r2,25528
 b0002d8:	00d3c034 	movhi	r3,20224
 b0002dc:	10c00015 	stw	r3,0(r2)
	tailIndex = (int *) SHARED_RAD_BASE;
 b0002e0:	0082fff4 	movhi	r2,3071
 b0002e4:	1098f004 	addi	r2,r2,25536
 b0002e8:	e0bff715 	stw	r2,-36(fp)
	while (1) {
		while (adc != NULL) {
 b0002ec:	00001a06 	br	b000358 <main+0x10c>
			usleep(10);
 b0002f0:	01000284 	movi	r4,10
 b0002f4:	b0041580 	call	b004158 <usleep>
			alt_up_adc_update(adc);
 b0002f8:	e0bfff17 	ldw	r2,-4(fp)
 b0002fc:	10800a17 	ldw	r2,40(r2)
 b000300:	0007883a 	mov	r3,zero
 b000304:	10c00035 	stwio	r3,0(r2)
			radData = alt_up_adc_read(adc, 5);
 b000308:	01400144 	movi	r5,5
 b00030c:	e13fff17 	ldw	r4,-4(fp)
 b000310:	b0060d40 	call	b0060d4 <alt_up_adc_read>
 b000314:	e0bff815 	stw	r2,-32(fp)
			radData += 1;
 b000318:	e0bff817 	ldw	r2,-32(fp)
 b00031c:	10800044 	addi	r2,r2,1
 b000320:	e0bff815 	stw	r2,-32(fp)
			//fprintf(stderr, "%d!\n", data);
			*tailIndex = radData;
 b000324:	e0bff717 	ldw	r2,-36(fp)
 b000328:	e0fff817 	ldw	r3,-32(fp)
 b00032c:	10c00015 	stw	r3,0(r2)
			tailIndex ++;
 b000330:	e0bff717 	ldw	r2,-36(fp)
 b000334:	10800104 	addi	r2,r2,4
 b000338:	e0bff715 	stw	r2,-36(fp)
			if (tailIndex < (int *)SHARED_RAD_END) {
 b00033c:	e0fff717 	ldw	r3,-36(fp)
 b000340:	00830034 	movhi	r2,3072
 b000344:	10bfff84 	addi	r2,r2,-2
 b000348:	10c00336 	bltu	r2,r3,b000358 <main+0x10c>
				tailIndex = (int *)SHARED_RAD_BASE;
 b00034c:	0082fff4 	movhi	r2,3071
 b000350:	1098f004 	addi	r2,r2,25536
 b000354:	e0bff715 	stw	r2,-36(fp)
		tailIndex ++;
	}
	temp = FLAG;
	tailIndex = (int *) SHARED_RAD_BASE;
	while (1) {
		while (adc != NULL) {
 b000358:	e0bfff17 	ldw	r2,-4(fp)
 b00035c:	103fe41e 	bne	r2,zero,b0002f0 <__alt_mem_flash+0xfefff2f0>
//				count = 0;
//			} else {
//				count ++;
//			}
		}
	}
 b000360:	003fe206 	br	b0002ec <__alt_mem_flash+0xfefff2ec>

0b000364 <getTemperature>:
  return 0;
}

float getTemperature (int tempData){
 b000364:	defff404 	addi	sp,sp,-48
 b000368:	dfc00b15 	stw	ra,44(sp)
 b00036c:	df000a15 	stw	fp,40(sp)
 b000370:	dcc00915 	stw	r19,36(sp)
 b000374:	dc800815 	stw	r18,32(sp)
 b000378:	dc400715 	stw	r17,28(sp)
 b00037c:	dc000615 	stw	r16,24(sp)
 b000380:	df000a04 	addi	fp,sp,40
 b000384:	e13ffb15 	stw	r4,-20(fp)
	//converts the adc reading into an actual voltage based off of slope.
	float voltage = (0.000502512562 * tempData - 0.095979899);
 b000388:	e13ffb17 	ldw	r4,-20(fp)
 b00038c:	b003a0c0 	call	b003a0c <__floatsidf>
 b000390:	1011883a 	mov	r8,r2
 b000394:	1813883a 	mov	r9,r3
 b000398:	01a0a0f4 	movhi	r6,33411
 b00039c:	31b86304 	addi	r6,r6,-7796
 b0003a0:	01cfd034 	movhi	r7,16192
 b0003a4:	39ddd844 	addi	r7,r7,30561
 b0003a8:	4009883a 	mov	r4,r8
 b0003ac:	480b883a 	mov	r5,r9
 b0003b0:	b0028a40 	call	b0028a4 <__muldf3>
 b0003b4:	1009883a 	mov	r4,r2
 b0003b8:	180b883a 	mov	r5,r3
 b0003bc:	2005883a 	mov	r2,r4
 b0003c0:	2807883a 	mov	r3,r5
 b0003c4:	019fd1f4 	movhi	r6,32583
 b0003c8:	31910744 	addi	r6,r6,17437
 b0003cc:	01cfee74 	movhi	r7,16313
 b0003d0:	39e488c4 	addi	r7,r7,-28125
 b0003d4:	1009883a 	mov	r4,r2
 b0003d8:	180b883a 	mov	r5,r3
 b0003dc:	b0031100 	call	b003110 <__subdf3>
 b0003e0:	1009883a 	mov	r4,r2
 b0003e4:	180b883a 	mov	r5,r3
 b0003e8:	2005883a 	mov	r2,r4
 b0003ec:	2807883a 	mov	r3,r5
 b0003f0:	1009883a 	mov	r4,r2
 b0003f4:	180b883a 	mov	r5,r3
 b0003f8:	b003bf80 	call	b003bf8 <__truncdfsf2>
 b0003fc:	1007883a 	mov	r3,r2
 b000400:	e0fff615 	stw	r3,-40(fp)
	//Need to convert our voltage reading into the resistance across the thermistor. To find this we use 3.3(R1)/(3.3-vadc) - R1
	float resistance = (3.3 * 10000)/(3.3 - voltage) - 10000;
 b000404:	e13ff617 	ldw	r4,-40(fp)
 b000408:	b003ae80 	call	b003ae8 <__extendsfdf2>
 b00040c:	1009883a 	mov	r4,r2
 b000410:	180b883a 	mov	r5,r3
 b000414:	200d883a 	mov	r6,r4
 b000418:	280f883a 	mov	r7,r5
 b00041c:	011999b4 	movhi	r4,26214
 b000420:	21199984 	addi	r4,r4,26214
 b000424:	015002b4 	movhi	r5,16394
 b000428:	29599984 	addi	r5,r5,26214
 b00042c:	b0031100 	call	b003110 <__subdf3>
 b000430:	1009883a 	mov	r4,r2
 b000434:	180b883a 	mov	r5,r3
 b000438:	2005883a 	mov	r2,r4
 b00043c:	2807883a 	mov	r3,r5
 b000440:	100d883a 	mov	r6,r2
 b000444:	180f883a 	mov	r7,r3
 b000448:	0009883a 	mov	r4,zero
 b00044c:	01503834 	movhi	r5,16608
 b000450:	29474004 	addi	r5,r5,7424
 b000454:	b001d700 	call	b001d70 <__divdf3>
 b000458:	1009883a 	mov	r4,r2
 b00045c:	180b883a 	mov	r5,r3
 b000460:	2005883a 	mov	r2,r4
 b000464:	2807883a 	mov	r3,r5
 b000468:	000d883a 	mov	r6,zero
 b00046c:	01d03134 	movhi	r7,16580
 b000470:	39e20004 	addi	r7,r7,-30720
 b000474:	1009883a 	mov	r4,r2
 b000478:	180b883a 	mov	r5,r3
 b00047c:	b0031100 	call	b003110 <__subdf3>
 b000480:	1009883a 	mov	r4,r2
 b000484:	180b883a 	mov	r5,r3
 b000488:	2005883a 	mov	r2,r4
 b00048c:	2807883a 	mov	r3,r5
 b000490:	1009883a 	mov	r4,r2
 b000494:	180b883a 	mov	r5,r3
 b000498:	b003bf80 	call	b003bf8 <__truncdfsf2>
 b00049c:	1007883a 	mov	r3,r2
 b0004a0:	e0fff715 	stw	r3,-36(fp)
	//constants for the NTCLE100E3103HT1 in the Steinhart-Hart equation (T = 1/(A + Bln(resistance) + Dln^3(resistance))
	float a_const = 0.003354016;
 b0004a4:	008ed734 	movhi	r2,15196
 b0004a8:	10b3c344 	addi	r2,r2,-12531
 b0004ac:	e0bff815 	stw	r2,-32(fp)
	float b_const = 0.000256985;
 b0004b0:	008e61f4 	movhi	r2,14727
 b0004b4:	10aefc44 	addi	r2,r2,-17423
 b0004b8:	e0bff915 	stw	r2,-28(fp)
	float d_const = 0.00000006383091;
 b0004bc:	008ce274 	movhi	r2,13193
 b0004c0:	1084da84 	addi	r2,r2,4970
 b0004c4:	e0bffa15 	stw	r2,-24(fp)
	//Steinhart-Hart to find temperature then return it.
	return 1 / (a_const + b_const * log(resistance / 10000) + d_const * log(resistance / 10000) * log(resistance / 10000) * log(resistance / 10000));
 b0004c8:	e13ff817 	ldw	r4,-32(fp)
 b0004cc:	b003ae80 	call	b003ae8 <__extendsfdf2>
 b0004d0:	1021883a 	mov	r16,r2
 b0004d4:	1823883a 	mov	r17,r3
 b0004d8:	e13ff917 	ldw	r4,-28(fp)
 b0004dc:	b003ae80 	call	b003ae8 <__extendsfdf2>
 b0004e0:	1025883a 	mov	r18,r2
 b0004e4:	1827883a 	mov	r19,r3
 b0004e8:	01518734 	movhi	r5,17948
 b0004ec:	29500004 	addi	r5,r5,16384
 b0004f0:	e13ff717 	ldw	r4,-36(fp)
 b0004f4:	b0010840 	call	b001084 <__divsf3>
 b0004f8:	1007883a 	mov	r3,r2
 b0004fc:	1805883a 	mov	r2,r3
 b000500:	1009883a 	mov	r4,r2
 b000504:	b003ae80 	call	b003ae8 <__extendsfdf2>
 b000508:	100b883a 	mov	r5,r2
 b00050c:	180d883a 	mov	r6,r3
 b000510:	2809883a 	mov	r4,r5
 b000514:	300b883a 	mov	r5,r6
 b000518:	b0007440 	call	b000744 <log>
 b00051c:	1009883a 	mov	r4,r2
 b000520:	180b883a 	mov	r5,r3
 b000524:	200d883a 	mov	r6,r4
 b000528:	280f883a 	mov	r7,r5
 b00052c:	9009883a 	mov	r4,r18
 b000530:	980b883a 	mov	r5,r19
 b000534:	b0028a40 	call	b0028a4 <__muldf3>
 b000538:	1009883a 	mov	r4,r2
 b00053c:	180b883a 	mov	r5,r3
 b000540:	2005883a 	mov	r2,r4
 b000544:	2807883a 	mov	r3,r5
 b000548:	100d883a 	mov	r6,r2
 b00054c:	180f883a 	mov	r7,r3
 b000550:	8009883a 	mov	r4,r16
 b000554:	880b883a 	mov	r5,r17
 b000558:	b0014c40 	call	b0014c4 <__adddf3>
 b00055c:	1009883a 	mov	r4,r2
 b000560:	180b883a 	mov	r5,r3
 b000564:	2021883a 	mov	r16,r4
 b000568:	2823883a 	mov	r17,r5
 b00056c:	e13ffa17 	ldw	r4,-24(fp)
 b000570:	b003ae80 	call	b003ae8 <__extendsfdf2>
 b000574:	1025883a 	mov	r18,r2
 b000578:	1827883a 	mov	r19,r3
 b00057c:	01518734 	movhi	r5,17948
 b000580:	29500004 	addi	r5,r5,16384
 b000584:	e13ff717 	ldw	r4,-36(fp)
 b000588:	b0010840 	call	b001084 <__divsf3>
 b00058c:	1007883a 	mov	r3,r2
 b000590:	1805883a 	mov	r2,r3
 b000594:	1009883a 	mov	r4,r2
 b000598:	b003ae80 	call	b003ae8 <__extendsfdf2>
 b00059c:	100b883a 	mov	r5,r2
 b0005a0:	180d883a 	mov	r6,r3
 b0005a4:	2809883a 	mov	r4,r5
 b0005a8:	300b883a 	mov	r5,r6
 b0005ac:	b0007440 	call	b000744 <log>
 b0005b0:	1009883a 	mov	r4,r2
 b0005b4:	180b883a 	mov	r5,r3
 b0005b8:	200d883a 	mov	r6,r4
 b0005bc:	280f883a 	mov	r7,r5
 b0005c0:	9009883a 	mov	r4,r18
 b0005c4:	980b883a 	mov	r5,r19
 b0005c8:	b0028a40 	call	b0028a4 <__muldf3>
 b0005cc:	1009883a 	mov	r4,r2
 b0005d0:	180b883a 	mov	r5,r3
 b0005d4:	2025883a 	mov	r18,r4
 b0005d8:	2827883a 	mov	r19,r5
 b0005dc:	01518734 	movhi	r5,17948
 b0005e0:	29500004 	addi	r5,r5,16384
 b0005e4:	e13ff717 	ldw	r4,-36(fp)
 b0005e8:	b0010840 	call	b001084 <__divsf3>
 b0005ec:	1007883a 	mov	r3,r2
 b0005f0:	1805883a 	mov	r2,r3
 b0005f4:	1009883a 	mov	r4,r2
 b0005f8:	b003ae80 	call	b003ae8 <__extendsfdf2>
 b0005fc:	100b883a 	mov	r5,r2
 b000600:	180d883a 	mov	r6,r3
 b000604:	2809883a 	mov	r4,r5
 b000608:	300b883a 	mov	r5,r6
 b00060c:	b0007440 	call	b000744 <log>
 b000610:	1009883a 	mov	r4,r2
 b000614:	180b883a 	mov	r5,r3
 b000618:	200d883a 	mov	r6,r4
 b00061c:	280f883a 	mov	r7,r5
 b000620:	9009883a 	mov	r4,r18
 b000624:	980b883a 	mov	r5,r19
 b000628:	b0028a40 	call	b0028a4 <__muldf3>
 b00062c:	1009883a 	mov	r4,r2
 b000630:	180b883a 	mov	r5,r3
 b000634:	2025883a 	mov	r18,r4
 b000638:	2827883a 	mov	r19,r5
 b00063c:	01518734 	movhi	r5,17948
 b000640:	29500004 	addi	r5,r5,16384
 b000644:	e13ff717 	ldw	r4,-36(fp)
 b000648:	b0010840 	call	b001084 <__divsf3>
 b00064c:	1007883a 	mov	r3,r2
 b000650:	1805883a 	mov	r2,r3
 b000654:	1009883a 	mov	r4,r2
 b000658:	b003ae80 	call	b003ae8 <__extendsfdf2>
 b00065c:	100b883a 	mov	r5,r2
 b000660:	180d883a 	mov	r6,r3
 b000664:	2809883a 	mov	r4,r5
 b000668:	300b883a 	mov	r5,r6
 b00066c:	b0007440 	call	b000744 <log>
 b000670:	1009883a 	mov	r4,r2
 b000674:	180b883a 	mov	r5,r3
 b000678:	200d883a 	mov	r6,r4
 b00067c:	280f883a 	mov	r7,r5
 b000680:	9009883a 	mov	r4,r18
 b000684:	980b883a 	mov	r5,r19
 b000688:	b0028a40 	call	b0028a4 <__muldf3>
 b00068c:	1009883a 	mov	r4,r2
 b000690:	180b883a 	mov	r5,r3
 b000694:	2005883a 	mov	r2,r4
 b000698:	2807883a 	mov	r3,r5
 b00069c:	100d883a 	mov	r6,r2
 b0006a0:	180f883a 	mov	r7,r3
 b0006a4:	8009883a 	mov	r4,r16
 b0006a8:	880b883a 	mov	r5,r17
 b0006ac:	b0014c40 	call	b0014c4 <__adddf3>
 b0006b0:	1009883a 	mov	r4,r2
 b0006b4:	180b883a 	mov	r5,r3
 b0006b8:	2005883a 	mov	r2,r4
 b0006bc:	2807883a 	mov	r3,r5
 b0006c0:	100d883a 	mov	r6,r2
 b0006c4:	180f883a 	mov	r7,r3
 b0006c8:	0009883a 	mov	r4,zero
 b0006cc:	014ffc34 	movhi	r5,16368
 b0006d0:	b001d700 	call	b001d70 <__divdf3>
 b0006d4:	1009883a 	mov	r4,r2
 b0006d8:	180b883a 	mov	r5,r3
 b0006dc:	2005883a 	mov	r2,r4
 b0006e0:	2807883a 	mov	r3,r5
 b0006e4:	1009883a 	mov	r4,r2
 b0006e8:	180b883a 	mov	r5,r3
 b0006ec:	b003bf80 	call	b003bf8 <__truncdfsf2>
 b0006f0:	1007883a 	mov	r3,r2
 b0006f4:	1805883a 	mov	r2,r3
}
 b0006f8:	e6fffc04 	addi	sp,fp,-16
 b0006fc:	dfc00517 	ldw	ra,20(sp)
 b000700:	df000417 	ldw	fp,16(sp)
 b000704:	dcc00317 	ldw	r19,12(sp)
 b000708:	dc800217 	ldw	r18,8(sp)
 b00070c:	dc400117 	ldw	r17,4(sp)
 b000710:	dc000017 	ldw	r16,0(sp)
 b000714:	dec00604 	addi	sp,sp,24
 b000718:	f800283a 	ret

0b00071c <getPressure>:

float getPressure (int pressureData) {
 b00071c:	defffe04 	addi	sp,sp,-8
 b000720:	df000115 	stw	fp,4(sp)
 b000724:	df000104 	addi	fp,sp,4
 b000728:	e13fff15 	stw	r4,-4(fp)
	return 0;
 b00072c:	0007883a 	mov	r3,zero
 b000730:	1805883a 	mov	r2,r3
}
 b000734:	e037883a 	mov	sp,fp
 b000738:	df000017 	ldw	fp,0(sp)
 b00073c:	dec00104 	addi	sp,sp,4
 b000740:	f800283a 	ret

0b000744 <log>:
 b000744:	defff104 	addi	sp,sp,-60
 b000748:	dd000d15 	stw	r20,52(sp)
 b00074c:	0502c074 	movhi	r20,2817
 b000750:	dcc00c15 	stw	r19,48(sp)
 b000754:	dc800b15 	stw	r18,44(sp)
 b000758:	dc400a15 	stw	r17,40(sp)
 b00075c:	dc000915 	stw	r16,36(sp)
 b000760:	dfc00e15 	stw	ra,56(sp)
 b000764:	a526c904 	addi	r20,r20,-25820
 b000768:	2027883a 	mov	r19,r4
 b00076c:	2825883a 	mov	r18,r5
 b000770:	b0008e00 	call	b0008e0 <__ieee754_log>
 b000774:	1821883a 	mov	r16,r3
 b000778:	a0c00017 	ldw	r3,0(r20)
 b00077c:	1023883a 	mov	r17,r2
 b000780:	00bfffc4 	movi	r2,-1
 b000784:	18800a26 	beq	r3,r2,b0007b0 <log+0x6c>
 b000788:	9809883a 	mov	r4,r19
 b00078c:	900b883a 	mov	r5,r18
 b000790:	b000ffc0 	call	b000ffc <__fpclassifyd>
 b000794:	10000626 	beq	r2,zero,b0007b0 <log+0x6c>
 b000798:	000d883a 	mov	r6,zero
 b00079c:	000f883a 	mov	r7,zero
 b0007a0:	9809883a 	mov	r4,r19
 b0007a4:	900b883a 	mov	r5,r18
 b0007a8:	b0027c80 	call	b0027c8 <__gedf2>
 b0007ac:	00800a0e 	bge	zero,r2,b0007d8 <log+0x94>
 b0007b0:	8805883a 	mov	r2,r17
 b0007b4:	8007883a 	mov	r3,r16
 b0007b8:	dfc00e17 	ldw	ra,56(sp)
 b0007bc:	dd000d17 	ldw	r20,52(sp)
 b0007c0:	dcc00c17 	ldw	r19,48(sp)
 b0007c4:	dc800b17 	ldw	r18,44(sp)
 b0007c8:	dc400a17 	ldw	r17,40(sp)
 b0007cc:	dc000917 	ldw	r16,36(sp)
 b0007d0:	dec00f04 	addi	sp,sp,60
 b0007d4:	f800283a 	ret
 b0007d8:	0082c074 	movhi	r2,2817
 b0007dc:	a4000017 	ldw	r16,0(r20)
 b0007e0:	10a07304 	addi	r2,r2,-32308
 b0007e4:	d8000815 	stw	zero,32(sp)
 b0007e8:	d8800115 	stw	r2,4(sp)
 b0007ec:	dcc00215 	stw	r19,8(sp)
 b0007f0:	dc800315 	stw	r18,12(sp)
 b0007f4:	dcc00415 	stw	r19,16(sp)
 b0007f8:	dc800515 	stw	r18,20(sp)
 b0007fc:	000d883a 	mov	r6,zero
 b000800:	000f883a 	mov	r7,zero
 b000804:	9809883a 	mov	r4,r19
 b000808:	900b883a 	mov	r5,r18
 b00080c:	8000101e 	bne	r16,zero,b000850 <log+0x10c>
 b000810:	00b80034 	movhi	r2,57344
 b000814:	d8800615 	stw	r2,24(sp)
 b000818:	00b1fc34 	movhi	r2,51184
 b00081c:	10bfffc4 	addi	r2,r2,-1
 b000820:	d8800715 	stw	r2,28(sp)
 b000824:	b0027400 	call	b002740 <__eqdf2>
 b000828:	10001f1e 	bne	r2,zero,b0008a8 <log+0x164>
 b00082c:	00800084 	movi	r2,2
 b000830:	d8800015 	stw	r2,0(sp)
 b000834:	d809883a 	mov	r4,sp
 b000838:	b0010700 	call	b001070 <matherr>
 b00083c:	1000151e 	bne	r2,zero,b000894 <log+0x150>
 b000840:	b003fe00 	call	b003fe0 <__errno>
 b000844:	00c00884 	movi	r3,34
 b000848:	10c00015 	stw	r3,0(r2)
 b00084c:	00001106 	br	b000894 <log+0x150>
 b000850:	00bffc34 	movhi	r2,65520
 b000854:	d8000615 	stw	zero,24(sp)
 b000858:	d8800715 	stw	r2,28(sp)
 b00085c:	b0027400 	call	b002740 <__eqdf2>
 b000860:	10001726 	beq	r2,zero,b0008c0 <log+0x17c>
 b000864:	00800044 	movi	r2,1
 b000868:	d8800015 	stw	r2,0(sp)
 b00086c:	00800084 	movi	r2,2
 b000870:	80800f1e 	bne	r16,r2,b0008b0 <log+0x16c>
 b000874:	b003fe00 	call	b003fe0 <__errno>
 b000878:	00c00844 	movi	r3,33
 b00087c:	10c00015 	stw	r3,0(r2)
 b000880:	0102c074 	movhi	r4,2817
 b000884:	21207404 	addi	r4,r4,-32304
 b000888:	b0010780 	call	b001078 <nan>
 b00088c:	d8800615 	stw	r2,24(sp)
 b000890:	d8c00715 	stw	r3,28(sp)
 b000894:	d8800817 	ldw	r2,32(sp)
 b000898:	10000d1e 	bne	r2,zero,b0008d0 <log+0x18c>
 b00089c:	d8800617 	ldw	r2,24(sp)
 b0008a0:	d8c00717 	ldw	r3,28(sp)
 b0008a4:	003fc406 	br	b0007b8 <__alt_mem_flash+0xfefff7b8>
 b0008a8:	00800044 	movi	r2,1
 b0008ac:	d8800015 	stw	r2,0(sp)
 b0008b0:	d809883a 	mov	r4,sp
 b0008b4:	b0010700 	call	b001070 <matherr>
 b0008b8:	103ff11e 	bne	r2,zero,b000880 <__alt_mem_flash+0xfefff880>
 b0008bc:	003fed06 	br	b000874 <__alt_mem_flash+0xfefff874>
 b0008c0:	00800084 	movi	r2,2
 b0008c4:	d8800015 	stw	r2,0(sp)
 b0008c8:	80bfdd26 	beq	r16,r2,b000840 <__alt_mem_flash+0xfefff840>
 b0008cc:	003fd906 	br	b000834 <__alt_mem_flash+0xfefff834>
 b0008d0:	b003fe00 	call	b003fe0 <__errno>
 b0008d4:	d8c00817 	ldw	r3,32(sp)
 b0008d8:	10c00015 	stw	r3,0(r2)
 b0008dc:	003fef06 	br	b00089c <__alt_mem_flash+0xfefff89c>

0b0008e0 <__ieee754_log>:
 b0008e0:	defff204 	addi	sp,sp,-56
 b0008e4:	01800434 	movhi	r6,16
 b0008e8:	dfc00d15 	stw	ra,52(sp)
 b0008ec:	df000c15 	stw	fp,48(sp)
 b0008f0:	ddc00b15 	stw	r23,44(sp)
 b0008f4:	dd800a15 	stw	r22,40(sp)
 b0008f8:	dd400915 	stw	r21,36(sp)
 b0008fc:	dd000815 	stw	r20,32(sp)
 b000900:	dcc00715 	stw	r19,28(sp)
 b000904:	dc800615 	stw	r18,24(sp)
 b000908:	dc400515 	stw	r17,20(sp)
 b00090c:	dc000415 	stw	r16,16(sp)
 b000910:	31bfffc4 	addi	r6,r6,-1
 b000914:	280f883a 	mov	r7,r5
 b000918:	2005883a 	mov	r2,r4
 b00091c:	31404616 	blt	r6,r5,b000a38 <__ieee754_log+0x158>
 b000920:	00e00034 	movhi	r3,32768
 b000924:	18ffffc4 	addi	r3,r3,-1
 b000928:	28c6703a 	and	r3,r5,r3
 b00092c:	1906b03a 	or	r3,r3,r4
 b000930:	1800f426 	beq	r3,zero,b000d04 <__ieee754_log+0x424>
 b000934:	28017816 	blt	r5,zero,b000f18 <__ieee754_log+0x638>
 b000938:	01d0d434 	movhi	r7,17232
 b00093c:	000d883a 	mov	r6,zero
 b000940:	b0028a40 	call	b0028a4 <__muldf3>
 b000944:	015ffc34 	movhi	r5,32752
 b000948:	297fffc4 	addi	r5,r5,-1
 b00094c:	180f883a 	mov	r7,r3
 b000950:	013ff284 	movi	r4,-54
 b000954:	28c03d16 	blt	r5,r3,b000a4c <__ieee754_log+0x16c>
 b000958:	04c00434 	movhi	r19,16
 b00095c:	9cffffc4 	addi	r19,r19,-1
 b000960:	01400274 	movhi	r5,9
 b000964:	1cf8703a 	and	fp,r3,r19
 b000968:	2957d904 	addi	r5,r5,24420
 b00096c:	1821d53a 	srai	r16,r3,20
 b000970:	e14b883a 	add	r5,fp,r5
 b000974:	2940042c 	andhi	r5,r5,16
 b000978:	2807d53a 	srai	r3,r5,20
 b00097c:	843f0044 	addi	r16,r16,-1023
 b000980:	294ffc3c 	xorhi	r5,r5,16368
 b000984:	8121883a 	add	r16,r16,r4
 b000988:	000d883a 	mov	r6,zero
 b00098c:	01cffc34 	movhi	r7,16368
 b000990:	1009883a 	mov	r4,r2
 b000994:	2f0ab03a 	or	r5,r5,fp
 b000998:	1c21883a 	add	r16,r3,r16
 b00099c:	b0031100 	call	b003110 <__subdf3>
 b0009a0:	1025883a 	mov	r18,r2
 b0009a4:	e0800084 	addi	r2,fp,2
 b0009a8:	14e6703a 	and	r19,r2,r19
 b0009ac:	00800084 	movi	r2,2
 b0009b0:	1823883a 	mov	r17,r3
 b0009b4:	000d883a 	mov	r6,zero
 b0009b8:	14c03416 	blt	r2,r19,b000a8c <__ieee754_log+0x1ac>
 b0009bc:	000f883a 	mov	r7,zero
 b0009c0:	9009883a 	mov	r4,r18
 b0009c4:	180b883a 	mov	r5,r3
 b0009c8:	b0027400 	call	b002740 <__eqdf2>
 b0009cc:	1000d31e 	bne	r2,zero,b000d1c <__ieee754_log+0x43c>
 b0009d0:	80015926 	beq	r16,zero,b000f38 <__ieee754_log+0x658>
 b0009d4:	8009883a 	mov	r4,r16
 b0009d8:	b003a0c0 	call	b003a0c <__floatsidf>
 b0009dc:	01cff9b4 	movhi	r7,16358
 b0009e0:	39cb9084 	addi	r7,r7,11842
 b0009e4:	01bfb834 	movhi	r6,65248
 b0009e8:	1009883a 	mov	r4,r2
 b0009ec:	180b883a 	mov	r5,r3
 b0009f0:	1023883a 	mov	r17,r2
 b0009f4:	1821883a 	mov	r16,r3
 b0009f8:	b0028a40 	call	b0028a4 <__muldf3>
 b0009fc:	018d5e74 	movhi	r6,13689
 b000a00:	01cf7ab4 	movhi	r7,15850
 b000a04:	8809883a 	mov	r4,r17
 b000a08:	800b883a 	mov	r5,r16
 b000a0c:	318f1d84 	addi	r6,r6,15478
 b000a10:	39ce7bc4 	addi	r7,r7,14831
 b000a14:	1027883a 	mov	r19,r2
 b000a18:	1825883a 	mov	r18,r3
 b000a1c:	b0028a40 	call	b0028a4 <__muldf3>
 b000a20:	100d883a 	mov	r6,r2
 b000a24:	180f883a 	mov	r7,r3
 b000a28:	9809883a 	mov	r4,r19
 b000a2c:	900b883a 	mov	r5,r18
 b000a30:	b0014c40 	call	b0014c4 <__adddf3>
 b000a34:	00000906 	br	b000a5c <__ieee754_log+0x17c>
 b000a38:	2807883a 	mov	r3,r5
 b000a3c:	015ffc34 	movhi	r5,32752
 b000a40:	297fffc4 	addi	r5,r5,-1
 b000a44:	0009883a 	mov	r4,zero
 b000a48:	28ffc30e 	bge	r5,r3,b000958 <__alt_mem_flash+0xfefff958>
 b000a4c:	100d883a 	mov	r6,r2
 b000a50:	1009883a 	mov	r4,r2
 b000a54:	380b883a 	mov	r5,r7
 b000a58:	b0014c40 	call	b0014c4 <__adddf3>
 b000a5c:	dfc00d17 	ldw	ra,52(sp)
 b000a60:	df000c17 	ldw	fp,48(sp)
 b000a64:	ddc00b17 	ldw	r23,44(sp)
 b000a68:	dd800a17 	ldw	r22,40(sp)
 b000a6c:	dd400917 	ldw	r21,36(sp)
 b000a70:	dd000817 	ldw	r20,32(sp)
 b000a74:	dcc00717 	ldw	r19,28(sp)
 b000a78:	dc800617 	ldw	r18,24(sp)
 b000a7c:	dc400517 	ldw	r17,20(sp)
 b000a80:	dc000417 	ldw	r16,16(sp)
 b000a84:	dec00e04 	addi	sp,sp,56
 b000a88:	f800283a 	ret
 b000a8c:	01d00034 	movhi	r7,16384
 b000a90:	9009883a 	mov	r4,r18
 b000a94:	180b883a 	mov	r5,r3
 b000a98:	b0014c40 	call	b0014c4 <__adddf3>
 b000a9c:	100d883a 	mov	r6,r2
 b000aa0:	180f883a 	mov	r7,r3
 b000aa4:	880b883a 	mov	r5,r17
 b000aa8:	9009883a 	mov	r4,r18
 b000aac:	b001d700 	call	b001d70 <__divdf3>
 b000ab0:	8009883a 	mov	r4,r16
 b000ab4:	102d883a 	mov	r22,r2
 b000ab8:	182b883a 	mov	r21,r3
 b000abc:	b003a0c0 	call	b003a0c <__floatsidf>
 b000ac0:	b00d883a 	mov	r6,r22
 b000ac4:	a80f883a 	mov	r7,r21
 b000ac8:	b009883a 	mov	r4,r22
 b000acc:	a80b883a 	mov	r5,r21
 b000ad0:	d8800015 	stw	r2,0(sp)
 b000ad4:	d8c00115 	stw	r3,4(sp)
 b000ad8:	b0028a40 	call	b0028a4 <__muldf3>
 b000adc:	027ffeb4 	movhi	r9,65530
 b000ae0:	4a7ae184 	addi	r9,r9,-5242
 b000ae4:	100d883a 	mov	r6,r2
 b000ae8:	180f883a 	mov	r7,r3
 b000aec:	1009883a 	mov	r4,r2
 b000af0:	180b883a 	mov	r5,r3
 b000af4:	e26f883a 	add	r23,fp,r9
 b000af8:	d8c00315 	stw	r3,12(sp)
 b000afc:	d8800215 	stw	r2,8(sp)
 b000b00:	b0028a40 	call	b0028a4 <__muldf3>
 b000b04:	01b7cfb4 	movhi	r6,57150
 b000b08:	01cff0f4 	movhi	r7,16323
 b000b0c:	31949104 	addi	r6,r6,21060
 b000b10:	39fc4484 	addi	r7,r7,-3822
 b000b14:	1009883a 	mov	r4,r2
 b000b18:	180b883a 	mov	r5,r3
 b000b1c:	1029883a 	mov	r20,r2
 b000b20:	1827883a 	mov	r19,r3
 b000b24:	b0028a40 	call	b0028a4 <__muldf3>
 b000b28:	01a5b2f4 	movhi	r6,38603
 b000b2c:	01cff1f4 	movhi	r7,16327
 b000b30:	3180f784 	addi	r6,r6,990
 b000b34:	39d19904 	addi	r7,r7,18020
 b000b38:	1009883a 	mov	r4,r2
 b000b3c:	180b883a 	mov	r5,r3
 b000b40:	b0014c40 	call	b0014c4 <__adddf3>
 b000b44:	a00d883a 	mov	r6,r20
 b000b48:	980f883a 	mov	r7,r19
 b000b4c:	1009883a 	mov	r4,r2
 b000b50:	180b883a 	mov	r5,r3
 b000b54:	b0028a40 	call	b0028a4 <__muldf3>
 b000b58:	01a508f4 	movhi	r6,37923
 b000b5c:	01cff4b4 	movhi	r7,16338
 b000b60:	31a4d644 	addi	r6,r6,-27815
 b000b64:	39d24904 	addi	r7,r7,18724
 b000b68:	1009883a 	mov	r4,r2
 b000b6c:	180b883a 	mov	r5,r3
 b000b70:	b0014c40 	call	b0014c4 <__adddf3>
 b000b74:	a00d883a 	mov	r6,r20
 b000b78:	980f883a 	mov	r7,r19
 b000b7c:	1009883a 	mov	r4,r2
 b000b80:	180b883a 	mov	r5,r3
 b000b84:	b0028a40 	call	b0028a4 <__muldf3>
 b000b88:	01955574 	movhi	r6,21845
 b000b8c:	01cff974 	movhi	r7,16357
 b000b90:	319564c4 	addi	r6,r6,21907
 b000b94:	39d55544 	addi	r7,r7,21845
 b000b98:	1009883a 	mov	r4,r2
 b000b9c:	180b883a 	mov	r5,r3
 b000ba0:	b0014c40 	call	b0014c4 <__adddf3>
 b000ba4:	dac00217 	ldw	r11,8(sp)
 b000ba8:	da800317 	ldw	r10,12(sp)
 b000bac:	1009883a 	mov	r4,r2
 b000bb0:	580d883a 	mov	r6,r11
 b000bb4:	500f883a 	mov	r7,r10
 b000bb8:	180b883a 	mov	r5,r3
 b000bbc:	b0028a40 	call	b0028a4 <__muldf3>
 b000bc0:	01b41e74 	movhi	r6,53369
 b000bc4:	01cff134 	movhi	r7,16324
 b000bc8:	a009883a 	mov	r4,r20
 b000bcc:	980b883a 	mov	r5,r19
 b000bd0:	31b1a7c4 	addi	r6,r6,-14689
 b000bd4:	39e68244 	addi	r7,r7,-26103
 b000bd8:	d8c00315 	stw	r3,12(sp)
 b000bdc:	d8800215 	stw	r2,8(sp)
 b000be0:	b0028a40 	call	b0028a4 <__muldf3>
 b000be4:	018763b4 	movhi	r6,7566
 b000be8:	01cff334 	movhi	r7,16332
 b000bec:	319e2bc4 	addi	r6,r6,30895
 b000bf0:	39dc7144 	addi	r7,r7,29125
 b000bf4:	1009883a 	mov	r4,r2
 b000bf8:	180b883a 	mov	r5,r3
 b000bfc:	b0014c40 	call	b0014c4 <__adddf3>
 b000c00:	a00d883a 	mov	r6,r20
 b000c04:	980f883a 	mov	r7,r19
 b000c08:	1009883a 	mov	r4,r2
 b000c0c:	180b883a 	mov	r5,r3
 b000c10:	b0028a40 	call	b0028a4 <__muldf3>
 b000c14:	01a66634 	movhi	r6,39320
 b000c18:	01cff6b4 	movhi	r7,16346
 b000c1c:	31be8104 	addi	r6,r6,-1532
 b000c20:	39e66644 	addi	r7,r7,-26215
 b000c24:	1009883a 	mov	r4,r2
 b000c28:	180b883a 	mov	r5,r3
 b000c2c:	b0014c40 	call	b0014c4 <__adddf3>
 b000c30:	a00d883a 	mov	r6,r20
 b000c34:	980f883a 	mov	r7,r19
 b000c38:	1009883a 	mov	r4,r2
 b000c3c:	180b883a 	mov	r5,r3
 b000c40:	b0028a40 	call	b0028a4 <__muldf3>
 b000c44:	dac00217 	ldw	r11,8(sp)
 b000c48:	da800317 	ldw	r10,12(sp)
 b000c4c:	100d883a 	mov	r6,r2
 b000c50:	180f883a 	mov	r7,r3
 b000c54:	5809883a 	mov	r4,r11
 b000c58:	500b883a 	mov	r5,r10
 b000c5c:	b0014c40 	call	b0014c4 <__adddf3>
 b000c60:	1827883a 	mov	r19,r3
 b000c64:	00c001f4 	movhi	r3,7
 b000c68:	18ee1444 	addi	r3,r3,-18351
 b000c6c:	1f07c83a 	sub	r3,r3,fp
 b000c70:	1dd2b03a 	or	r9,r3,r23
 b000c74:	1029883a 	mov	r20,r2
 b000c78:	0240490e 	bge	zero,r9,b000da0 <__ieee754_log+0x4c0>
 b000c7c:	000d883a 	mov	r6,zero
 b000c80:	01cff834 	movhi	r7,16352
 b000c84:	9009883a 	mov	r4,r18
 b000c88:	880b883a 	mov	r5,r17
 b000c8c:	b0028a40 	call	b0028a4 <__muldf3>
 b000c90:	900d883a 	mov	r6,r18
 b000c94:	880f883a 	mov	r7,r17
 b000c98:	1009883a 	mov	r4,r2
 b000c9c:	180b883a 	mov	r5,r3
 b000ca0:	b0028a40 	call	b0028a4 <__muldf3>
 b000ca4:	1039883a 	mov	fp,r2
 b000ca8:	182f883a 	mov	r23,r3
 b000cac:	8000691e 	bne	r16,zero,b000e54 <__ieee754_log+0x574>
 b000cb0:	100d883a 	mov	r6,r2
 b000cb4:	180f883a 	mov	r7,r3
 b000cb8:	a009883a 	mov	r4,r20
 b000cbc:	980b883a 	mov	r5,r19
 b000cc0:	b0014c40 	call	b0014c4 <__adddf3>
 b000cc4:	b00d883a 	mov	r6,r22
 b000cc8:	a80f883a 	mov	r7,r21
 b000ccc:	1009883a 	mov	r4,r2
 b000cd0:	180b883a 	mov	r5,r3
 b000cd4:	b0028a40 	call	b0028a4 <__muldf3>
 b000cd8:	100d883a 	mov	r6,r2
 b000cdc:	180f883a 	mov	r7,r3
 b000ce0:	e009883a 	mov	r4,fp
 b000ce4:	b80b883a 	mov	r5,r23
 b000ce8:	b0031100 	call	b003110 <__subdf3>
 b000cec:	100d883a 	mov	r6,r2
 b000cf0:	180f883a 	mov	r7,r3
 b000cf4:	9009883a 	mov	r4,r18
 b000cf8:	880b883a 	mov	r5,r17
 b000cfc:	b0031100 	call	b003110 <__subdf3>
 b000d00:	003f5606 	br	b000a5c <__alt_mem_flash+0xfefffa5c>
 b000d04:	000d883a 	mov	r6,zero
 b000d08:	000f883a 	mov	r7,zero
 b000d0c:	0009883a 	mov	r4,zero
 b000d10:	0170d434 	movhi	r5,50000
 b000d14:	b001d700 	call	b001d70 <__divdf3>
 b000d18:	003f5006 	br	b000a5c <__alt_mem_flash+0xfefffa5c>
 b000d1c:	01955574 	movhi	r6,21845
 b000d20:	01cff574 	movhi	r7,16341
 b000d24:	31955544 	addi	r6,r6,21845
 b000d28:	39d55544 	addi	r7,r7,21845
 b000d2c:	9009883a 	mov	r4,r18
 b000d30:	880b883a 	mov	r5,r17
 b000d34:	b0028a40 	call	b0028a4 <__muldf3>
 b000d38:	100d883a 	mov	r6,r2
 b000d3c:	180f883a 	mov	r7,r3
 b000d40:	0009883a 	mov	r4,zero
 b000d44:	014ff834 	movhi	r5,16352
 b000d48:	b0031100 	call	b003110 <__subdf3>
 b000d4c:	900d883a 	mov	r6,r18
 b000d50:	880f883a 	mov	r7,r17
 b000d54:	9009883a 	mov	r4,r18
 b000d58:	880b883a 	mov	r5,r17
 b000d5c:	1029883a 	mov	r20,r2
 b000d60:	1827883a 	mov	r19,r3
 b000d64:	b0028a40 	call	b0028a4 <__muldf3>
 b000d68:	a009883a 	mov	r4,r20
 b000d6c:	980b883a 	mov	r5,r19
 b000d70:	100d883a 	mov	r6,r2
 b000d74:	180f883a 	mov	r7,r3
 b000d78:	b0028a40 	call	b0028a4 <__muldf3>
 b000d7c:	1029883a 	mov	r20,r2
 b000d80:	1827883a 	mov	r19,r3
 b000d84:	80006f1e 	bne	r16,zero,b000f44 <__ieee754_log+0x664>
 b000d88:	100d883a 	mov	r6,r2
 b000d8c:	180f883a 	mov	r7,r3
 b000d90:	9009883a 	mov	r4,r18
 b000d94:	880b883a 	mov	r5,r17
 b000d98:	b0031100 	call	b003110 <__subdf3>
 b000d9c:	003f2f06 	br	b000a5c <__alt_mem_flash+0xfefffa5c>
 b000da0:	80008b26 	beq	r16,zero,b000fd0 <__ieee754_log+0x6f0>
 b000da4:	d9000017 	ldw	r4,0(sp)
 b000da8:	d9400117 	ldw	r5,4(sp)
 b000dac:	01cff9b4 	movhi	r7,16358
 b000db0:	39cb9084 	addi	r7,r7,11842
 b000db4:	01bfb834 	movhi	r6,65248
 b000db8:	b0028a40 	call	b0028a4 <__muldf3>
 b000dbc:	a00d883a 	mov	r6,r20
 b000dc0:	980f883a 	mov	r7,r19
 b000dc4:	9009883a 	mov	r4,r18
 b000dc8:	880b883a 	mov	r5,r17
 b000dcc:	1821883a 	mov	r16,r3
 b000dd0:	d8800215 	stw	r2,8(sp)
 b000dd4:	b0031100 	call	b003110 <__subdf3>
 b000dd8:	b00d883a 	mov	r6,r22
 b000ddc:	a80f883a 	mov	r7,r21
 b000de0:	1009883a 	mov	r4,r2
 b000de4:	180b883a 	mov	r5,r3
 b000de8:	b0028a40 	call	b0028a4 <__muldf3>
 b000dec:	d9000017 	ldw	r4,0(sp)
 b000df0:	d9400117 	ldw	r5,4(sp)
 b000df4:	018d5e74 	movhi	r6,13689
 b000df8:	01cf7ab4 	movhi	r7,15850
 b000dfc:	318f1d84 	addi	r6,r6,15478
 b000e00:	39ce7bc4 	addi	r7,r7,14831
 b000e04:	1029883a 	mov	r20,r2
 b000e08:	1827883a 	mov	r19,r3
 b000e0c:	b0028a40 	call	b0028a4 <__muldf3>
 b000e10:	a009883a 	mov	r4,r20
 b000e14:	980b883a 	mov	r5,r19
 b000e18:	100d883a 	mov	r6,r2
 b000e1c:	180f883a 	mov	r7,r3
 b000e20:	b0031100 	call	b003110 <__subdf3>
 b000e24:	900d883a 	mov	r6,r18
 b000e28:	880f883a 	mov	r7,r17
 b000e2c:	1009883a 	mov	r4,r2
 b000e30:	180b883a 	mov	r5,r3
 b000e34:	b0031100 	call	b003110 <__subdf3>
 b000e38:	da000217 	ldw	r8,8(sp)
 b000e3c:	100d883a 	mov	r6,r2
 b000e40:	180f883a 	mov	r7,r3
 b000e44:	4009883a 	mov	r4,r8
 b000e48:	800b883a 	mov	r5,r16
 b000e4c:	b0031100 	call	b003110 <__subdf3>
 b000e50:	003f0206 	br	b000a5c <__alt_mem_flash+0xfefffa5c>
 b000e54:	d9000017 	ldw	r4,0(sp)
 b000e58:	d9400117 	ldw	r5,4(sp)
 b000e5c:	01cff9b4 	movhi	r7,16358
 b000e60:	39cb9084 	addi	r7,r7,11842
 b000e64:	01bfb834 	movhi	r6,65248
 b000e68:	b0028a40 	call	b0028a4 <__muldf3>
 b000e6c:	e00d883a 	mov	r6,fp
 b000e70:	b80f883a 	mov	r7,r23
 b000e74:	a009883a 	mov	r4,r20
 b000e78:	980b883a 	mov	r5,r19
 b000e7c:	1821883a 	mov	r16,r3
 b000e80:	d8800315 	stw	r2,12(sp)
 b000e84:	b0014c40 	call	b0014c4 <__adddf3>
 b000e88:	b00d883a 	mov	r6,r22
 b000e8c:	a80f883a 	mov	r7,r21
 b000e90:	1009883a 	mov	r4,r2
 b000e94:	180b883a 	mov	r5,r3
 b000e98:	b0028a40 	call	b0028a4 <__muldf3>
 b000e9c:	d9000017 	ldw	r4,0(sp)
 b000ea0:	d9400117 	ldw	r5,4(sp)
 b000ea4:	018d5e74 	movhi	r6,13689
 b000ea8:	01cf7ab4 	movhi	r7,15850
 b000eac:	318f1d84 	addi	r6,r6,15478
 b000eb0:	39ce7bc4 	addi	r7,r7,14831
 b000eb4:	1029883a 	mov	r20,r2
 b000eb8:	1827883a 	mov	r19,r3
 b000ebc:	b0028a40 	call	b0028a4 <__muldf3>
 b000ec0:	a009883a 	mov	r4,r20
 b000ec4:	980b883a 	mov	r5,r19
 b000ec8:	100d883a 	mov	r6,r2
 b000ecc:	180f883a 	mov	r7,r3
 b000ed0:	b0014c40 	call	b0014c4 <__adddf3>
 b000ed4:	e009883a 	mov	r4,fp
 b000ed8:	b80b883a 	mov	r5,r23
 b000edc:	100d883a 	mov	r6,r2
 b000ee0:	180f883a 	mov	r7,r3
 b000ee4:	b0031100 	call	b003110 <__subdf3>
 b000ee8:	900d883a 	mov	r6,r18
 b000eec:	880f883a 	mov	r7,r17
 b000ef0:	1009883a 	mov	r4,r2
 b000ef4:	180b883a 	mov	r5,r3
 b000ef8:	b0031100 	call	b003110 <__subdf3>
 b000efc:	da800317 	ldw	r10,12(sp)
 b000f00:	100d883a 	mov	r6,r2
 b000f04:	180f883a 	mov	r7,r3
 b000f08:	5009883a 	mov	r4,r10
 b000f0c:	800b883a 	mov	r5,r16
 b000f10:	b0031100 	call	b003110 <__subdf3>
 b000f14:	003ed106 	br	b000a5c <__alt_mem_flash+0xfefffa5c>
 b000f18:	200d883a 	mov	r6,r4
 b000f1c:	b0031100 	call	b003110 <__subdf3>
 b000f20:	000d883a 	mov	r6,zero
 b000f24:	000f883a 	mov	r7,zero
 b000f28:	1009883a 	mov	r4,r2
 b000f2c:	180b883a 	mov	r5,r3
 b000f30:	b001d700 	call	b001d70 <__divdf3>
 b000f34:	003ec906 	br	b000a5c <__alt_mem_flash+0xfefffa5c>
 b000f38:	0005883a 	mov	r2,zero
 b000f3c:	0007883a 	mov	r3,zero
 b000f40:	003ec606 	br	b000a5c <__alt_mem_flash+0xfefffa5c>
 b000f44:	8009883a 	mov	r4,r16
 b000f48:	b003a0c0 	call	b003a0c <__floatsidf>
 b000f4c:	01cff9b4 	movhi	r7,16358
 b000f50:	39cb9084 	addi	r7,r7,11842
 b000f54:	01bfb834 	movhi	r6,65248
 b000f58:	1009883a 	mov	r4,r2
 b000f5c:	180b883a 	mov	r5,r3
 b000f60:	102b883a 	mov	r21,r2
 b000f64:	1821883a 	mov	r16,r3
 b000f68:	b0028a40 	call	b0028a4 <__muldf3>
 b000f6c:	018d5e74 	movhi	r6,13689
 b000f70:	01cf7ab4 	movhi	r7,15850
 b000f74:	a809883a 	mov	r4,r21
 b000f78:	800b883a 	mov	r5,r16
 b000f7c:	318f1d84 	addi	r6,r6,15478
 b000f80:	39ce7bc4 	addi	r7,r7,14831
 b000f84:	102f883a 	mov	r23,r2
 b000f88:	182d883a 	mov	r22,r3
 b000f8c:	b0028a40 	call	b0028a4 <__muldf3>
 b000f90:	a009883a 	mov	r4,r20
 b000f94:	980b883a 	mov	r5,r19
 b000f98:	100d883a 	mov	r6,r2
 b000f9c:	180f883a 	mov	r7,r3
 b000fa0:	b0031100 	call	b003110 <__subdf3>
 b000fa4:	900d883a 	mov	r6,r18
 b000fa8:	880f883a 	mov	r7,r17
 b000fac:	1009883a 	mov	r4,r2
 b000fb0:	180b883a 	mov	r5,r3
 b000fb4:	b0031100 	call	b003110 <__subdf3>
 b000fb8:	100d883a 	mov	r6,r2
 b000fbc:	180f883a 	mov	r7,r3
 b000fc0:	b809883a 	mov	r4,r23
 b000fc4:	b00b883a 	mov	r5,r22
 b000fc8:	b0031100 	call	b003110 <__subdf3>
 b000fcc:	003ea306 	br	b000a5c <__alt_mem_flash+0xfefffa5c>
 b000fd0:	a00d883a 	mov	r6,r20
 b000fd4:	980f883a 	mov	r7,r19
 b000fd8:	9009883a 	mov	r4,r18
 b000fdc:	880b883a 	mov	r5,r17
 b000fe0:	b0031100 	call	b003110 <__subdf3>
 b000fe4:	b00d883a 	mov	r6,r22
 b000fe8:	a80f883a 	mov	r7,r21
 b000fec:	1009883a 	mov	r4,r2
 b000ff0:	180b883a 	mov	r5,r3
 b000ff4:	b0028a40 	call	b0028a4 <__muldf3>
 b000ff8:	003f3c06 	br	b000cec <__alt_mem_flash+0xfefffcec>

0b000ffc <__fpclassifyd>:
 b000ffc:	00a00034 	movhi	r2,32768
 b001000:	10bfffc4 	addi	r2,r2,-1
 b001004:	2884703a 	and	r2,r5,r2
 b001008:	10000726 	beq	r2,zero,b001028 <__fpclassifyd+0x2c>
 b00100c:	00fffc34 	movhi	r3,65520
 b001010:	019ff834 	movhi	r6,32736
 b001014:	28c7883a 	add	r3,r5,r3
 b001018:	31bfffc4 	addi	r6,r6,-1
 b00101c:	30c00536 	bltu	r6,r3,b001034 <__fpclassifyd+0x38>
 b001020:	00800104 	movi	r2,4
 b001024:	f800283a 	ret
 b001028:	2000021e 	bne	r4,zero,b001034 <__fpclassifyd+0x38>
 b00102c:	00800084 	movi	r2,2
 b001030:	f800283a 	ret
 b001034:	00dffc34 	movhi	r3,32752
 b001038:	019ff834 	movhi	r6,32736
 b00103c:	28cb883a 	add	r5,r5,r3
 b001040:	31bfffc4 	addi	r6,r6,-1
 b001044:	317ff62e 	bgeu	r6,r5,b001020 <__alt_mem_flash+0xff000020>
 b001048:	01400434 	movhi	r5,16
 b00104c:	297fffc4 	addi	r5,r5,-1
 b001050:	28800236 	bltu	r5,r2,b00105c <__fpclassifyd+0x60>
 b001054:	008000c4 	movi	r2,3
 b001058:	f800283a 	ret
 b00105c:	10c00226 	beq	r2,r3,b001068 <__fpclassifyd+0x6c>
 b001060:	0005883a 	mov	r2,zero
 b001064:	f800283a 	ret
 b001068:	2005003a 	cmpeq	r2,r4,zero
 b00106c:	f800283a 	ret

0b001070 <matherr>:
 b001070:	0005883a 	mov	r2,zero
 b001074:	f800283a 	ret

0b001078 <nan>:
 b001078:	0005883a 	mov	r2,zero
 b00107c:	00dffe34 	movhi	r3,32760
 b001080:	f800283a 	ret

0b001084 <__divsf3>:
 b001084:	defff504 	addi	sp,sp,-44
 b001088:	200cd5fa 	srli	r6,r4,23
 b00108c:	dcc00415 	stw	r19,16(sp)
 b001090:	2026d7fa 	srli	r19,r4,31
 b001094:	00c02034 	movhi	r3,128
 b001098:	dd800715 	stw	r22,28(sp)
 b00109c:	dd000515 	stw	r20,20(sp)
 b0010a0:	dc800315 	stw	r18,12(sp)
 b0010a4:	18ffffc4 	addi	r3,r3,-1
 b0010a8:	dfc00a15 	stw	ra,40(sp)
 b0010ac:	df000915 	stw	fp,36(sp)
 b0010b0:	ddc00815 	stw	r23,32(sp)
 b0010b4:	dd400615 	stw	r21,24(sp)
 b0010b8:	dc400215 	stw	r17,8(sp)
 b0010bc:	dc000115 	stw	r16,4(sp)
 b0010c0:	35003fcc 	andi	r20,r6,255
 b0010c4:	1924703a 	and	r18,r3,r4
 b0010c8:	9d803fcc 	andi	r22,r19,255
 b0010cc:	a0005226 	beq	r20,zero,b001218 <__divsf3+0x194>
 b0010d0:	00803fc4 	movi	r2,255
 b0010d4:	a0802e26 	beq	r20,r2,b001190 <__divsf3+0x10c>
 b0010d8:	91002034 	orhi	r4,r18,128
 b0010dc:	202490fa 	slli	r18,r4,3
 b0010e0:	a53fe044 	addi	r20,r20,-127
 b0010e4:	0021883a 	mov	r16,zero
 b0010e8:	002f883a 	mov	r23,zero
 b0010ec:	280cd5fa 	srli	r6,r5,23
 b0010f0:	282ad7fa 	srli	r21,r5,31
 b0010f4:	00c02034 	movhi	r3,128
 b0010f8:	18ffffc4 	addi	r3,r3,-1
 b0010fc:	31803fcc 	andi	r6,r6,255
 b001100:	1962703a 	and	r17,r3,r5
 b001104:	af003fcc 	andi	fp,r21,255
 b001108:	30004a26 	beq	r6,zero,b001234 <__divsf3+0x1b0>
 b00110c:	00803fc4 	movi	r2,255
 b001110:	30804526 	beq	r6,r2,b001228 <__divsf3+0x1a4>
 b001114:	89402034 	orhi	r5,r17,128
 b001118:	282290fa 	slli	r17,r5,3
 b00111c:	31bfe044 	addi	r6,r6,-127
 b001120:	000b883a 	mov	r5,zero
 b001124:	2c20b03a 	or	r16,r5,r16
 b001128:	802090ba 	slli	r16,r16,2
 b00112c:	0082c034 	movhi	r2,2816
 b001130:	10845404 	addi	r2,r2,4432
 b001134:	80a1883a 	add	r16,r16,r2
 b001138:	81000017 	ldw	r4,0(r16)
 b00113c:	9d46f03a 	xor	r3,r19,r21
 b001140:	180f883a 	mov	r7,r3
 b001144:	18803fcc 	andi	r2,r3,255
 b001148:	a18dc83a 	sub	r6,r20,r6
 b00114c:	2000683a 	jmp	r4
 b001150:	0b001334 	orhi	r12,at,76
 b001154:	0b0011b8 	rdprs	r12,at,70
 b001158:	0b001328 	cmpgeui	r12,at,76
 b00115c:	0b0011a4 	muli	r12,at,70
 b001160:	0b001328 	cmpgeui	r12,at,76
 b001164:	0b001300 	call	b00130 <__alt_mem_onchip-0x34ffed0>
 b001168:	0b001328 	cmpgeui	r12,at,76
 b00116c:	0b0011a4 	muli	r12,at,70
 b001170:	0b0011b8 	rdprs	r12,at,70
 b001174:	0b0011b8 	rdprs	r12,at,70
 b001178:	0b001300 	call	b00130 <__alt_mem_onchip-0x34ffed0>
 b00117c:	0b0011a4 	muli	r12,at,70
 b001180:	0b001414 	ori	r12,at,80
 b001184:	0b001414 	ori	r12,at,80
 b001188:	0b001414 	ori	r12,at,80
 b00118c:	0b0013c8 	cmpgei	r12,at,79
 b001190:	9000581e 	bne	r18,zero,b0012f4 <__divsf3+0x270>
 b001194:	04000204 	movi	r16,8
 b001198:	05c00084 	movi	r23,2
 b00119c:	003fd306 	br	b0010ec <__alt_mem_flash+0xff0000ec>
 b0011a0:	0023883a 	mov	r17,zero
 b0011a4:	e02d883a 	mov	r22,fp
 b0011a8:	282f883a 	mov	r23,r5
 b0011ac:	00800084 	movi	r2,2
 b0011b0:	b8808f1e 	bne	r23,r2,b0013f0 <__divsf3+0x36c>
 b0011b4:	b005883a 	mov	r2,r22
 b0011b8:	11c0004c 	andi	r7,r2,1
 b0011bc:	013fffc4 	movi	r4,-1
 b0011c0:	000d883a 	mov	r6,zero
 b0011c4:	21003fcc 	andi	r4,r4,255
 b0011c8:	200895fa 	slli	r4,r4,23
 b0011cc:	38803fcc 	andi	r2,r7,255
 b0011d0:	00c02034 	movhi	r3,128
 b0011d4:	100497fa 	slli	r2,r2,31
 b0011d8:	18ffffc4 	addi	r3,r3,-1
 b0011dc:	30c6703a 	and	r3,r6,r3
 b0011e0:	1906b03a 	or	r3,r3,r4
 b0011e4:	1884b03a 	or	r2,r3,r2
 b0011e8:	dfc00a17 	ldw	ra,40(sp)
 b0011ec:	df000917 	ldw	fp,36(sp)
 b0011f0:	ddc00817 	ldw	r23,32(sp)
 b0011f4:	dd800717 	ldw	r22,28(sp)
 b0011f8:	dd400617 	ldw	r21,24(sp)
 b0011fc:	dd000517 	ldw	r20,20(sp)
 b001200:	dcc00417 	ldw	r19,16(sp)
 b001204:	dc800317 	ldw	r18,12(sp)
 b001208:	dc400217 	ldw	r17,8(sp)
 b00120c:	dc000117 	ldw	r16,4(sp)
 b001210:	dec00b04 	addi	sp,sp,44
 b001214:	f800283a 	ret
 b001218:	90002b1e 	bne	r18,zero,b0012c8 <__divsf3+0x244>
 b00121c:	04000104 	movi	r16,4
 b001220:	05c00044 	movi	r23,1
 b001224:	003fb106 	br	b0010ec <__alt_mem_flash+0xff0000ec>
 b001228:	8800251e 	bne	r17,zero,b0012c0 <__divsf3+0x23c>
 b00122c:	01400084 	movi	r5,2
 b001230:	00000206 	br	b00123c <__divsf3+0x1b8>
 b001234:	88001a1e 	bne	r17,zero,b0012a0 <__divsf3+0x21c>
 b001238:	01400044 	movi	r5,1
 b00123c:	8160b03a 	or	r16,r16,r5
 b001240:	802090ba 	slli	r16,r16,2
 b001244:	00c2c034 	movhi	r3,2816
 b001248:	18c49804 	addi	r3,r3,4704
 b00124c:	80e1883a 	add	r16,r16,r3
 b001250:	80c00017 	ldw	r3,0(r16)
 b001254:	9d44f03a 	xor	r2,r19,r21
 b001258:	a18dc83a 	sub	r6,r20,r6
 b00125c:	1800683a 	jmp	r3
 b001260:	0b0011b8 	rdprs	r12,at,70
 b001264:	0b0011b8 	rdprs	r12,at,70
 b001268:	0b001404 	addi	r12,at,80
 b00126c:	0b0011a0 	cmpeqi	r12,at,70
 b001270:	0b001404 	addi	r12,at,80
 b001274:	0b001300 	call	b00130 <__alt_mem_onchip-0x34ffed0>
 b001278:	0b001404 	addi	r12,at,80
 b00127c:	0b0011a0 	cmpeqi	r12,at,70
 b001280:	0b0011b8 	rdprs	r12,at,70
 b001284:	0b0011b8 	rdprs	r12,at,70
 b001288:	0b001300 	call	b00130 <__alt_mem_onchip-0x34ffed0>
 b00128c:	0b0011a0 	cmpeqi	r12,at,70
 b001290:	0b001414 	ori	r12,at,80
 b001294:	0b001414 	ori	r12,at,80
 b001298:	0b001414 	ori	r12,at,80
 b00129c:	0b00142c 	andhi	r12,at,80
 b0012a0:	8809883a 	mov	r4,r17
 b0012a4:	b003da00 	call	b003da0 <__clzsi2>
 b0012a8:	10fffec4 	addi	r3,r2,-5
 b0012ac:	10801d84 	addi	r2,r2,118
 b0012b0:	88e2983a 	sll	r17,r17,r3
 b0012b4:	008dc83a 	sub	r6,zero,r2
 b0012b8:	000b883a 	mov	r5,zero
 b0012bc:	003f9906 	br	b001124 <__alt_mem_flash+0xff000124>
 b0012c0:	014000c4 	movi	r5,3
 b0012c4:	003f9706 	br	b001124 <__alt_mem_flash+0xff000124>
 b0012c8:	9009883a 	mov	r4,r18
 b0012cc:	d9400015 	stw	r5,0(sp)
 b0012d0:	b003da00 	call	b003da0 <__clzsi2>
 b0012d4:	10fffec4 	addi	r3,r2,-5
 b0012d8:	11801d84 	addi	r6,r2,118
 b0012dc:	90e4983a 	sll	r18,r18,r3
 b0012e0:	01a9c83a 	sub	r20,zero,r6
 b0012e4:	0021883a 	mov	r16,zero
 b0012e8:	002f883a 	mov	r23,zero
 b0012ec:	d9400017 	ldw	r5,0(sp)
 b0012f0:	003f7e06 	br	b0010ec <__alt_mem_flash+0xff0000ec>
 b0012f4:	04000304 	movi	r16,12
 b0012f8:	05c000c4 	movi	r23,3
 b0012fc:	003f7b06 	br	b0010ec <__alt_mem_flash+0xff0000ec>
 b001300:	01802034 	movhi	r6,128
 b001304:	000f883a 	mov	r7,zero
 b001308:	31bfffc4 	addi	r6,r6,-1
 b00130c:	013fffc4 	movi	r4,-1
 b001310:	003fac06 	br	b0011c4 <__alt_mem_flash+0xff0001c4>
 b001314:	01400044 	movi	r5,1
 b001318:	2909c83a 	sub	r4,r5,r4
 b00131c:	00c006c4 	movi	r3,27
 b001320:	19004b0e 	bge	r3,r4,b001450 <__divsf3+0x3cc>
 b001324:	114e703a 	and	r7,r2,r5
 b001328:	0009883a 	mov	r4,zero
 b00132c:	000d883a 	mov	r6,zero
 b001330:	003fa406 	br	b0011c4 <__alt_mem_flash+0xff0001c4>
 b001334:	9006917a 	slli	r3,r18,5
 b001338:	8822917a 	slli	r17,r17,5
 b00133c:	1c40372e 	bgeu	r3,r17,b00141c <__divsf3+0x398>
 b001340:	31bfffc4 	addi	r6,r6,-1
 b001344:	010006c4 	movi	r4,27
 b001348:	000b883a 	mov	r5,zero
 b00134c:	180f883a 	mov	r7,r3
 b001350:	294b883a 	add	r5,r5,r5
 b001354:	18c7883a 	add	r3,r3,r3
 b001358:	38000116 	blt	r7,zero,b001360 <__divsf3+0x2dc>
 b00135c:	1c400236 	bltu	r3,r17,b001368 <__divsf3+0x2e4>
 b001360:	1c47c83a 	sub	r3,r3,r17
 b001364:	29400054 	ori	r5,r5,1
 b001368:	213fffc4 	addi	r4,r4,-1
 b00136c:	203ff71e 	bne	r4,zero,b00134c <__alt_mem_flash+0xff00034c>
 b001370:	1806c03a 	cmpne	r3,r3,zero
 b001374:	1962b03a 	or	r17,r3,r5
 b001378:	31001fc4 	addi	r4,r6,127
 b00137c:	013fe50e 	bge	zero,r4,b001314 <__alt_mem_flash+0xff000314>
 b001380:	88c001cc 	andi	r3,r17,7
 b001384:	18000426 	beq	r3,zero,b001398 <__divsf3+0x314>
 b001388:	88c003cc 	andi	r3,r17,15
 b00138c:	01400104 	movi	r5,4
 b001390:	19400126 	beq	r3,r5,b001398 <__divsf3+0x314>
 b001394:	8963883a 	add	r17,r17,r5
 b001398:	88c2002c 	andhi	r3,r17,2048
 b00139c:	18000426 	beq	r3,zero,b0013b0 <__divsf3+0x32c>
 b0013a0:	00fe0034 	movhi	r3,63488
 b0013a4:	18ffffc4 	addi	r3,r3,-1
 b0013a8:	31002004 	addi	r4,r6,128
 b0013ac:	88e2703a 	and	r17,r17,r3
 b0013b0:	00c03f84 	movi	r3,254
 b0013b4:	193f8016 	blt	r3,r4,b0011b8 <__alt_mem_flash+0xff0001b8>
 b0013b8:	880c91ba 	slli	r6,r17,6
 b0013bc:	11c0004c 	andi	r7,r2,1
 b0013c0:	300cd27a 	srli	r6,r6,9
 b0013c4:	003f7f06 	br	b0011c4 <__alt_mem_flash+0xff0001c4>
 b0013c8:	9080102c 	andhi	r2,r18,64
 b0013cc:	10000226 	beq	r2,zero,b0013d8 <__divsf3+0x354>
 b0013d0:	8880102c 	andhi	r2,r17,64
 b0013d4:	10001826 	beq	r2,zero,b001438 <__divsf3+0x3b4>
 b0013d8:	00802034 	movhi	r2,128
 b0013dc:	91801034 	orhi	r6,r18,64
 b0013e0:	10bfffc4 	addi	r2,r2,-1
 b0013e4:	980f883a 	mov	r7,r19
 b0013e8:	308c703a 	and	r6,r6,r2
 b0013ec:	003fc706 	br	b00130c <__alt_mem_flash+0xff00030c>
 b0013f0:	008000c4 	movi	r2,3
 b0013f4:	b8802d26 	beq	r23,r2,b0014ac <__divsf3+0x428>
 b0013f8:	00c00044 	movi	r3,1
 b0013fc:	b005883a 	mov	r2,r22
 b001400:	b8ffdd1e 	bne	r23,r3,b001378 <__alt_mem_flash+0xff000378>
 b001404:	11c0004c 	andi	r7,r2,1
 b001408:	0009883a 	mov	r4,zero
 b00140c:	000d883a 	mov	r6,zero
 b001410:	003f6c06 	br	b0011c4 <__alt_mem_flash+0xff0001c4>
 b001414:	9023883a 	mov	r17,r18
 b001418:	003f6406 	br	b0011ac <__alt_mem_flash+0xff0001ac>
 b00141c:	1c47c83a 	sub	r3,r3,r17
 b001420:	01000684 	movi	r4,26
 b001424:	01400044 	movi	r5,1
 b001428:	003fc806 	br	b00134c <__alt_mem_flash+0xff00034c>
 b00142c:	9080102c 	andhi	r2,r18,64
 b001430:	103fe926 	beq	r2,zero,b0013d8 <__alt_mem_flash+0xff0003d8>
 b001434:	0023883a 	mov	r17,zero
 b001438:	00802034 	movhi	r2,128
 b00143c:	89801034 	orhi	r6,r17,64
 b001440:	10bfffc4 	addi	r2,r2,-1
 b001444:	a80f883a 	mov	r7,r21
 b001448:	308c703a 	and	r6,r6,r2
 b00144c:	003faf06 	br	b00130c <__alt_mem_flash+0xff00030c>
 b001450:	01c00804 	movi	r7,32
 b001454:	390fc83a 	sub	r7,r7,r4
 b001458:	89ce983a 	sll	r7,r17,r7
 b00145c:	890ad83a 	srl	r5,r17,r4
 b001460:	380ec03a 	cmpne	r7,r7,zero
 b001464:	29cab03a 	or	r5,r5,r7
 b001468:	28c001cc 	andi	r3,r5,7
 b00146c:	18000426 	beq	r3,zero,b001480 <__divsf3+0x3fc>
 b001470:	28c003cc 	andi	r3,r5,15
 b001474:	01000104 	movi	r4,4
 b001478:	19000126 	beq	r3,r4,b001480 <__divsf3+0x3fc>
 b00147c:	290b883a 	add	r5,r5,r4
 b001480:	28c1002c 	andhi	r3,r5,1024
 b001484:	18000426 	beq	r3,zero,b001498 <__divsf3+0x414>
 b001488:	11c0004c 	andi	r7,r2,1
 b00148c:	01000044 	movi	r4,1
 b001490:	000d883a 	mov	r6,zero
 b001494:	003f4b06 	br	b0011c4 <__alt_mem_flash+0xff0001c4>
 b001498:	280a91ba 	slli	r5,r5,6
 b00149c:	11c0004c 	andi	r7,r2,1
 b0014a0:	0009883a 	mov	r4,zero
 b0014a4:	280cd27a 	srli	r6,r5,9
 b0014a8:	003f4606 	br	b0011c4 <__alt_mem_flash+0xff0001c4>
 b0014ac:	00802034 	movhi	r2,128
 b0014b0:	89801034 	orhi	r6,r17,64
 b0014b4:	10bfffc4 	addi	r2,r2,-1
 b0014b8:	b00f883a 	mov	r7,r22
 b0014bc:	308c703a 	and	r6,r6,r2
 b0014c0:	003f9206 	br	b00130c <__alt_mem_flash+0xff00030c>

0b0014c4 <__adddf3>:
 b0014c4:	02c00434 	movhi	r11,16
 b0014c8:	5affffc4 	addi	r11,r11,-1
 b0014cc:	2806d7fa 	srli	r3,r5,31
 b0014d0:	2ad4703a 	and	r10,r5,r11
 b0014d4:	3ad2703a 	and	r9,r7,r11
 b0014d8:	3804d53a 	srli	r2,r7,20
 b0014dc:	3018d77a 	srli	r12,r6,29
 b0014e0:	280ad53a 	srli	r5,r5,20
 b0014e4:	501490fa 	slli	r10,r10,3
 b0014e8:	2010d77a 	srli	r8,r4,29
 b0014ec:	481290fa 	slli	r9,r9,3
 b0014f0:	380ed7fa 	srli	r7,r7,31
 b0014f4:	defffb04 	addi	sp,sp,-20
 b0014f8:	dc800215 	stw	r18,8(sp)
 b0014fc:	dc400115 	stw	r17,4(sp)
 b001500:	dc000015 	stw	r16,0(sp)
 b001504:	dfc00415 	stw	ra,16(sp)
 b001508:	dcc00315 	stw	r19,12(sp)
 b00150c:	1c803fcc 	andi	r18,r3,255
 b001510:	2c01ffcc 	andi	r16,r5,2047
 b001514:	5210b03a 	or	r8,r10,r8
 b001518:	202290fa 	slli	r17,r4,3
 b00151c:	1081ffcc 	andi	r2,r2,2047
 b001520:	4b12b03a 	or	r9,r9,r12
 b001524:	300c90fa 	slli	r6,r6,3
 b001528:	91c07526 	beq	r18,r7,b001700 <__adddf3+0x23c>
 b00152c:	8087c83a 	sub	r3,r16,r2
 b001530:	00c0ab0e 	bge	zero,r3,b0017e0 <__adddf3+0x31c>
 b001534:	10002a1e 	bne	r2,zero,b0015e0 <__adddf3+0x11c>
 b001538:	4984b03a 	or	r2,r9,r6
 b00153c:	1000961e 	bne	r2,zero,b001798 <__adddf3+0x2d4>
 b001540:	888001cc 	andi	r2,r17,7
 b001544:	10000726 	beq	r2,zero,b001564 <__adddf3+0xa0>
 b001548:	888003cc 	andi	r2,r17,15
 b00154c:	00c00104 	movi	r3,4
 b001550:	10c00426 	beq	r2,r3,b001564 <__adddf3+0xa0>
 b001554:	88c7883a 	add	r3,r17,r3
 b001558:	1c63803a 	cmpltu	r17,r3,r17
 b00155c:	4451883a 	add	r8,r8,r17
 b001560:	1823883a 	mov	r17,r3
 b001564:	4080202c 	andhi	r2,r8,128
 b001568:	10005926 	beq	r2,zero,b0016d0 <__adddf3+0x20c>
 b00156c:	84000044 	addi	r16,r16,1
 b001570:	0081ffc4 	movi	r2,2047
 b001574:	8080ba26 	beq	r16,r2,b001860 <__adddf3+0x39c>
 b001578:	00bfe034 	movhi	r2,65408
 b00157c:	10bfffc4 	addi	r2,r2,-1
 b001580:	4090703a 	and	r8,r8,r2
 b001584:	4004977a 	slli	r2,r8,29
 b001588:	4010927a 	slli	r8,r8,9
 b00158c:	8822d0fa 	srli	r17,r17,3
 b001590:	8401ffcc 	andi	r16,r16,2047
 b001594:	4010d33a 	srli	r8,r8,12
 b001598:	9007883a 	mov	r3,r18
 b00159c:	1444b03a 	or	r2,r2,r17
 b0015a0:	8401ffcc 	andi	r16,r16,2047
 b0015a4:	8020953a 	slli	r16,r16,20
 b0015a8:	18c03fcc 	andi	r3,r3,255
 b0015ac:	01000434 	movhi	r4,16
 b0015b0:	213fffc4 	addi	r4,r4,-1
 b0015b4:	180697fa 	slli	r3,r3,31
 b0015b8:	4110703a 	and	r8,r8,r4
 b0015bc:	4410b03a 	or	r8,r8,r16
 b0015c0:	40c6b03a 	or	r3,r8,r3
 b0015c4:	dfc00417 	ldw	ra,16(sp)
 b0015c8:	dcc00317 	ldw	r19,12(sp)
 b0015cc:	dc800217 	ldw	r18,8(sp)
 b0015d0:	dc400117 	ldw	r17,4(sp)
 b0015d4:	dc000017 	ldw	r16,0(sp)
 b0015d8:	dec00504 	addi	sp,sp,20
 b0015dc:	f800283a 	ret
 b0015e0:	0081ffc4 	movi	r2,2047
 b0015e4:	80bfd626 	beq	r16,r2,b001540 <__alt_mem_flash+0xff000540>
 b0015e8:	4a402034 	orhi	r9,r9,128
 b0015ec:	00800e04 	movi	r2,56
 b0015f0:	10c09f16 	blt	r2,r3,b001870 <__adddf3+0x3ac>
 b0015f4:	008007c4 	movi	r2,31
 b0015f8:	10c0c216 	blt	r2,r3,b001904 <__adddf3+0x440>
 b0015fc:	00800804 	movi	r2,32
 b001600:	10c5c83a 	sub	r2,r2,r3
 b001604:	488a983a 	sll	r5,r9,r2
 b001608:	30c8d83a 	srl	r4,r6,r3
 b00160c:	3084983a 	sll	r2,r6,r2
 b001610:	48c6d83a 	srl	r3,r9,r3
 b001614:	290cb03a 	or	r6,r5,r4
 b001618:	1004c03a 	cmpne	r2,r2,zero
 b00161c:	308cb03a 	or	r6,r6,r2
 b001620:	898dc83a 	sub	r6,r17,r6
 b001624:	89a3803a 	cmpltu	r17,r17,r6
 b001628:	40d1c83a 	sub	r8,r8,r3
 b00162c:	4451c83a 	sub	r8,r8,r17
 b001630:	3023883a 	mov	r17,r6
 b001634:	4080202c 	andhi	r2,r8,128
 b001638:	10002326 	beq	r2,zero,b0016c8 <__adddf3+0x204>
 b00163c:	04c02034 	movhi	r19,128
 b001640:	9cffffc4 	addi	r19,r19,-1
 b001644:	44e6703a 	and	r19,r8,r19
 b001648:	98007626 	beq	r19,zero,b001824 <__adddf3+0x360>
 b00164c:	9809883a 	mov	r4,r19
 b001650:	b003da00 	call	b003da0 <__clzsi2>
 b001654:	10fffe04 	addi	r3,r2,-8
 b001658:	010007c4 	movi	r4,31
 b00165c:	20c07716 	blt	r4,r3,b00183c <__adddf3+0x378>
 b001660:	00800804 	movi	r2,32
 b001664:	10c5c83a 	sub	r2,r2,r3
 b001668:	8884d83a 	srl	r2,r17,r2
 b00166c:	98d0983a 	sll	r8,r19,r3
 b001670:	88e2983a 	sll	r17,r17,r3
 b001674:	1204b03a 	or	r2,r2,r8
 b001678:	1c007416 	blt	r3,r16,b00184c <__adddf3+0x388>
 b00167c:	1c21c83a 	sub	r16,r3,r16
 b001680:	82000044 	addi	r8,r16,1
 b001684:	00c007c4 	movi	r3,31
 b001688:	1a009116 	blt	r3,r8,b0018d0 <__adddf3+0x40c>
 b00168c:	00c00804 	movi	r3,32
 b001690:	1a07c83a 	sub	r3,r3,r8
 b001694:	8a08d83a 	srl	r4,r17,r8
 b001698:	88e2983a 	sll	r17,r17,r3
 b00169c:	10c6983a 	sll	r3,r2,r3
 b0016a0:	1210d83a 	srl	r8,r2,r8
 b0016a4:	8804c03a 	cmpne	r2,r17,zero
 b0016a8:	1906b03a 	or	r3,r3,r4
 b0016ac:	18a2b03a 	or	r17,r3,r2
 b0016b0:	0021883a 	mov	r16,zero
 b0016b4:	003fa206 	br	b001540 <__alt_mem_flash+0xff000540>
 b0016b8:	1890b03a 	or	r8,r3,r2
 b0016bc:	40017d26 	beq	r8,zero,b001cb4 <__adddf3+0x7f0>
 b0016c0:	1011883a 	mov	r8,r2
 b0016c4:	1823883a 	mov	r17,r3
 b0016c8:	888001cc 	andi	r2,r17,7
 b0016cc:	103f9e1e 	bne	r2,zero,b001548 <__alt_mem_flash+0xff000548>
 b0016d0:	4004977a 	slli	r2,r8,29
 b0016d4:	8822d0fa 	srli	r17,r17,3
 b0016d8:	4010d0fa 	srli	r8,r8,3
 b0016dc:	9007883a 	mov	r3,r18
 b0016e0:	1444b03a 	or	r2,r2,r17
 b0016e4:	0101ffc4 	movi	r4,2047
 b0016e8:	81002426 	beq	r16,r4,b00177c <__adddf3+0x2b8>
 b0016ec:	8120703a 	and	r16,r16,r4
 b0016f0:	01000434 	movhi	r4,16
 b0016f4:	213fffc4 	addi	r4,r4,-1
 b0016f8:	4110703a 	and	r8,r8,r4
 b0016fc:	003fa806 	br	b0015a0 <__alt_mem_flash+0xff0005a0>
 b001700:	8089c83a 	sub	r4,r16,r2
 b001704:	01005e0e 	bge	zero,r4,b001880 <__adddf3+0x3bc>
 b001708:	10002b26 	beq	r2,zero,b0017b8 <__adddf3+0x2f4>
 b00170c:	0081ffc4 	movi	r2,2047
 b001710:	80bf8b26 	beq	r16,r2,b001540 <__alt_mem_flash+0xff000540>
 b001714:	4a402034 	orhi	r9,r9,128
 b001718:	00800e04 	movi	r2,56
 b00171c:	1100a40e 	bge	r2,r4,b0019b0 <__adddf3+0x4ec>
 b001720:	498cb03a 	or	r6,r9,r6
 b001724:	300ac03a 	cmpne	r5,r6,zero
 b001728:	0013883a 	mov	r9,zero
 b00172c:	2c4b883a 	add	r5,r5,r17
 b001730:	2c63803a 	cmpltu	r17,r5,r17
 b001734:	4a11883a 	add	r8,r9,r8
 b001738:	8a11883a 	add	r8,r17,r8
 b00173c:	2823883a 	mov	r17,r5
 b001740:	4080202c 	andhi	r2,r8,128
 b001744:	103fe026 	beq	r2,zero,b0016c8 <__alt_mem_flash+0xff0006c8>
 b001748:	84000044 	addi	r16,r16,1
 b00174c:	0081ffc4 	movi	r2,2047
 b001750:	8080d226 	beq	r16,r2,b001a9c <__adddf3+0x5d8>
 b001754:	00bfe034 	movhi	r2,65408
 b001758:	10bfffc4 	addi	r2,r2,-1
 b00175c:	4090703a 	and	r8,r8,r2
 b001760:	880ad07a 	srli	r5,r17,1
 b001764:	400897fa 	slli	r4,r8,31
 b001768:	88c0004c 	andi	r3,r17,1
 b00176c:	28e2b03a 	or	r17,r5,r3
 b001770:	4010d07a 	srli	r8,r8,1
 b001774:	2462b03a 	or	r17,r4,r17
 b001778:	003f7106 	br	b001540 <__alt_mem_flash+0xff000540>
 b00177c:	4088b03a 	or	r4,r8,r2
 b001780:	20014526 	beq	r4,zero,b001c98 <__adddf3+0x7d4>
 b001784:	01000434 	movhi	r4,16
 b001788:	42000234 	orhi	r8,r8,8
 b00178c:	213fffc4 	addi	r4,r4,-1
 b001790:	4110703a 	and	r8,r8,r4
 b001794:	003f8206 	br	b0015a0 <__alt_mem_flash+0xff0005a0>
 b001798:	18ffffc4 	addi	r3,r3,-1
 b00179c:	1800491e 	bne	r3,zero,b0018c4 <__adddf3+0x400>
 b0017a0:	898bc83a 	sub	r5,r17,r6
 b0017a4:	8963803a 	cmpltu	r17,r17,r5
 b0017a8:	4251c83a 	sub	r8,r8,r9
 b0017ac:	4451c83a 	sub	r8,r8,r17
 b0017b0:	2823883a 	mov	r17,r5
 b0017b4:	003f9f06 	br	b001634 <__alt_mem_flash+0xff000634>
 b0017b8:	4984b03a 	or	r2,r9,r6
 b0017bc:	103f6026 	beq	r2,zero,b001540 <__alt_mem_flash+0xff000540>
 b0017c0:	213fffc4 	addi	r4,r4,-1
 b0017c4:	2000931e 	bne	r4,zero,b001a14 <__adddf3+0x550>
 b0017c8:	898d883a 	add	r6,r17,r6
 b0017cc:	3463803a 	cmpltu	r17,r6,r17
 b0017d0:	4251883a 	add	r8,r8,r9
 b0017d4:	8a11883a 	add	r8,r17,r8
 b0017d8:	3023883a 	mov	r17,r6
 b0017dc:	003fd806 	br	b001740 <__alt_mem_flash+0xff000740>
 b0017e0:	1800541e 	bne	r3,zero,b001934 <__adddf3+0x470>
 b0017e4:	80800044 	addi	r2,r16,1
 b0017e8:	1081ffcc 	andi	r2,r2,2047
 b0017ec:	00c00044 	movi	r3,1
 b0017f0:	1880a00e 	bge	r3,r2,b001a74 <__adddf3+0x5b0>
 b0017f4:	8989c83a 	sub	r4,r17,r6
 b0017f8:	8905803a 	cmpltu	r2,r17,r4
 b0017fc:	4267c83a 	sub	r19,r8,r9
 b001800:	98a7c83a 	sub	r19,r19,r2
 b001804:	9880202c 	andhi	r2,r19,128
 b001808:	10006326 	beq	r2,zero,b001998 <__adddf3+0x4d4>
 b00180c:	3463c83a 	sub	r17,r6,r17
 b001810:	4a07c83a 	sub	r3,r9,r8
 b001814:	344d803a 	cmpltu	r6,r6,r17
 b001818:	19a7c83a 	sub	r19,r3,r6
 b00181c:	3825883a 	mov	r18,r7
 b001820:	983f8a1e 	bne	r19,zero,b00164c <__alt_mem_flash+0xff00064c>
 b001824:	8809883a 	mov	r4,r17
 b001828:	b003da00 	call	b003da0 <__clzsi2>
 b00182c:	10800804 	addi	r2,r2,32
 b001830:	10fffe04 	addi	r3,r2,-8
 b001834:	010007c4 	movi	r4,31
 b001838:	20ff890e 	bge	r4,r3,b001660 <__alt_mem_flash+0xff000660>
 b00183c:	10bff604 	addi	r2,r2,-40
 b001840:	8884983a 	sll	r2,r17,r2
 b001844:	0023883a 	mov	r17,zero
 b001848:	1c3f8c0e 	bge	r3,r16,b00167c <__alt_mem_flash+0xff00067c>
 b00184c:	023fe034 	movhi	r8,65408
 b001850:	423fffc4 	addi	r8,r8,-1
 b001854:	80e1c83a 	sub	r16,r16,r3
 b001858:	1210703a 	and	r8,r2,r8
 b00185c:	003f3806 	br	b001540 <__alt_mem_flash+0xff000540>
 b001860:	9007883a 	mov	r3,r18
 b001864:	0011883a 	mov	r8,zero
 b001868:	0005883a 	mov	r2,zero
 b00186c:	003f4c06 	br	b0015a0 <__alt_mem_flash+0xff0005a0>
 b001870:	498cb03a 	or	r6,r9,r6
 b001874:	300cc03a 	cmpne	r6,r6,zero
 b001878:	0007883a 	mov	r3,zero
 b00187c:	003f6806 	br	b001620 <__alt_mem_flash+0xff000620>
 b001880:	20009c1e 	bne	r4,zero,b001af4 <__adddf3+0x630>
 b001884:	80800044 	addi	r2,r16,1
 b001888:	1141ffcc 	andi	r5,r2,2047
 b00188c:	01000044 	movi	r4,1
 b001890:	2140670e 	bge	r4,r5,b001a30 <__adddf3+0x56c>
 b001894:	0101ffc4 	movi	r4,2047
 b001898:	11007f26 	beq	r2,r4,b001a98 <__adddf3+0x5d4>
 b00189c:	898d883a 	add	r6,r17,r6
 b0018a0:	4247883a 	add	r3,r8,r9
 b0018a4:	3451803a 	cmpltu	r8,r6,r17
 b0018a8:	40d1883a 	add	r8,r8,r3
 b0018ac:	402297fa 	slli	r17,r8,31
 b0018b0:	300cd07a 	srli	r6,r6,1
 b0018b4:	4010d07a 	srli	r8,r8,1
 b0018b8:	1021883a 	mov	r16,r2
 b0018bc:	89a2b03a 	or	r17,r17,r6
 b0018c0:	003f1f06 	br	b001540 <__alt_mem_flash+0xff000540>
 b0018c4:	0081ffc4 	movi	r2,2047
 b0018c8:	80bf481e 	bne	r16,r2,b0015ec <__alt_mem_flash+0xff0005ec>
 b0018cc:	003f1c06 	br	b001540 <__alt_mem_flash+0xff000540>
 b0018d0:	843ff844 	addi	r16,r16,-31
 b0018d4:	01000804 	movi	r4,32
 b0018d8:	1406d83a 	srl	r3,r2,r16
 b0018dc:	41005026 	beq	r8,r4,b001a20 <__adddf3+0x55c>
 b0018e0:	01001004 	movi	r4,64
 b0018e4:	2211c83a 	sub	r8,r4,r8
 b0018e8:	1204983a 	sll	r2,r2,r8
 b0018ec:	88a2b03a 	or	r17,r17,r2
 b0018f0:	8822c03a 	cmpne	r17,r17,zero
 b0018f4:	1c62b03a 	or	r17,r3,r17
 b0018f8:	0011883a 	mov	r8,zero
 b0018fc:	0021883a 	mov	r16,zero
 b001900:	003f7106 	br	b0016c8 <__alt_mem_flash+0xff0006c8>
 b001904:	193ff804 	addi	r4,r3,-32
 b001908:	00800804 	movi	r2,32
 b00190c:	4908d83a 	srl	r4,r9,r4
 b001910:	18804526 	beq	r3,r2,b001a28 <__adddf3+0x564>
 b001914:	00801004 	movi	r2,64
 b001918:	10c5c83a 	sub	r2,r2,r3
 b00191c:	4886983a 	sll	r3,r9,r2
 b001920:	198cb03a 	or	r6,r3,r6
 b001924:	300cc03a 	cmpne	r6,r6,zero
 b001928:	218cb03a 	or	r6,r4,r6
 b00192c:	0007883a 	mov	r3,zero
 b001930:	003f3b06 	br	b001620 <__alt_mem_flash+0xff000620>
 b001934:	80002a26 	beq	r16,zero,b0019e0 <__adddf3+0x51c>
 b001938:	0101ffc4 	movi	r4,2047
 b00193c:	11006826 	beq	r2,r4,b001ae0 <__adddf3+0x61c>
 b001940:	00c7c83a 	sub	r3,zero,r3
 b001944:	42002034 	orhi	r8,r8,128
 b001948:	01000e04 	movi	r4,56
 b00194c:	20c07c16 	blt	r4,r3,b001b40 <__adddf3+0x67c>
 b001950:	010007c4 	movi	r4,31
 b001954:	20c0da16 	blt	r4,r3,b001cc0 <__adddf3+0x7fc>
 b001958:	01000804 	movi	r4,32
 b00195c:	20c9c83a 	sub	r4,r4,r3
 b001960:	4114983a 	sll	r10,r8,r4
 b001964:	88cad83a 	srl	r5,r17,r3
 b001968:	8908983a 	sll	r4,r17,r4
 b00196c:	40c6d83a 	srl	r3,r8,r3
 b001970:	5162b03a 	or	r17,r10,r5
 b001974:	2008c03a 	cmpne	r4,r4,zero
 b001978:	8922b03a 	or	r17,r17,r4
 b00197c:	3463c83a 	sub	r17,r6,r17
 b001980:	48c7c83a 	sub	r3,r9,r3
 b001984:	344d803a 	cmpltu	r6,r6,r17
 b001988:	1991c83a 	sub	r8,r3,r6
 b00198c:	1021883a 	mov	r16,r2
 b001990:	3825883a 	mov	r18,r7
 b001994:	003f2706 	br	b001634 <__alt_mem_flash+0xff000634>
 b001998:	24d0b03a 	or	r8,r4,r19
 b00199c:	40001b1e 	bne	r8,zero,b001a0c <__adddf3+0x548>
 b0019a0:	0005883a 	mov	r2,zero
 b0019a4:	0007883a 	mov	r3,zero
 b0019a8:	0021883a 	mov	r16,zero
 b0019ac:	003f4d06 	br	b0016e4 <__alt_mem_flash+0xff0006e4>
 b0019b0:	008007c4 	movi	r2,31
 b0019b4:	11003c16 	blt	r2,r4,b001aa8 <__adddf3+0x5e4>
 b0019b8:	00800804 	movi	r2,32
 b0019bc:	1105c83a 	sub	r2,r2,r4
 b0019c0:	488e983a 	sll	r7,r9,r2
 b0019c4:	310ad83a 	srl	r5,r6,r4
 b0019c8:	3084983a 	sll	r2,r6,r2
 b0019cc:	4912d83a 	srl	r9,r9,r4
 b0019d0:	394ab03a 	or	r5,r7,r5
 b0019d4:	1004c03a 	cmpne	r2,r2,zero
 b0019d8:	288ab03a 	or	r5,r5,r2
 b0019dc:	003f5306 	br	b00172c <__alt_mem_flash+0xff00072c>
 b0019e0:	4448b03a 	or	r4,r8,r17
 b0019e4:	20003e26 	beq	r4,zero,b001ae0 <__adddf3+0x61c>
 b0019e8:	00c6303a 	nor	r3,zero,r3
 b0019ec:	18003a1e 	bne	r3,zero,b001ad8 <__adddf3+0x614>
 b0019f0:	3463c83a 	sub	r17,r6,r17
 b0019f4:	4a07c83a 	sub	r3,r9,r8
 b0019f8:	344d803a 	cmpltu	r6,r6,r17
 b0019fc:	1991c83a 	sub	r8,r3,r6
 b001a00:	1021883a 	mov	r16,r2
 b001a04:	3825883a 	mov	r18,r7
 b001a08:	003f0a06 	br	b001634 <__alt_mem_flash+0xff000634>
 b001a0c:	2023883a 	mov	r17,r4
 b001a10:	003f0d06 	br	b001648 <__alt_mem_flash+0xff000648>
 b001a14:	0081ffc4 	movi	r2,2047
 b001a18:	80bf3f1e 	bne	r16,r2,b001718 <__alt_mem_flash+0xff000718>
 b001a1c:	003ec806 	br	b001540 <__alt_mem_flash+0xff000540>
 b001a20:	0005883a 	mov	r2,zero
 b001a24:	003fb106 	br	b0018ec <__alt_mem_flash+0xff0008ec>
 b001a28:	0007883a 	mov	r3,zero
 b001a2c:	003fbc06 	br	b001920 <__alt_mem_flash+0xff000920>
 b001a30:	4444b03a 	or	r2,r8,r17
 b001a34:	8000871e 	bne	r16,zero,b001c54 <__adddf3+0x790>
 b001a38:	1000ba26 	beq	r2,zero,b001d24 <__adddf3+0x860>
 b001a3c:	4984b03a 	or	r2,r9,r6
 b001a40:	103ebf26 	beq	r2,zero,b001540 <__alt_mem_flash+0xff000540>
 b001a44:	8985883a 	add	r2,r17,r6
 b001a48:	4247883a 	add	r3,r8,r9
 b001a4c:	1451803a 	cmpltu	r8,r2,r17
 b001a50:	40d1883a 	add	r8,r8,r3
 b001a54:	40c0202c 	andhi	r3,r8,128
 b001a58:	1023883a 	mov	r17,r2
 b001a5c:	183f1a26 	beq	r3,zero,b0016c8 <__alt_mem_flash+0xff0006c8>
 b001a60:	00bfe034 	movhi	r2,65408
 b001a64:	10bfffc4 	addi	r2,r2,-1
 b001a68:	2021883a 	mov	r16,r4
 b001a6c:	4090703a 	and	r8,r8,r2
 b001a70:	003eb306 	br	b001540 <__alt_mem_flash+0xff000540>
 b001a74:	4444b03a 	or	r2,r8,r17
 b001a78:	8000291e 	bne	r16,zero,b001b20 <__adddf3+0x65c>
 b001a7c:	10004b1e 	bne	r2,zero,b001bac <__adddf3+0x6e8>
 b001a80:	4990b03a 	or	r8,r9,r6
 b001a84:	40008b26 	beq	r8,zero,b001cb4 <__adddf3+0x7f0>
 b001a88:	4811883a 	mov	r8,r9
 b001a8c:	3023883a 	mov	r17,r6
 b001a90:	3825883a 	mov	r18,r7
 b001a94:	003eaa06 	br	b001540 <__alt_mem_flash+0xff000540>
 b001a98:	1021883a 	mov	r16,r2
 b001a9c:	0011883a 	mov	r8,zero
 b001aa0:	0005883a 	mov	r2,zero
 b001aa4:	003f0f06 	br	b0016e4 <__alt_mem_flash+0xff0006e4>
 b001aa8:	217ff804 	addi	r5,r4,-32
 b001aac:	00800804 	movi	r2,32
 b001ab0:	494ad83a 	srl	r5,r9,r5
 b001ab4:	20807d26 	beq	r4,r2,b001cac <__adddf3+0x7e8>
 b001ab8:	00801004 	movi	r2,64
 b001abc:	1109c83a 	sub	r4,r2,r4
 b001ac0:	4912983a 	sll	r9,r9,r4
 b001ac4:	498cb03a 	or	r6,r9,r6
 b001ac8:	300cc03a 	cmpne	r6,r6,zero
 b001acc:	298ab03a 	or	r5,r5,r6
 b001ad0:	0013883a 	mov	r9,zero
 b001ad4:	003f1506 	br	b00172c <__alt_mem_flash+0xff00072c>
 b001ad8:	0101ffc4 	movi	r4,2047
 b001adc:	113f9a1e 	bne	r2,r4,b001948 <__alt_mem_flash+0xff000948>
 b001ae0:	4811883a 	mov	r8,r9
 b001ae4:	3023883a 	mov	r17,r6
 b001ae8:	1021883a 	mov	r16,r2
 b001aec:	3825883a 	mov	r18,r7
 b001af0:	003e9306 	br	b001540 <__alt_mem_flash+0xff000540>
 b001af4:	8000161e 	bne	r16,zero,b001b50 <__adddf3+0x68c>
 b001af8:	444ab03a 	or	r5,r8,r17
 b001afc:	28005126 	beq	r5,zero,b001c44 <__adddf3+0x780>
 b001b00:	0108303a 	nor	r4,zero,r4
 b001b04:	20004d1e 	bne	r4,zero,b001c3c <__adddf3+0x778>
 b001b08:	89a3883a 	add	r17,r17,r6
 b001b0c:	4253883a 	add	r9,r8,r9
 b001b10:	898d803a 	cmpltu	r6,r17,r6
 b001b14:	3251883a 	add	r8,r6,r9
 b001b18:	1021883a 	mov	r16,r2
 b001b1c:	003f0806 	br	b001740 <__alt_mem_flash+0xff000740>
 b001b20:	1000301e 	bne	r2,zero,b001be4 <__adddf3+0x720>
 b001b24:	4984b03a 	or	r2,r9,r6
 b001b28:	10007126 	beq	r2,zero,b001cf0 <__adddf3+0x82c>
 b001b2c:	4811883a 	mov	r8,r9
 b001b30:	3023883a 	mov	r17,r6
 b001b34:	3825883a 	mov	r18,r7
 b001b38:	0401ffc4 	movi	r16,2047
 b001b3c:	003e8006 	br	b001540 <__alt_mem_flash+0xff000540>
 b001b40:	4462b03a 	or	r17,r8,r17
 b001b44:	8822c03a 	cmpne	r17,r17,zero
 b001b48:	0007883a 	mov	r3,zero
 b001b4c:	003f8b06 	br	b00197c <__alt_mem_flash+0xff00097c>
 b001b50:	0141ffc4 	movi	r5,2047
 b001b54:	11403b26 	beq	r2,r5,b001c44 <__adddf3+0x780>
 b001b58:	0109c83a 	sub	r4,zero,r4
 b001b5c:	42002034 	orhi	r8,r8,128
 b001b60:	01400e04 	movi	r5,56
 b001b64:	29006716 	blt	r5,r4,b001d04 <__adddf3+0x840>
 b001b68:	014007c4 	movi	r5,31
 b001b6c:	29007016 	blt	r5,r4,b001d30 <__adddf3+0x86c>
 b001b70:	01400804 	movi	r5,32
 b001b74:	290bc83a 	sub	r5,r5,r4
 b001b78:	4154983a 	sll	r10,r8,r5
 b001b7c:	890ed83a 	srl	r7,r17,r4
 b001b80:	894a983a 	sll	r5,r17,r5
 b001b84:	4108d83a 	srl	r4,r8,r4
 b001b88:	51e2b03a 	or	r17,r10,r7
 b001b8c:	280ac03a 	cmpne	r5,r5,zero
 b001b90:	8962b03a 	or	r17,r17,r5
 b001b94:	89a3883a 	add	r17,r17,r6
 b001b98:	2253883a 	add	r9,r4,r9
 b001b9c:	898d803a 	cmpltu	r6,r17,r6
 b001ba0:	3251883a 	add	r8,r6,r9
 b001ba4:	1021883a 	mov	r16,r2
 b001ba8:	003ee506 	br	b001740 <__alt_mem_flash+0xff000740>
 b001bac:	4984b03a 	or	r2,r9,r6
 b001bb0:	103e6326 	beq	r2,zero,b001540 <__alt_mem_flash+0xff000540>
 b001bb4:	8987c83a 	sub	r3,r17,r6
 b001bb8:	88c9803a 	cmpltu	r4,r17,r3
 b001bbc:	4245c83a 	sub	r2,r8,r9
 b001bc0:	1105c83a 	sub	r2,r2,r4
 b001bc4:	1100202c 	andhi	r4,r2,128
 b001bc8:	203ebb26 	beq	r4,zero,b0016b8 <__alt_mem_flash+0xff0006b8>
 b001bcc:	3463c83a 	sub	r17,r6,r17
 b001bd0:	4a07c83a 	sub	r3,r9,r8
 b001bd4:	344d803a 	cmpltu	r6,r6,r17
 b001bd8:	1991c83a 	sub	r8,r3,r6
 b001bdc:	3825883a 	mov	r18,r7
 b001be0:	003e5706 	br	b001540 <__alt_mem_flash+0xff000540>
 b001be4:	4984b03a 	or	r2,r9,r6
 b001be8:	10002e26 	beq	r2,zero,b001ca4 <__adddf3+0x7e0>
 b001bec:	4004d0fa 	srli	r2,r8,3
 b001bf0:	8822d0fa 	srli	r17,r17,3
 b001bf4:	4010977a 	slli	r8,r8,29
 b001bf8:	10c0022c 	andhi	r3,r2,8
 b001bfc:	4462b03a 	or	r17,r8,r17
 b001c00:	18000826 	beq	r3,zero,b001c24 <__adddf3+0x760>
 b001c04:	4808d0fa 	srli	r4,r9,3
 b001c08:	20c0022c 	andhi	r3,r4,8
 b001c0c:	1800051e 	bne	r3,zero,b001c24 <__adddf3+0x760>
 b001c10:	300cd0fa 	srli	r6,r6,3
 b001c14:	4806977a 	slli	r3,r9,29
 b001c18:	2005883a 	mov	r2,r4
 b001c1c:	3825883a 	mov	r18,r7
 b001c20:	19a2b03a 	or	r17,r3,r6
 b001c24:	8810d77a 	srli	r8,r17,29
 b001c28:	100490fa 	slli	r2,r2,3
 b001c2c:	882290fa 	slli	r17,r17,3
 b001c30:	0401ffc4 	movi	r16,2047
 b001c34:	4090b03a 	or	r8,r8,r2
 b001c38:	003e4106 	br	b001540 <__alt_mem_flash+0xff000540>
 b001c3c:	0141ffc4 	movi	r5,2047
 b001c40:	117fc71e 	bne	r2,r5,b001b60 <__alt_mem_flash+0xff000b60>
 b001c44:	4811883a 	mov	r8,r9
 b001c48:	3023883a 	mov	r17,r6
 b001c4c:	1021883a 	mov	r16,r2
 b001c50:	003e3b06 	br	b001540 <__alt_mem_flash+0xff000540>
 b001c54:	10002f26 	beq	r2,zero,b001d14 <__adddf3+0x850>
 b001c58:	4984b03a 	or	r2,r9,r6
 b001c5c:	10001126 	beq	r2,zero,b001ca4 <__adddf3+0x7e0>
 b001c60:	4004d0fa 	srli	r2,r8,3
 b001c64:	8822d0fa 	srli	r17,r17,3
 b001c68:	4010977a 	slli	r8,r8,29
 b001c6c:	10c0022c 	andhi	r3,r2,8
 b001c70:	4462b03a 	or	r17,r8,r17
 b001c74:	183feb26 	beq	r3,zero,b001c24 <__alt_mem_flash+0xff000c24>
 b001c78:	4808d0fa 	srli	r4,r9,3
 b001c7c:	20c0022c 	andhi	r3,r4,8
 b001c80:	183fe81e 	bne	r3,zero,b001c24 <__alt_mem_flash+0xff000c24>
 b001c84:	300cd0fa 	srli	r6,r6,3
 b001c88:	4806977a 	slli	r3,r9,29
 b001c8c:	2005883a 	mov	r2,r4
 b001c90:	19a2b03a 	or	r17,r3,r6
 b001c94:	003fe306 	br	b001c24 <__alt_mem_flash+0xff000c24>
 b001c98:	0011883a 	mov	r8,zero
 b001c9c:	0005883a 	mov	r2,zero
 b001ca0:	003e3f06 	br	b0015a0 <__alt_mem_flash+0xff0005a0>
 b001ca4:	0401ffc4 	movi	r16,2047
 b001ca8:	003e2506 	br	b001540 <__alt_mem_flash+0xff000540>
 b001cac:	0013883a 	mov	r9,zero
 b001cb0:	003f8406 	br	b001ac4 <__alt_mem_flash+0xff000ac4>
 b001cb4:	0005883a 	mov	r2,zero
 b001cb8:	0007883a 	mov	r3,zero
 b001cbc:	003e8906 	br	b0016e4 <__alt_mem_flash+0xff0006e4>
 b001cc0:	197ff804 	addi	r5,r3,-32
 b001cc4:	01000804 	movi	r4,32
 b001cc8:	414ad83a 	srl	r5,r8,r5
 b001ccc:	19002426 	beq	r3,r4,b001d60 <__adddf3+0x89c>
 b001cd0:	01001004 	movi	r4,64
 b001cd4:	20c7c83a 	sub	r3,r4,r3
 b001cd8:	40c6983a 	sll	r3,r8,r3
 b001cdc:	1c46b03a 	or	r3,r3,r17
 b001ce0:	1806c03a 	cmpne	r3,r3,zero
 b001ce4:	28e2b03a 	or	r17,r5,r3
 b001ce8:	0007883a 	mov	r3,zero
 b001cec:	003f2306 	br	b00197c <__alt_mem_flash+0xff00097c>
 b001cf0:	0007883a 	mov	r3,zero
 b001cf4:	5811883a 	mov	r8,r11
 b001cf8:	00bfffc4 	movi	r2,-1
 b001cfc:	0401ffc4 	movi	r16,2047
 b001d00:	003e7806 	br	b0016e4 <__alt_mem_flash+0xff0006e4>
 b001d04:	4462b03a 	or	r17,r8,r17
 b001d08:	8822c03a 	cmpne	r17,r17,zero
 b001d0c:	0009883a 	mov	r4,zero
 b001d10:	003fa006 	br	b001b94 <__alt_mem_flash+0xff000b94>
 b001d14:	4811883a 	mov	r8,r9
 b001d18:	3023883a 	mov	r17,r6
 b001d1c:	0401ffc4 	movi	r16,2047
 b001d20:	003e0706 	br	b001540 <__alt_mem_flash+0xff000540>
 b001d24:	4811883a 	mov	r8,r9
 b001d28:	3023883a 	mov	r17,r6
 b001d2c:	003e0406 	br	b001540 <__alt_mem_flash+0xff000540>
 b001d30:	21fff804 	addi	r7,r4,-32
 b001d34:	01400804 	movi	r5,32
 b001d38:	41ced83a 	srl	r7,r8,r7
 b001d3c:	21400a26 	beq	r4,r5,b001d68 <__adddf3+0x8a4>
 b001d40:	01401004 	movi	r5,64
 b001d44:	2909c83a 	sub	r4,r5,r4
 b001d48:	4108983a 	sll	r4,r8,r4
 b001d4c:	2448b03a 	or	r4,r4,r17
 b001d50:	2008c03a 	cmpne	r4,r4,zero
 b001d54:	3922b03a 	or	r17,r7,r4
 b001d58:	0009883a 	mov	r4,zero
 b001d5c:	003f8d06 	br	b001b94 <__alt_mem_flash+0xff000b94>
 b001d60:	0007883a 	mov	r3,zero
 b001d64:	003fdd06 	br	b001cdc <__alt_mem_flash+0xff000cdc>
 b001d68:	0009883a 	mov	r4,zero
 b001d6c:	003ff706 	br	b001d4c <__alt_mem_flash+0xff000d4c>

0b001d70 <__divdf3>:
 b001d70:	defff004 	addi	sp,sp,-64
 b001d74:	dc800815 	stw	r18,32(sp)
 b001d78:	2824d53a 	srli	r18,r5,20
 b001d7c:	dd800c15 	stw	r22,48(sp)
 b001d80:	282cd7fa 	srli	r22,r5,31
 b001d84:	dc000615 	stw	r16,24(sp)
 b001d88:	04000434 	movhi	r16,16
 b001d8c:	843fffc4 	addi	r16,r16,-1
 b001d90:	dfc00f15 	stw	ra,60(sp)
 b001d94:	df000e15 	stw	fp,56(sp)
 b001d98:	ddc00d15 	stw	r23,52(sp)
 b001d9c:	dd400b15 	stw	r21,44(sp)
 b001da0:	dd000a15 	stw	r20,40(sp)
 b001da4:	dcc00915 	stw	r19,36(sp)
 b001da8:	dc400715 	stw	r17,28(sp)
 b001dac:	9481ffcc 	andi	r18,r18,2047
 b001db0:	2c20703a 	and	r16,r5,r16
 b001db4:	b2003fcc 	andi	r8,r22,255
 b001db8:	90006126 	beq	r18,zero,b001f40 <__divdf3+0x1d0>
 b001dbc:	0081ffc4 	movi	r2,2047
 b001dc0:	202b883a 	mov	r21,r4
 b001dc4:	90803726 	beq	r18,r2,b001ea4 <__divdf3+0x134>
 b001dc8:	80800434 	orhi	r2,r16,16
 b001dcc:	100490fa 	slli	r2,r2,3
 b001dd0:	2020d77a 	srli	r16,r4,29
 b001dd4:	202a90fa 	slli	r21,r4,3
 b001dd8:	94bf0044 	addi	r18,r18,-1023
 b001ddc:	80a0b03a 	or	r16,r16,r2
 b001de0:	0013883a 	mov	r9,zero
 b001de4:	000b883a 	mov	r5,zero
 b001de8:	3806d53a 	srli	r3,r7,20
 b001dec:	382ed7fa 	srli	r23,r7,31
 b001df0:	04400434 	movhi	r17,16
 b001df4:	8c7fffc4 	addi	r17,r17,-1
 b001df8:	18c1ffcc 	andi	r3,r3,2047
 b001dfc:	3029883a 	mov	r20,r6
 b001e00:	3c62703a 	and	r17,r7,r17
 b001e04:	bf003fcc 	andi	fp,r23,255
 b001e08:	18006e26 	beq	r3,zero,b001fc4 <__divdf3+0x254>
 b001e0c:	0081ffc4 	movi	r2,2047
 b001e10:	18806626 	beq	r3,r2,b001fac <__divdf3+0x23c>
 b001e14:	88800434 	orhi	r2,r17,16
 b001e18:	100490fa 	slli	r2,r2,3
 b001e1c:	3022d77a 	srli	r17,r6,29
 b001e20:	302890fa 	slli	r20,r6,3
 b001e24:	18ff0044 	addi	r3,r3,-1023
 b001e28:	88a2b03a 	or	r17,r17,r2
 b001e2c:	000f883a 	mov	r7,zero
 b001e30:	b5e6f03a 	xor	r19,r22,r23
 b001e34:	3a4cb03a 	or	r6,r7,r9
 b001e38:	008003c4 	movi	r2,15
 b001e3c:	9809883a 	mov	r4,r19
 b001e40:	90c7c83a 	sub	r3,r18,r3
 b001e44:	9cc03fcc 	andi	r19,r19,255
 b001e48:	11809636 	bltu	r2,r6,b0020a4 <__divdf3+0x334>
 b001e4c:	300c90ba 	slli	r6,r6,2
 b001e50:	0082c034 	movhi	r2,2816
 b001e54:	10879904 	addi	r2,r2,7780
 b001e58:	308d883a 	add	r6,r6,r2
 b001e5c:	30800017 	ldw	r2,0(r6)
 b001e60:	1000683a 	jmp	r2
 b001e64:	0b0020a4 	muli	r12,at,130
 b001e68:	0b001edc 	xori	r12,at,123
 b001e6c:	0b002094 	ori	r12,at,130
 b001e70:	0b001ed0 	cmplti	r12,at,123
 b001e74:	0b002094 	ori	r12,at,130
 b001e78:	0b002068 	cmpgeui	r12,at,129
 b001e7c:	0b002094 	ori	r12,at,130
 b001e80:	0b001ed0 	cmplti	r12,at,123
 b001e84:	0b001edc 	xori	r12,at,123
 b001e88:	0b001edc 	xori	r12,at,123
 b001e8c:	0b002068 	cmpgeui	r12,at,129
 b001e90:	0b001ed0 	cmplti	r12,at,123
 b001e94:	0b001ec0 	call	b001ec <__alt_mem_onchip-0x34ffe14>
 b001e98:	0b001ec0 	call	b001ec <__alt_mem_onchip-0x34ffe14>
 b001e9c:	0b001ec0 	call	b001ec <__alt_mem_onchip-0x34ffe14>
 b001ea0:	0b00242c 	andhi	r12,at,144
 b001ea4:	2404b03a 	or	r2,r4,r16
 b001ea8:	10006c1e 	bne	r2,zero,b00205c <__divdf3+0x2ec>
 b001eac:	02400204 	movi	r9,8
 b001eb0:	0021883a 	mov	r16,zero
 b001eb4:	002b883a 	mov	r21,zero
 b001eb8:	01400084 	movi	r5,2
 b001ebc:	003fca06 	br	b001de8 <__alt_mem_flash+0xff000de8>
 b001ec0:	8023883a 	mov	r17,r16
 b001ec4:	a829883a 	mov	r20,r21
 b001ec8:	4039883a 	mov	fp,r8
 b001ecc:	280f883a 	mov	r7,r5
 b001ed0:	00800084 	movi	r2,2
 b001ed4:	3881601e 	bne	r7,r2,b002458 <__divdf3+0x6e8>
 b001ed8:	e027883a 	mov	r19,fp
 b001edc:	9900004c 	andi	r4,r19,1
 b001ee0:	0081ffc4 	movi	r2,2047
 b001ee4:	0021883a 	mov	r16,zero
 b001ee8:	002b883a 	mov	r21,zero
 b001eec:	1004953a 	slli	r2,r2,20
 b001ef0:	20c03fcc 	andi	r3,r4,255
 b001ef4:	01400434 	movhi	r5,16
 b001ef8:	297fffc4 	addi	r5,r5,-1
 b001efc:	180697fa 	slli	r3,r3,31
 b001f00:	8160703a 	and	r16,r16,r5
 b001f04:	80a0b03a 	or	r16,r16,r2
 b001f08:	80c6b03a 	or	r3,r16,r3
 b001f0c:	a805883a 	mov	r2,r21
 b001f10:	dfc00f17 	ldw	ra,60(sp)
 b001f14:	df000e17 	ldw	fp,56(sp)
 b001f18:	ddc00d17 	ldw	r23,52(sp)
 b001f1c:	dd800c17 	ldw	r22,48(sp)
 b001f20:	dd400b17 	ldw	r21,44(sp)
 b001f24:	dd000a17 	ldw	r20,40(sp)
 b001f28:	dcc00917 	ldw	r19,36(sp)
 b001f2c:	dc800817 	ldw	r18,32(sp)
 b001f30:	dc400717 	ldw	r17,28(sp)
 b001f34:	dc000617 	ldw	r16,24(sp)
 b001f38:	dec01004 	addi	sp,sp,64
 b001f3c:	f800283a 	ret
 b001f40:	2404b03a 	or	r2,r4,r16
 b001f44:	2023883a 	mov	r17,r4
 b001f48:	10003f26 	beq	r2,zero,b002048 <__divdf3+0x2d8>
 b001f4c:	80015e26 	beq	r16,zero,b0024c8 <__divdf3+0x758>
 b001f50:	8009883a 	mov	r4,r16
 b001f54:	d9800215 	stw	r6,8(sp)
 b001f58:	d9c00515 	stw	r7,20(sp)
 b001f5c:	da000415 	stw	r8,16(sp)
 b001f60:	b003da00 	call	b003da0 <__clzsi2>
 b001f64:	d9800217 	ldw	r6,8(sp)
 b001f68:	d9c00517 	ldw	r7,20(sp)
 b001f6c:	da000417 	ldw	r8,16(sp)
 b001f70:	113ffd44 	addi	r4,r2,-11
 b001f74:	00c00704 	movi	r3,28
 b001f78:	19014f16 	blt	r3,r4,b0024b8 <__divdf3+0x748>
 b001f7c:	00c00744 	movi	r3,29
 b001f80:	157ffe04 	addi	r21,r2,-8
 b001f84:	1907c83a 	sub	r3,r3,r4
 b001f88:	8560983a 	sll	r16,r16,r21
 b001f8c:	88c6d83a 	srl	r3,r17,r3
 b001f90:	8d6a983a 	sll	r21,r17,r21
 b001f94:	1c20b03a 	or	r16,r3,r16
 b001f98:	1080fcc4 	addi	r2,r2,1011
 b001f9c:	00a5c83a 	sub	r18,zero,r2
 b001fa0:	0013883a 	mov	r9,zero
 b001fa4:	000b883a 	mov	r5,zero
 b001fa8:	003f8f06 	br	b001de8 <__alt_mem_flash+0xff000de8>
 b001fac:	3444b03a 	or	r2,r6,r17
 b001fb0:	1000231e 	bne	r2,zero,b002040 <__divdf3+0x2d0>
 b001fb4:	0023883a 	mov	r17,zero
 b001fb8:	0029883a 	mov	r20,zero
 b001fbc:	01c00084 	movi	r7,2
 b001fc0:	003f9b06 	br	b001e30 <__alt_mem_flash+0xff000e30>
 b001fc4:	3444b03a 	or	r2,r6,r17
 b001fc8:	10001926 	beq	r2,zero,b002030 <__divdf3+0x2c0>
 b001fcc:	88014b26 	beq	r17,zero,b0024fc <__divdf3+0x78c>
 b001fd0:	8809883a 	mov	r4,r17
 b001fd4:	d9400115 	stw	r5,4(sp)
 b001fd8:	d9800215 	stw	r6,8(sp)
 b001fdc:	da000415 	stw	r8,16(sp)
 b001fe0:	da400315 	stw	r9,12(sp)
 b001fe4:	b003da00 	call	b003da0 <__clzsi2>
 b001fe8:	d9400117 	ldw	r5,4(sp)
 b001fec:	d9800217 	ldw	r6,8(sp)
 b001ff0:	da000417 	ldw	r8,16(sp)
 b001ff4:	da400317 	ldw	r9,12(sp)
 b001ff8:	113ffd44 	addi	r4,r2,-11
 b001ffc:	00c00704 	movi	r3,28
 b002000:	19013a16 	blt	r3,r4,b0024ec <__divdf3+0x77c>
 b002004:	00c00744 	movi	r3,29
 b002008:	153ffe04 	addi	r20,r2,-8
 b00200c:	1907c83a 	sub	r3,r3,r4
 b002010:	8d22983a 	sll	r17,r17,r20
 b002014:	30c6d83a 	srl	r3,r6,r3
 b002018:	3528983a 	sll	r20,r6,r20
 b00201c:	1c62b03a 	or	r17,r3,r17
 b002020:	1080fcc4 	addi	r2,r2,1011
 b002024:	0087c83a 	sub	r3,zero,r2
 b002028:	000f883a 	mov	r7,zero
 b00202c:	003f8006 	br	b001e30 <__alt_mem_flash+0xff000e30>
 b002030:	0023883a 	mov	r17,zero
 b002034:	0029883a 	mov	r20,zero
 b002038:	01c00044 	movi	r7,1
 b00203c:	003f7c06 	br	b001e30 <__alt_mem_flash+0xff000e30>
 b002040:	01c000c4 	movi	r7,3
 b002044:	003f7a06 	br	b001e30 <__alt_mem_flash+0xff000e30>
 b002048:	02400104 	movi	r9,4
 b00204c:	0021883a 	mov	r16,zero
 b002050:	002b883a 	mov	r21,zero
 b002054:	01400044 	movi	r5,1
 b002058:	003f6306 	br	b001de8 <__alt_mem_flash+0xff000de8>
 b00205c:	02400304 	movi	r9,12
 b002060:	014000c4 	movi	r5,3
 b002064:	003f6006 	br	b001de8 <__alt_mem_flash+0xff000de8>
 b002068:	04000434 	movhi	r16,16
 b00206c:	0009883a 	mov	r4,zero
 b002070:	843fffc4 	addi	r16,r16,-1
 b002074:	057fffc4 	movi	r21,-1
 b002078:	0081ffc4 	movi	r2,2047
 b00207c:	003f9b06 	br	b001eec <__alt_mem_flash+0xff000eec>
 b002080:	00c00044 	movi	r3,1
 b002084:	1887c83a 	sub	r3,r3,r2
 b002088:	01000e04 	movi	r4,56
 b00208c:	20c1530e 	bge	r4,r3,b0025dc <__divdf3+0x86c>
 b002090:	9900004c 	andi	r4,r19,1
 b002094:	0005883a 	mov	r2,zero
 b002098:	0021883a 	mov	r16,zero
 b00209c:	002b883a 	mov	r21,zero
 b0020a0:	003f9206 	br	b001eec <__alt_mem_flash+0xff000eec>
 b0020a4:	8c012e36 	bltu	r17,r16,b002560 <__divdf3+0x7f0>
 b0020a8:	84412c26 	beq	r16,r17,b00255c <__divdf3+0x7ec>
 b0020ac:	a82f883a 	mov	r23,r21
 b0020b0:	18ffffc4 	addi	r3,r3,-1
 b0020b4:	002b883a 	mov	r21,zero
 b0020b8:	a004d63a 	srli	r2,r20,24
 b0020bc:	8822923a 	slli	r17,r17,8
 b0020c0:	a028923a 	slli	r20,r20,8
 b0020c4:	8009883a 	mov	r4,r16
 b0020c8:	88acb03a 	or	r22,r17,r2
 b0020cc:	dd000015 	stw	r20,0(sp)
 b0020d0:	b028d43a 	srli	r20,r22,16
 b0020d4:	d8c00215 	stw	r3,8(sp)
 b0020d8:	b4bfffcc 	andi	r18,r22,65535
 b0020dc:	a00b883a 	mov	r5,r20
 b0020e0:	b003efc0 	call	b003efc <__udivsi3>
 b0020e4:	100b883a 	mov	r5,r2
 b0020e8:	9009883a 	mov	r4,r18
 b0020ec:	1023883a 	mov	r17,r2
 b0020f0:	b003fb80 	call	b003fb8 <__mulsi3>
 b0020f4:	8009883a 	mov	r4,r16
 b0020f8:	a00b883a 	mov	r5,r20
 b0020fc:	1039883a 	mov	fp,r2
 b002100:	b003f600 	call	b003f60 <__umodsi3>
 b002104:	1004943a 	slli	r2,r2,16
 b002108:	b808d43a 	srli	r4,r23,16
 b00210c:	d8c00217 	ldw	r3,8(sp)
 b002110:	2084b03a 	or	r2,r4,r2
 b002114:	1700062e 	bgeu	r2,fp,b002130 <__divdf3+0x3c0>
 b002118:	1585883a 	add	r2,r2,r22
 b00211c:	893fffc4 	addi	r4,r17,-1
 b002120:	15811d36 	bltu	r2,r22,b002598 <__divdf3+0x828>
 b002124:	17011c2e 	bgeu	r2,fp,b002598 <__divdf3+0x828>
 b002128:	8c7fff84 	addi	r17,r17,-2
 b00212c:	1585883a 	add	r2,r2,r22
 b002130:	1739c83a 	sub	fp,r2,fp
 b002134:	a00b883a 	mov	r5,r20
 b002138:	e009883a 	mov	r4,fp
 b00213c:	d8c00215 	stw	r3,8(sp)
 b002140:	b003efc0 	call	b003efc <__udivsi3>
 b002144:	100b883a 	mov	r5,r2
 b002148:	9009883a 	mov	r4,r18
 b00214c:	1021883a 	mov	r16,r2
 b002150:	b003fb80 	call	b003fb8 <__mulsi3>
 b002154:	a00b883a 	mov	r5,r20
 b002158:	e009883a 	mov	r4,fp
 b00215c:	d8800415 	stw	r2,16(sp)
 b002160:	b003f600 	call	b003f60 <__umodsi3>
 b002164:	1004943a 	slli	r2,r2,16
 b002168:	da000417 	ldw	r8,16(sp)
 b00216c:	bdffffcc 	andi	r23,r23,65535
 b002170:	b884b03a 	or	r2,r23,r2
 b002174:	d8c00217 	ldw	r3,8(sp)
 b002178:	1200062e 	bgeu	r2,r8,b002194 <__divdf3+0x424>
 b00217c:	1585883a 	add	r2,r2,r22
 b002180:	813fffc4 	addi	r4,r16,-1
 b002184:	15810236 	bltu	r2,r22,b002590 <__divdf3+0x820>
 b002188:	1201012e 	bgeu	r2,r8,b002590 <__divdf3+0x820>
 b00218c:	843fff84 	addi	r16,r16,-2
 b002190:	1585883a 	add	r2,r2,r22
 b002194:	8822943a 	slli	r17,r17,16
 b002198:	d9800017 	ldw	r6,0(sp)
 b00219c:	1211c83a 	sub	r8,r2,r8
 b0021a0:	8c22b03a 	or	r17,r17,r16
 b0021a4:	373fffcc 	andi	fp,r6,65535
 b0021a8:	8abfffcc 	andi	r10,r17,65535
 b0021ac:	8820d43a 	srli	r16,r17,16
 b0021b0:	5009883a 	mov	r4,r10
 b0021b4:	e00b883a 	mov	r5,fp
 b0021b8:	302ed43a 	srli	r23,r6,16
 b0021bc:	d8c00215 	stw	r3,8(sp)
 b0021c0:	da000415 	stw	r8,16(sp)
 b0021c4:	da800115 	stw	r10,4(sp)
 b0021c8:	b003fb80 	call	b003fb8 <__mulsi3>
 b0021cc:	800b883a 	mov	r5,r16
 b0021d0:	e009883a 	mov	r4,fp
 b0021d4:	d8800515 	stw	r2,20(sp)
 b0021d8:	b003fb80 	call	b003fb8 <__mulsi3>
 b0021dc:	8009883a 	mov	r4,r16
 b0021e0:	b80b883a 	mov	r5,r23
 b0021e4:	d8800315 	stw	r2,12(sp)
 b0021e8:	b003fb80 	call	b003fb8 <__mulsi3>
 b0021ec:	da800117 	ldw	r10,4(sp)
 b0021f0:	b80b883a 	mov	r5,r23
 b0021f4:	1021883a 	mov	r16,r2
 b0021f8:	5009883a 	mov	r4,r10
 b0021fc:	b003fb80 	call	b003fb8 <__mulsi3>
 b002200:	d9c00517 	ldw	r7,20(sp)
 b002204:	da400317 	ldw	r9,12(sp)
 b002208:	d8c00217 	ldw	r3,8(sp)
 b00220c:	3808d43a 	srli	r4,r7,16
 b002210:	1245883a 	add	r2,r2,r9
 b002214:	da000417 	ldw	r8,16(sp)
 b002218:	2085883a 	add	r2,r4,r2
 b00221c:	1240022e 	bgeu	r2,r9,b002228 <__divdf3+0x4b8>
 b002220:	01000074 	movhi	r4,1
 b002224:	8121883a 	add	r16,r16,r4
 b002228:	1008d43a 	srli	r4,r2,16
 b00222c:	1004943a 	slli	r2,r2,16
 b002230:	39ffffcc 	andi	r7,r7,65535
 b002234:	2409883a 	add	r4,r4,r16
 b002238:	11c5883a 	add	r2,r2,r7
 b00223c:	4100bb36 	bltu	r8,r4,b00252c <__divdf3+0x7bc>
 b002240:	4100d726 	beq	r8,r4,b0025a0 <__divdf3+0x830>
 b002244:	4109c83a 	sub	r4,r8,r4
 b002248:	a8a1c83a 	sub	r16,r21,r2
 b00224c:	ac2b803a 	cmpltu	r21,r21,r16
 b002250:	256bc83a 	sub	r21,r4,r21
 b002254:	b540d926 	beq	r22,r21,b0025bc <__divdf3+0x84c>
 b002258:	a00b883a 	mov	r5,r20
 b00225c:	a809883a 	mov	r4,r21
 b002260:	d8c00215 	stw	r3,8(sp)
 b002264:	b003efc0 	call	b003efc <__udivsi3>
 b002268:	100b883a 	mov	r5,r2
 b00226c:	9009883a 	mov	r4,r18
 b002270:	d8800515 	stw	r2,20(sp)
 b002274:	b003fb80 	call	b003fb8 <__mulsi3>
 b002278:	a809883a 	mov	r4,r21
 b00227c:	a00b883a 	mov	r5,r20
 b002280:	d8800415 	stw	r2,16(sp)
 b002284:	b003f600 	call	b003f60 <__umodsi3>
 b002288:	1004943a 	slli	r2,r2,16
 b00228c:	8008d43a 	srli	r4,r16,16
 b002290:	da000417 	ldw	r8,16(sp)
 b002294:	d8c00217 	ldw	r3,8(sp)
 b002298:	2084b03a 	or	r2,r4,r2
 b00229c:	d9c00517 	ldw	r7,20(sp)
 b0022a0:	1200062e 	bgeu	r2,r8,b0022bc <__divdf3+0x54c>
 b0022a4:	1585883a 	add	r2,r2,r22
 b0022a8:	393fffc4 	addi	r4,r7,-1
 b0022ac:	1580c536 	bltu	r2,r22,b0025c4 <__divdf3+0x854>
 b0022b0:	1200c42e 	bgeu	r2,r8,b0025c4 <__divdf3+0x854>
 b0022b4:	39ffff84 	addi	r7,r7,-2
 b0022b8:	1585883a 	add	r2,r2,r22
 b0022bc:	122bc83a 	sub	r21,r2,r8
 b0022c0:	a00b883a 	mov	r5,r20
 b0022c4:	a809883a 	mov	r4,r21
 b0022c8:	d8c00215 	stw	r3,8(sp)
 b0022cc:	d9c00515 	stw	r7,20(sp)
 b0022d0:	b003efc0 	call	b003efc <__udivsi3>
 b0022d4:	9009883a 	mov	r4,r18
 b0022d8:	100b883a 	mov	r5,r2
 b0022dc:	d8800415 	stw	r2,16(sp)
 b0022e0:	b003fb80 	call	b003fb8 <__mulsi3>
 b0022e4:	a809883a 	mov	r4,r21
 b0022e8:	a00b883a 	mov	r5,r20
 b0022ec:	1025883a 	mov	r18,r2
 b0022f0:	b003f600 	call	b003f60 <__umodsi3>
 b0022f4:	1004943a 	slli	r2,r2,16
 b0022f8:	813fffcc 	andi	r4,r16,65535
 b0022fc:	d8c00217 	ldw	r3,8(sp)
 b002300:	20a0b03a 	or	r16,r4,r2
 b002304:	d9c00517 	ldw	r7,20(sp)
 b002308:	da000417 	ldw	r8,16(sp)
 b00230c:	8480062e 	bgeu	r16,r18,b002328 <__divdf3+0x5b8>
 b002310:	85a1883a 	add	r16,r16,r22
 b002314:	40bfffc4 	addi	r2,r8,-1
 b002318:	8580ac36 	bltu	r16,r22,b0025cc <__divdf3+0x85c>
 b00231c:	8480ab2e 	bgeu	r16,r18,b0025cc <__divdf3+0x85c>
 b002320:	423fff84 	addi	r8,r8,-2
 b002324:	85a1883a 	add	r16,r16,r22
 b002328:	3804943a 	slli	r2,r7,16
 b00232c:	84a1c83a 	sub	r16,r16,r18
 b002330:	e009883a 	mov	r4,fp
 b002334:	1228b03a 	or	r20,r2,r8
 b002338:	a1ffffcc 	andi	r7,r20,65535
 b00233c:	a024d43a 	srli	r18,r20,16
 b002340:	380b883a 	mov	r5,r7
 b002344:	d8c00215 	stw	r3,8(sp)
 b002348:	d9c00515 	stw	r7,20(sp)
 b00234c:	b003fb80 	call	b003fb8 <__mulsi3>
 b002350:	900b883a 	mov	r5,r18
 b002354:	e009883a 	mov	r4,fp
 b002358:	102b883a 	mov	r21,r2
 b00235c:	b003fb80 	call	b003fb8 <__mulsi3>
 b002360:	900b883a 	mov	r5,r18
 b002364:	b809883a 	mov	r4,r23
 b002368:	1039883a 	mov	fp,r2
 b00236c:	b003fb80 	call	b003fb8 <__mulsi3>
 b002370:	d9c00517 	ldw	r7,20(sp)
 b002374:	b80b883a 	mov	r5,r23
 b002378:	1025883a 	mov	r18,r2
 b00237c:	3809883a 	mov	r4,r7
 b002380:	b003fb80 	call	b003fb8 <__mulsi3>
 b002384:	a808d43a 	srli	r4,r21,16
 b002388:	1705883a 	add	r2,r2,fp
 b00238c:	d8c00217 	ldw	r3,8(sp)
 b002390:	2085883a 	add	r2,r4,r2
 b002394:	1700022e 	bgeu	r2,fp,b0023a0 <__divdf3+0x630>
 b002398:	01000074 	movhi	r4,1
 b00239c:	9125883a 	add	r18,r18,r4
 b0023a0:	1008d43a 	srli	r4,r2,16
 b0023a4:	1004943a 	slli	r2,r2,16
 b0023a8:	ad7fffcc 	andi	r21,r21,65535
 b0023ac:	2489883a 	add	r4,r4,r18
 b0023b0:	1545883a 	add	r2,r2,r21
 b0023b4:	81003836 	bltu	r16,r4,b002498 <__divdf3+0x728>
 b0023b8:	81003626 	beq	r16,r4,b002494 <__divdf3+0x724>
 b0023bc:	a5000054 	ori	r20,r20,1
 b0023c0:	1880ffc4 	addi	r2,r3,1023
 b0023c4:	00bf2e0e 	bge	zero,r2,b002080 <__alt_mem_flash+0xff001080>
 b0023c8:	a10001cc 	andi	r4,r20,7
 b0023cc:	20000726 	beq	r4,zero,b0023ec <__divdf3+0x67c>
 b0023d0:	a10003cc 	andi	r4,r20,15
 b0023d4:	01400104 	movi	r5,4
 b0023d8:	21400426 	beq	r4,r5,b0023ec <__divdf3+0x67c>
 b0023dc:	a149883a 	add	r4,r20,r5
 b0023e0:	2529803a 	cmpltu	r20,r4,r20
 b0023e4:	8d23883a 	add	r17,r17,r20
 b0023e8:	2029883a 	mov	r20,r4
 b0023ec:	8900402c 	andhi	r4,r17,256
 b0023f0:	20000426 	beq	r4,zero,b002404 <__divdf3+0x694>
 b0023f4:	18810004 	addi	r2,r3,1024
 b0023f8:	00ffc034 	movhi	r3,65280
 b0023fc:	18ffffc4 	addi	r3,r3,-1
 b002400:	88e2703a 	and	r17,r17,r3
 b002404:	00c1ff84 	movi	r3,2046
 b002408:	18beb416 	blt	r3,r2,b001edc <__alt_mem_flash+0xff000edc>
 b00240c:	a028d0fa 	srli	r20,r20,3
 b002410:	882a977a 	slli	r21,r17,29
 b002414:	8820927a 	slli	r16,r17,9
 b002418:	1081ffcc 	andi	r2,r2,2047
 b00241c:	ad2ab03a 	or	r21,r21,r20
 b002420:	8020d33a 	srli	r16,r16,12
 b002424:	9900004c 	andi	r4,r19,1
 b002428:	003eb006 	br	b001eec <__alt_mem_flash+0xff000eec>
 b00242c:	8080022c 	andhi	r2,r16,8
 b002430:	10001226 	beq	r2,zero,b00247c <__divdf3+0x70c>
 b002434:	8880022c 	andhi	r2,r17,8
 b002438:	1000101e 	bne	r2,zero,b00247c <__divdf3+0x70c>
 b00243c:	00800434 	movhi	r2,16
 b002440:	8c000234 	orhi	r16,r17,8
 b002444:	10bfffc4 	addi	r2,r2,-1
 b002448:	b809883a 	mov	r4,r23
 b00244c:	80a0703a 	and	r16,r16,r2
 b002450:	a02b883a 	mov	r21,r20
 b002454:	003f0806 	br	b002078 <__alt_mem_flash+0xff001078>
 b002458:	008000c4 	movi	r2,3
 b00245c:	3880b126 	beq	r7,r2,b002724 <__divdf3+0x9b4>
 b002460:	00800044 	movi	r2,1
 b002464:	38805b1e 	bne	r7,r2,b0025d4 <__divdf3+0x864>
 b002468:	e009883a 	mov	r4,fp
 b00246c:	0005883a 	mov	r2,zero
 b002470:	0021883a 	mov	r16,zero
 b002474:	002b883a 	mov	r21,zero
 b002478:	003e9c06 	br	b001eec <__alt_mem_flash+0xff000eec>
 b00247c:	00800434 	movhi	r2,16
 b002480:	84000234 	orhi	r16,r16,8
 b002484:	10bfffc4 	addi	r2,r2,-1
 b002488:	b009883a 	mov	r4,r22
 b00248c:	80a0703a 	and	r16,r16,r2
 b002490:	003ef906 	br	b002078 <__alt_mem_flash+0xff001078>
 b002494:	103fca26 	beq	r2,zero,b0023c0 <__alt_mem_flash+0xff0013c0>
 b002498:	b421883a 	add	r16,r22,r16
 b00249c:	a17fffc4 	addi	r5,r20,-1
 b0024a0:	8580422e 	bgeu	r16,r22,b0025ac <__divdf3+0x83c>
 b0024a4:	2829883a 	mov	r20,r5
 b0024a8:	813fc41e 	bne	r16,r4,b0023bc <__alt_mem_flash+0xff0013bc>
 b0024ac:	d9800017 	ldw	r6,0(sp)
 b0024b0:	30bfc21e 	bne	r6,r2,b0023bc <__alt_mem_flash+0xff0013bc>
 b0024b4:	003fc206 	br	b0023c0 <__alt_mem_flash+0xff0013c0>
 b0024b8:	143ff604 	addi	r16,r2,-40
 b0024bc:	8c20983a 	sll	r16,r17,r16
 b0024c0:	002b883a 	mov	r21,zero
 b0024c4:	003eb406 	br	b001f98 <__alt_mem_flash+0xff000f98>
 b0024c8:	d9800215 	stw	r6,8(sp)
 b0024cc:	d9c00515 	stw	r7,20(sp)
 b0024d0:	da000415 	stw	r8,16(sp)
 b0024d4:	b003da00 	call	b003da0 <__clzsi2>
 b0024d8:	10800804 	addi	r2,r2,32
 b0024dc:	da000417 	ldw	r8,16(sp)
 b0024e0:	d9c00517 	ldw	r7,20(sp)
 b0024e4:	d9800217 	ldw	r6,8(sp)
 b0024e8:	003ea106 	br	b001f70 <__alt_mem_flash+0xff000f70>
 b0024ec:	147ff604 	addi	r17,r2,-40
 b0024f0:	3462983a 	sll	r17,r6,r17
 b0024f4:	0029883a 	mov	r20,zero
 b0024f8:	003ec906 	br	b002020 <__alt_mem_flash+0xff001020>
 b0024fc:	3009883a 	mov	r4,r6
 b002500:	d9400115 	stw	r5,4(sp)
 b002504:	d9800215 	stw	r6,8(sp)
 b002508:	da000415 	stw	r8,16(sp)
 b00250c:	da400315 	stw	r9,12(sp)
 b002510:	b003da00 	call	b003da0 <__clzsi2>
 b002514:	10800804 	addi	r2,r2,32
 b002518:	da400317 	ldw	r9,12(sp)
 b00251c:	da000417 	ldw	r8,16(sp)
 b002520:	d9800217 	ldw	r6,8(sp)
 b002524:	d9400117 	ldw	r5,4(sp)
 b002528:	003eb306 	br	b001ff8 <__alt_mem_flash+0xff000ff8>
 b00252c:	d9800017 	ldw	r6,0(sp)
 b002530:	a9ab883a 	add	r21,r21,r6
 b002534:	a98b803a 	cmpltu	r5,r21,r6
 b002538:	2d8b883a 	add	r5,r5,r22
 b00253c:	2a11883a 	add	r8,r5,r8
 b002540:	897fffc4 	addi	r5,r17,-1
 b002544:	b2000c2e 	bgeu	r22,r8,b002578 <__divdf3+0x808>
 b002548:	41003f36 	bltu	r8,r4,b002648 <__divdf3+0x8d8>
 b00254c:	22006c26 	beq	r4,r8,b002700 <__divdf3+0x990>
 b002550:	4109c83a 	sub	r4,r8,r4
 b002554:	2823883a 	mov	r17,r5
 b002558:	003f3b06 	br	b002248 <__alt_mem_flash+0xff001248>
 b00255c:	ad3ed336 	bltu	r21,r20,b0020ac <__alt_mem_flash+0xff0010ac>
 b002560:	a804d07a 	srli	r2,r21,1
 b002564:	802e97fa 	slli	r23,r16,31
 b002568:	a82a97fa 	slli	r21,r21,31
 b00256c:	8020d07a 	srli	r16,r16,1
 b002570:	b8aeb03a 	or	r23,r23,r2
 b002574:	003ed006 	br	b0020b8 <__alt_mem_flash+0xff0010b8>
 b002578:	b23ff51e 	bne	r22,r8,b002550 <__alt_mem_flash+0xff001550>
 b00257c:	d9800017 	ldw	r6,0(sp)
 b002580:	a9bff12e 	bgeu	r21,r6,b002548 <__alt_mem_flash+0xff001548>
 b002584:	b109c83a 	sub	r4,r22,r4
 b002588:	2823883a 	mov	r17,r5
 b00258c:	003f2e06 	br	b002248 <__alt_mem_flash+0xff001248>
 b002590:	2021883a 	mov	r16,r4
 b002594:	003eff06 	br	b002194 <__alt_mem_flash+0xff001194>
 b002598:	2023883a 	mov	r17,r4
 b00259c:	003ee406 	br	b002130 <__alt_mem_flash+0xff001130>
 b0025a0:	a8bfe236 	bltu	r21,r2,b00252c <__alt_mem_flash+0xff00152c>
 b0025a4:	0009883a 	mov	r4,zero
 b0025a8:	003f2706 	br	b002248 <__alt_mem_flash+0xff001248>
 b0025ac:	81002d36 	bltu	r16,r4,b002664 <__divdf3+0x8f4>
 b0025b0:	24005626 	beq	r4,r16,b00270c <__divdf3+0x99c>
 b0025b4:	2829883a 	mov	r20,r5
 b0025b8:	003f8006 	br	b0023bc <__alt_mem_flash+0xff0013bc>
 b0025bc:	053fffc4 	movi	r20,-1
 b0025c0:	003f7f06 	br	b0023c0 <__alt_mem_flash+0xff0013c0>
 b0025c4:	200f883a 	mov	r7,r4
 b0025c8:	003f3c06 	br	b0022bc <__alt_mem_flash+0xff0012bc>
 b0025cc:	1011883a 	mov	r8,r2
 b0025d0:	003f5506 	br	b002328 <__alt_mem_flash+0xff001328>
 b0025d4:	e027883a 	mov	r19,fp
 b0025d8:	003f7906 	br	b0023c0 <__alt_mem_flash+0xff0013c0>
 b0025dc:	010007c4 	movi	r4,31
 b0025e0:	20c02816 	blt	r4,r3,b002684 <__divdf3+0x914>
 b0025e4:	00800804 	movi	r2,32
 b0025e8:	10c5c83a 	sub	r2,r2,r3
 b0025ec:	888a983a 	sll	r5,r17,r2
 b0025f0:	a0c8d83a 	srl	r4,r20,r3
 b0025f4:	a084983a 	sll	r2,r20,r2
 b0025f8:	88e2d83a 	srl	r17,r17,r3
 b0025fc:	2906b03a 	or	r3,r5,r4
 b002600:	1004c03a 	cmpne	r2,r2,zero
 b002604:	1886b03a 	or	r3,r3,r2
 b002608:	188001cc 	andi	r2,r3,7
 b00260c:	10000726 	beq	r2,zero,b00262c <__divdf3+0x8bc>
 b002610:	188003cc 	andi	r2,r3,15
 b002614:	01000104 	movi	r4,4
 b002618:	11000426 	beq	r2,r4,b00262c <__divdf3+0x8bc>
 b00261c:	1805883a 	mov	r2,r3
 b002620:	10c00104 	addi	r3,r2,4
 b002624:	1885803a 	cmpltu	r2,r3,r2
 b002628:	88a3883a 	add	r17,r17,r2
 b00262c:	8880202c 	andhi	r2,r17,128
 b002630:	10002926 	beq	r2,zero,b0026d8 <__divdf3+0x968>
 b002634:	9900004c 	andi	r4,r19,1
 b002638:	00800044 	movi	r2,1
 b00263c:	0021883a 	mov	r16,zero
 b002640:	002b883a 	mov	r21,zero
 b002644:	003e2906 	br	b001eec <__alt_mem_flash+0xff000eec>
 b002648:	d9800017 	ldw	r6,0(sp)
 b00264c:	8c7fff84 	addi	r17,r17,-2
 b002650:	a9ab883a 	add	r21,r21,r6
 b002654:	a98b803a 	cmpltu	r5,r21,r6
 b002658:	2d8b883a 	add	r5,r5,r22
 b00265c:	2a11883a 	add	r8,r5,r8
 b002660:	003ef806 	br	b002244 <__alt_mem_flash+0xff001244>
 b002664:	d9800017 	ldw	r6,0(sp)
 b002668:	318f883a 	add	r7,r6,r6
 b00266c:	398b803a 	cmpltu	r5,r7,r6
 b002670:	2d8d883a 	add	r6,r5,r22
 b002674:	81a1883a 	add	r16,r16,r6
 b002678:	a17fff84 	addi	r5,r20,-2
 b00267c:	d9c00015 	stw	r7,0(sp)
 b002680:	003f8806 	br	b0024a4 <__alt_mem_flash+0xff0014a4>
 b002684:	013ff844 	movi	r4,-31
 b002688:	2085c83a 	sub	r2,r4,r2
 b00268c:	8888d83a 	srl	r4,r17,r2
 b002690:	00800804 	movi	r2,32
 b002694:	18802126 	beq	r3,r2,b00271c <__divdf3+0x9ac>
 b002698:	04001004 	movi	r16,64
 b00269c:	80c7c83a 	sub	r3,r16,r3
 b0026a0:	88e0983a 	sll	r16,r17,r3
 b0026a4:	8504b03a 	or	r2,r16,r20
 b0026a8:	1004c03a 	cmpne	r2,r2,zero
 b0026ac:	2084b03a 	or	r2,r4,r2
 b0026b0:	144001cc 	andi	r17,r2,7
 b0026b4:	88000d1e 	bne	r17,zero,b0026ec <__divdf3+0x97c>
 b0026b8:	0021883a 	mov	r16,zero
 b0026bc:	102ad0fa 	srli	r21,r2,3
 b0026c0:	9900004c 	andi	r4,r19,1
 b0026c4:	0005883a 	mov	r2,zero
 b0026c8:	ac6ab03a 	or	r21,r21,r17
 b0026cc:	003e0706 	br	b001eec <__alt_mem_flash+0xff000eec>
 b0026d0:	1007883a 	mov	r3,r2
 b0026d4:	0023883a 	mov	r17,zero
 b0026d8:	8820927a 	slli	r16,r17,9
 b0026dc:	1805883a 	mov	r2,r3
 b0026e0:	8822977a 	slli	r17,r17,29
 b0026e4:	8020d33a 	srli	r16,r16,12
 b0026e8:	003ff406 	br	b0026bc <__alt_mem_flash+0xff0016bc>
 b0026ec:	10c003cc 	andi	r3,r2,15
 b0026f0:	01000104 	movi	r4,4
 b0026f4:	193ff626 	beq	r3,r4,b0026d0 <__alt_mem_flash+0xff0016d0>
 b0026f8:	0023883a 	mov	r17,zero
 b0026fc:	003fc806 	br	b002620 <__alt_mem_flash+0xff001620>
 b002700:	a8bfd136 	bltu	r21,r2,b002648 <__alt_mem_flash+0xff001648>
 b002704:	2823883a 	mov	r17,r5
 b002708:	003fa606 	br	b0025a4 <__alt_mem_flash+0xff0015a4>
 b00270c:	d9800017 	ldw	r6,0(sp)
 b002710:	30bfd436 	bltu	r6,r2,b002664 <__alt_mem_flash+0xff001664>
 b002714:	2829883a 	mov	r20,r5
 b002718:	003f6406 	br	b0024ac <__alt_mem_flash+0xff0014ac>
 b00271c:	0021883a 	mov	r16,zero
 b002720:	003fe006 	br	b0026a4 <__alt_mem_flash+0xff0016a4>
 b002724:	00800434 	movhi	r2,16
 b002728:	8c000234 	orhi	r16,r17,8
 b00272c:	10bfffc4 	addi	r2,r2,-1
 b002730:	e009883a 	mov	r4,fp
 b002734:	80a0703a 	and	r16,r16,r2
 b002738:	a02b883a 	mov	r21,r20
 b00273c:	003e4e06 	br	b002078 <__alt_mem_flash+0xff001078>

0b002740 <__eqdf2>:
 b002740:	2804d53a 	srli	r2,r5,20
 b002744:	3806d53a 	srli	r3,r7,20
 b002748:	02000434 	movhi	r8,16
 b00274c:	423fffc4 	addi	r8,r8,-1
 b002750:	1081ffcc 	andi	r2,r2,2047
 b002754:	0281ffc4 	movi	r10,2047
 b002758:	2a12703a 	and	r9,r5,r8
 b00275c:	18c1ffcc 	andi	r3,r3,2047
 b002760:	3a10703a 	and	r8,r7,r8
 b002764:	280ad7fa 	srli	r5,r5,31
 b002768:	380ed7fa 	srli	r7,r7,31
 b00276c:	12801026 	beq	r2,r10,b0027b0 <__eqdf2+0x70>
 b002770:	0281ffc4 	movi	r10,2047
 b002774:	1a800a26 	beq	r3,r10,b0027a0 <__eqdf2+0x60>
 b002778:	10c00226 	beq	r2,r3,b002784 <__eqdf2+0x44>
 b00277c:	00800044 	movi	r2,1
 b002780:	f800283a 	ret
 b002784:	4a3ffd1e 	bne	r9,r8,b00277c <__alt_mem_flash+0xff00177c>
 b002788:	21bffc1e 	bne	r4,r6,b00277c <__alt_mem_flash+0xff00177c>
 b00278c:	29c00c26 	beq	r5,r7,b0027c0 <__eqdf2+0x80>
 b002790:	103ffa1e 	bne	r2,zero,b00277c <__alt_mem_flash+0xff00177c>
 b002794:	2244b03a 	or	r2,r4,r9
 b002798:	1004c03a 	cmpne	r2,r2,zero
 b00279c:	f800283a 	ret
 b0027a0:	3214b03a 	or	r10,r6,r8
 b0027a4:	503ff426 	beq	r10,zero,b002778 <__alt_mem_flash+0xff001778>
 b0027a8:	00800044 	movi	r2,1
 b0027ac:	f800283a 	ret
 b0027b0:	2254b03a 	or	r10,r4,r9
 b0027b4:	503fee26 	beq	r10,zero,b002770 <__alt_mem_flash+0xff001770>
 b0027b8:	00800044 	movi	r2,1
 b0027bc:	f800283a 	ret
 b0027c0:	0005883a 	mov	r2,zero
 b0027c4:	f800283a 	ret

0b0027c8 <__gedf2>:
 b0027c8:	2804d53a 	srli	r2,r5,20
 b0027cc:	3806d53a 	srli	r3,r7,20
 b0027d0:	02000434 	movhi	r8,16
 b0027d4:	423fffc4 	addi	r8,r8,-1
 b0027d8:	1081ffcc 	andi	r2,r2,2047
 b0027dc:	0241ffc4 	movi	r9,2047
 b0027e0:	2a14703a 	and	r10,r5,r8
 b0027e4:	18c1ffcc 	andi	r3,r3,2047
 b0027e8:	3a10703a 	and	r8,r7,r8
 b0027ec:	280ad7fa 	srli	r5,r5,31
 b0027f0:	380ed7fa 	srli	r7,r7,31
 b0027f4:	12401d26 	beq	r2,r9,b00286c <__gedf2+0xa4>
 b0027f8:	0241ffc4 	movi	r9,2047
 b0027fc:	1a401226 	beq	r3,r9,b002848 <__gedf2+0x80>
 b002800:	1000081e 	bne	r2,zero,b002824 <__gedf2+0x5c>
 b002804:	2296b03a 	or	r11,r4,r10
 b002808:	5813003a 	cmpeq	r9,r11,zero
 b00280c:	1800091e 	bne	r3,zero,b002834 <__gedf2+0x6c>
 b002810:	3218b03a 	or	r12,r6,r8
 b002814:	6000071e 	bne	r12,zero,b002834 <__gedf2+0x6c>
 b002818:	0005883a 	mov	r2,zero
 b00281c:	5800101e 	bne	r11,zero,b002860 <__gedf2+0x98>
 b002820:	f800283a 	ret
 b002824:	18000c1e 	bne	r3,zero,b002858 <__gedf2+0x90>
 b002828:	3212b03a 	or	r9,r6,r8
 b00282c:	48000c26 	beq	r9,zero,b002860 <__gedf2+0x98>
 b002830:	0013883a 	mov	r9,zero
 b002834:	39c03fcc 	andi	r7,r7,255
 b002838:	48000826 	beq	r9,zero,b00285c <__gedf2+0x94>
 b00283c:	38000926 	beq	r7,zero,b002864 <__gedf2+0x9c>
 b002840:	00800044 	movi	r2,1
 b002844:	f800283a 	ret
 b002848:	3212b03a 	or	r9,r6,r8
 b00284c:	483fec26 	beq	r9,zero,b002800 <__alt_mem_flash+0xff001800>
 b002850:	00bfff84 	movi	r2,-2
 b002854:	f800283a 	ret
 b002858:	39c03fcc 	andi	r7,r7,255
 b00285c:	29c00626 	beq	r5,r7,b002878 <__gedf2+0xb0>
 b002860:	283ff726 	beq	r5,zero,b002840 <__alt_mem_flash+0xff001840>
 b002864:	00bfffc4 	movi	r2,-1
 b002868:	f800283a 	ret
 b00286c:	2292b03a 	or	r9,r4,r10
 b002870:	483fe126 	beq	r9,zero,b0027f8 <__alt_mem_flash+0xff0017f8>
 b002874:	003ff606 	br	b002850 <__alt_mem_flash+0xff001850>
 b002878:	18bff916 	blt	r3,r2,b002860 <__alt_mem_flash+0xff001860>
 b00287c:	10c00316 	blt	r2,r3,b00288c <__gedf2+0xc4>
 b002880:	42bff736 	bltu	r8,r10,b002860 <__alt_mem_flash+0xff001860>
 b002884:	52000326 	beq	r10,r8,b002894 <__gedf2+0xcc>
 b002888:	5200042e 	bgeu	r10,r8,b00289c <__gedf2+0xd4>
 b00288c:	283fec1e 	bne	r5,zero,b002840 <__alt_mem_flash+0xff001840>
 b002890:	003ff406 	br	b002864 <__alt_mem_flash+0xff001864>
 b002894:	313ff236 	bltu	r6,r4,b002860 <__alt_mem_flash+0xff001860>
 b002898:	21bffc36 	bltu	r4,r6,b00288c <__alt_mem_flash+0xff00188c>
 b00289c:	0005883a 	mov	r2,zero
 b0028a0:	f800283a 	ret

0b0028a4 <__muldf3>:
 b0028a4:	deffee04 	addi	sp,sp,-72
 b0028a8:	dd000c15 	stw	r20,48(sp)
 b0028ac:	2828d53a 	srli	r20,r5,20
 b0028b0:	ddc00f15 	stw	r23,60(sp)
 b0028b4:	282ed7fa 	srli	r23,r5,31
 b0028b8:	dc000815 	stw	r16,32(sp)
 b0028bc:	04000434 	movhi	r16,16
 b0028c0:	dcc00b15 	stw	r19,44(sp)
 b0028c4:	843fffc4 	addi	r16,r16,-1
 b0028c8:	dfc01115 	stw	ra,68(sp)
 b0028cc:	df001015 	stw	fp,64(sp)
 b0028d0:	dd800e15 	stw	r22,56(sp)
 b0028d4:	dd400d15 	stw	r21,52(sp)
 b0028d8:	dc800a15 	stw	r18,40(sp)
 b0028dc:	dc400915 	stw	r17,36(sp)
 b0028e0:	a501ffcc 	andi	r20,r20,2047
 b0028e4:	2c20703a 	and	r16,r5,r16
 b0028e8:	b827883a 	mov	r19,r23
 b0028ec:	ba403fcc 	andi	r9,r23,255
 b0028f0:	a0006026 	beq	r20,zero,b002a74 <__muldf3+0x1d0>
 b0028f4:	0081ffc4 	movi	r2,2047
 b0028f8:	202d883a 	mov	r22,r4
 b0028fc:	a0803626 	beq	r20,r2,b0029d8 <__muldf3+0x134>
 b002900:	84000434 	orhi	r16,r16,16
 b002904:	200ad77a 	srli	r5,r4,29
 b002908:	800490fa 	slli	r2,r16,3
 b00290c:	202c90fa 	slli	r22,r4,3
 b002910:	a53f0044 	addi	r20,r20,-1023
 b002914:	28a0b03a 	or	r16,r5,r2
 b002918:	002b883a 	mov	r21,zero
 b00291c:	000b883a 	mov	r5,zero
 b002920:	3804d53a 	srli	r2,r7,20
 b002924:	3838d7fa 	srli	fp,r7,31
 b002928:	04400434 	movhi	r17,16
 b00292c:	8c7fffc4 	addi	r17,r17,-1
 b002930:	1081ffcc 	andi	r2,r2,2047
 b002934:	3025883a 	mov	r18,r6
 b002938:	3c62703a 	and	r17,r7,r17
 b00293c:	e2803fcc 	andi	r10,fp,255
 b002940:	10006d26 	beq	r2,zero,b002af8 <__muldf3+0x254>
 b002944:	00c1ffc4 	movi	r3,2047
 b002948:	10c06526 	beq	r2,r3,b002ae0 <__muldf3+0x23c>
 b00294c:	8c400434 	orhi	r17,r17,16
 b002950:	300ed77a 	srli	r7,r6,29
 b002954:	880690fa 	slli	r3,r17,3
 b002958:	302490fa 	slli	r18,r6,3
 b00295c:	10bf0044 	addi	r2,r2,-1023
 b002960:	38e2b03a 	or	r17,r7,r3
 b002964:	000f883a 	mov	r7,zero
 b002968:	a087883a 	add	r3,r20,r2
 b00296c:	010003c4 	movi	r4,15
 b002970:	3d44b03a 	or	r2,r7,r21
 b002974:	e5ccf03a 	xor	r6,fp,r23
 b002978:	1a000044 	addi	r8,r3,1
 b00297c:	20809b36 	bltu	r4,r2,b002bec <__muldf3+0x348>
 b002980:	100490ba 	slli	r2,r2,2
 b002984:	0102c034 	movhi	r4,2816
 b002988:	210a6604 	addi	r4,r4,10648
 b00298c:	1105883a 	add	r2,r2,r4
 b002990:	10800017 	ldw	r2,0(r2)
 b002994:	1000683a 	jmp	r2
 b002998:	0b002bec 	andhi	r12,at,175
 b00299c:	0b0029f8 	rdprs	r12,at,167
 b0029a0:	0b0029f8 	rdprs	r12,at,167
 b0029a4:	0b0029f4 	orhi	r12,at,167
 b0029a8:	0b002bc8 	cmpgei	r12,at,175
 b0029ac:	0b002bc8 	cmpgei	r12,at,175
 b0029b0:	0b002bb0 	cmpltui	r12,at,174
 b0029b4:	0b0029f4 	orhi	r12,at,167
 b0029b8:	0b002bc8 	cmpgei	r12,at,175
 b0029bc:	0b002bb0 	cmpltui	r12,at,174
 b0029c0:	0b002bc8 	cmpgei	r12,at,175
 b0029c4:	0b0029f4 	orhi	r12,at,167
 b0029c8:	0b002bd8 	cmpnei	r12,at,175
 b0029cc:	0b002bd8 	cmpnei	r12,at,175
 b0029d0:	0b002bd8 	cmpnei	r12,at,175
 b0029d4:	0b002f38 	rdprs	r12,at,188
 b0029d8:	2404b03a 	or	r2,r4,r16
 b0029dc:	1000711e 	bne	r2,zero,b002ba4 <__muldf3+0x300>
 b0029e0:	05400204 	movi	r21,8
 b0029e4:	0021883a 	mov	r16,zero
 b0029e8:	002d883a 	mov	r22,zero
 b0029ec:	01400084 	movi	r5,2
 b0029f0:	003fcb06 	br	b002920 <__alt_mem_flash+0xff001920>
 b0029f4:	500d883a 	mov	r6,r10
 b0029f8:	00800084 	movi	r2,2
 b0029fc:	38805926 	beq	r7,r2,b002b64 <__muldf3+0x2c0>
 b002a00:	008000c4 	movi	r2,3
 b002a04:	3881bb26 	beq	r7,r2,b0030f4 <__muldf3+0x850>
 b002a08:	00800044 	movi	r2,1
 b002a0c:	3881961e 	bne	r7,r2,b003068 <__muldf3+0x7c4>
 b002a10:	3027883a 	mov	r19,r6
 b002a14:	0005883a 	mov	r2,zero
 b002a18:	0021883a 	mov	r16,zero
 b002a1c:	002d883a 	mov	r22,zero
 b002a20:	1004953a 	slli	r2,r2,20
 b002a24:	98c03fcc 	andi	r3,r19,255
 b002a28:	04400434 	movhi	r17,16
 b002a2c:	8c7fffc4 	addi	r17,r17,-1
 b002a30:	180697fa 	slli	r3,r3,31
 b002a34:	8460703a 	and	r16,r16,r17
 b002a38:	80a0b03a 	or	r16,r16,r2
 b002a3c:	80c6b03a 	or	r3,r16,r3
 b002a40:	b005883a 	mov	r2,r22
 b002a44:	dfc01117 	ldw	ra,68(sp)
 b002a48:	df001017 	ldw	fp,64(sp)
 b002a4c:	ddc00f17 	ldw	r23,60(sp)
 b002a50:	dd800e17 	ldw	r22,56(sp)
 b002a54:	dd400d17 	ldw	r21,52(sp)
 b002a58:	dd000c17 	ldw	r20,48(sp)
 b002a5c:	dcc00b17 	ldw	r19,44(sp)
 b002a60:	dc800a17 	ldw	r18,40(sp)
 b002a64:	dc400917 	ldw	r17,36(sp)
 b002a68:	dc000817 	ldw	r16,32(sp)
 b002a6c:	dec01204 	addi	sp,sp,72
 b002a70:	f800283a 	ret
 b002a74:	2404b03a 	or	r2,r4,r16
 b002a78:	202b883a 	mov	r21,r4
 b002a7c:	10004426 	beq	r2,zero,b002b90 <__muldf3+0x2ec>
 b002a80:	80015126 	beq	r16,zero,b002fc8 <__muldf3+0x724>
 b002a84:	8009883a 	mov	r4,r16
 b002a88:	d9800715 	stw	r6,28(sp)
 b002a8c:	d9c00215 	stw	r7,8(sp)
 b002a90:	da400415 	stw	r9,16(sp)
 b002a94:	b003da00 	call	b003da0 <__clzsi2>
 b002a98:	d9800717 	ldw	r6,28(sp)
 b002a9c:	d9c00217 	ldw	r7,8(sp)
 b002aa0:	da400417 	ldw	r9,16(sp)
 b002aa4:	113ffd44 	addi	r4,r2,-11
 b002aa8:	00c00704 	movi	r3,28
 b002aac:	19014216 	blt	r3,r4,b002fb8 <__muldf3+0x714>
 b002ab0:	00c00744 	movi	r3,29
 b002ab4:	15bffe04 	addi	r22,r2,-8
 b002ab8:	1907c83a 	sub	r3,r3,r4
 b002abc:	85a0983a 	sll	r16,r16,r22
 b002ac0:	a8c6d83a 	srl	r3,r21,r3
 b002ac4:	adac983a 	sll	r22,r21,r22
 b002ac8:	1c20b03a 	or	r16,r3,r16
 b002acc:	1080fcc4 	addi	r2,r2,1011
 b002ad0:	00a9c83a 	sub	r20,zero,r2
 b002ad4:	002b883a 	mov	r21,zero
 b002ad8:	000b883a 	mov	r5,zero
 b002adc:	003f9006 	br	b002920 <__alt_mem_flash+0xff001920>
 b002ae0:	3446b03a 	or	r3,r6,r17
 b002ae4:	1800281e 	bne	r3,zero,b002b88 <__muldf3+0x2e4>
 b002ae8:	0023883a 	mov	r17,zero
 b002aec:	0025883a 	mov	r18,zero
 b002af0:	01c00084 	movi	r7,2
 b002af4:	003f9c06 	br	b002968 <__alt_mem_flash+0xff001968>
 b002af8:	3446b03a 	or	r3,r6,r17
 b002afc:	18001e26 	beq	r3,zero,b002b78 <__muldf3+0x2d4>
 b002b00:	88012126 	beq	r17,zero,b002f88 <__muldf3+0x6e4>
 b002b04:	8809883a 	mov	r4,r17
 b002b08:	d9400215 	stw	r5,8(sp)
 b002b0c:	d9800715 	stw	r6,28(sp)
 b002b10:	da400415 	stw	r9,16(sp)
 b002b14:	da800315 	stw	r10,12(sp)
 b002b18:	b003da00 	call	b003da0 <__clzsi2>
 b002b1c:	d9400217 	ldw	r5,8(sp)
 b002b20:	d9800717 	ldw	r6,28(sp)
 b002b24:	da400417 	ldw	r9,16(sp)
 b002b28:	da800317 	ldw	r10,12(sp)
 b002b2c:	113ffd44 	addi	r4,r2,-11
 b002b30:	00c00704 	movi	r3,28
 b002b34:	19011016 	blt	r3,r4,b002f78 <__muldf3+0x6d4>
 b002b38:	00c00744 	movi	r3,29
 b002b3c:	14bffe04 	addi	r18,r2,-8
 b002b40:	1907c83a 	sub	r3,r3,r4
 b002b44:	8ca2983a 	sll	r17,r17,r18
 b002b48:	30c6d83a 	srl	r3,r6,r3
 b002b4c:	34a4983a 	sll	r18,r6,r18
 b002b50:	1c62b03a 	or	r17,r3,r17
 b002b54:	1080fcc4 	addi	r2,r2,1011
 b002b58:	0085c83a 	sub	r2,zero,r2
 b002b5c:	000f883a 	mov	r7,zero
 b002b60:	003f8106 	br	b002968 <__alt_mem_flash+0xff001968>
 b002b64:	3027883a 	mov	r19,r6
 b002b68:	0081ffc4 	movi	r2,2047
 b002b6c:	0021883a 	mov	r16,zero
 b002b70:	002d883a 	mov	r22,zero
 b002b74:	003faa06 	br	b002a20 <__alt_mem_flash+0xff001a20>
 b002b78:	0023883a 	mov	r17,zero
 b002b7c:	0025883a 	mov	r18,zero
 b002b80:	01c00044 	movi	r7,1
 b002b84:	003f7806 	br	b002968 <__alt_mem_flash+0xff001968>
 b002b88:	01c000c4 	movi	r7,3
 b002b8c:	003f7606 	br	b002968 <__alt_mem_flash+0xff001968>
 b002b90:	05400104 	movi	r21,4
 b002b94:	0021883a 	mov	r16,zero
 b002b98:	002d883a 	mov	r22,zero
 b002b9c:	01400044 	movi	r5,1
 b002ba0:	003f5f06 	br	b002920 <__alt_mem_flash+0xff001920>
 b002ba4:	05400304 	movi	r21,12
 b002ba8:	014000c4 	movi	r5,3
 b002bac:	003f5c06 	br	b002920 <__alt_mem_flash+0xff001920>
 b002bb0:	04000434 	movhi	r16,16
 b002bb4:	0027883a 	mov	r19,zero
 b002bb8:	843fffc4 	addi	r16,r16,-1
 b002bbc:	05bfffc4 	movi	r22,-1
 b002bc0:	0081ffc4 	movi	r2,2047
 b002bc4:	003f9606 	br	b002a20 <__alt_mem_flash+0xff001a20>
 b002bc8:	8023883a 	mov	r17,r16
 b002bcc:	b025883a 	mov	r18,r22
 b002bd0:	280f883a 	mov	r7,r5
 b002bd4:	003f8806 	br	b0029f8 <__alt_mem_flash+0xff0019f8>
 b002bd8:	8023883a 	mov	r17,r16
 b002bdc:	b025883a 	mov	r18,r22
 b002be0:	480d883a 	mov	r6,r9
 b002be4:	280f883a 	mov	r7,r5
 b002be8:	003f8306 	br	b0029f8 <__alt_mem_flash+0xff0019f8>
 b002bec:	b026d43a 	srli	r19,r22,16
 b002bf0:	902ed43a 	srli	r23,r18,16
 b002bf4:	b5bfffcc 	andi	r22,r22,65535
 b002bf8:	94bfffcc 	andi	r18,r18,65535
 b002bfc:	b00b883a 	mov	r5,r22
 b002c00:	9009883a 	mov	r4,r18
 b002c04:	d8c00515 	stw	r3,20(sp)
 b002c08:	d9800715 	stw	r6,28(sp)
 b002c0c:	da000615 	stw	r8,24(sp)
 b002c10:	b003fb80 	call	b003fb8 <__mulsi3>
 b002c14:	980b883a 	mov	r5,r19
 b002c18:	9009883a 	mov	r4,r18
 b002c1c:	1029883a 	mov	r20,r2
 b002c20:	b003fb80 	call	b003fb8 <__mulsi3>
 b002c24:	b80b883a 	mov	r5,r23
 b002c28:	9809883a 	mov	r4,r19
 b002c2c:	102b883a 	mov	r21,r2
 b002c30:	b003fb80 	call	b003fb8 <__mulsi3>
 b002c34:	b809883a 	mov	r4,r23
 b002c38:	b00b883a 	mov	r5,r22
 b002c3c:	1039883a 	mov	fp,r2
 b002c40:	b003fb80 	call	b003fb8 <__mulsi3>
 b002c44:	a008d43a 	srli	r4,r20,16
 b002c48:	1545883a 	add	r2,r2,r21
 b002c4c:	d8c00517 	ldw	r3,20(sp)
 b002c50:	2085883a 	add	r2,r4,r2
 b002c54:	d9800717 	ldw	r6,28(sp)
 b002c58:	da000617 	ldw	r8,24(sp)
 b002c5c:	1540022e 	bgeu	r2,r21,b002c68 <__muldf3+0x3c4>
 b002c60:	01000074 	movhi	r4,1
 b002c64:	e139883a 	add	fp,fp,r4
 b002c68:	100e943a 	slli	r7,r2,16
 b002c6c:	1004d43a 	srli	r2,r2,16
 b002c70:	882ad43a 	srli	r21,r17,16
 b002c74:	a53fffcc 	andi	r20,r20,65535
 b002c78:	8c7fffcc 	andi	r17,r17,65535
 b002c7c:	3d29883a 	add	r20,r7,r20
 b002c80:	b00b883a 	mov	r5,r22
 b002c84:	8809883a 	mov	r4,r17
 b002c88:	d8c00515 	stw	r3,20(sp)
 b002c8c:	d9800715 	stw	r6,28(sp)
 b002c90:	da000615 	stw	r8,24(sp)
 b002c94:	dd000115 	stw	r20,4(sp)
 b002c98:	d8800015 	stw	r2,0(sp)
 b002c9c:	b003fb80 	call	b003fb8 <__mulsi3>
 b002ca0:	980b883a 	mov	r5,r19
 b002ca4:	8809883a 	mov	r4,r17
 b002ca8:	d8800215 	stw	r2,8(sp)
 b002cac:	b003fb80 	call	b003fb8 <__mulsi3>
 b002cb0:	9809883a 	mov	r4,r19
 b002cb4:	a80b883a 	mov	r5,r21
 b002cb8:	1029883a 	mov	r20,r2
 b002cbc:	b003fb80 	call	b003fb8 <__mulsi3>
 b002cc0:	b00b883a 	mov	r5,r22
 b002cc4:	a809883a 	mov	r4,r21
 b002cc8:	d8800415 	stw	r2,16(sp)
 b002ccc:	b003fb80 	call	b003fb8 <__mulsi3>
 b002cd0:	d9c00217 	ldw	r7,8(sp)
 b002cd4:	1505883a 	add	r2,r2,r20
 b002cd8:	d8c00517 	ldw	r3,20(sp)
 b002cdc:	3826d43a 	srli	r19,r7,16
 b002ce0:	d9800717 	ldw	r6,28(sp)
 b002ce4:	da000617 	ldw	r8,24(sp)
 b002ce8:	9885883a 	add	r2,r19,r2
 b002cec:	da400417 	ldw	r9,16(sp)
 b002cf0:	1500022e 	bgeu	r2,r20,b002cfc <__muldf3+0x458>
 b002cf4:	01000074 	movhi	r4,1
 b002cf8:	4913883a 	add	r9,r9,r4
 b002cfc:	1028d43a 	srli	r20,r2,16
 b002d00:	1004943a 	slli	r2,r2,16
 b002d04:	802cd43a 	srli	r22,r16,16
 b002d08:	843fffcc 	andi	r16,r16,65535
 b002d0c:	3cffffcc 	andi	r19,r7,65535
 b002d10:	9009883a 	mov	r4,r18
 b002d14:	800b883a 	mov	r5,r16
 b002d18:	a269883a 	add	r20,r20,r9
 b002d1c:	d8c00515 	stw	r3,20(sp)
 b002d20:	d9800715 	stw	r6,28(sp)
 b002d24:	da000615 	stw	r8,24(sp)
 b002d28:	14e7883a 	add	r19,r2,r19
 b002d2c:	b003fb80 	call	b003fb8 <__mulsi3>
 b002d30:	9009883a 	mov	r4,r18
 b002d34:	b00b883a 	mov	r5,r22
 b002d38:	d8800315 	stw	r2,12(sp)
 b002d3c:	b003fb80 	call	b003fb8 <__mulsi3>
 b002d40:	b809883a 	mov	r4,r23
 b002d44:	b00b883a 	mov	r5,r22
 b002d48:	d8800215 	stw	r2,8(sp)
 b002d4c:	b003fb80 	call	b003fb8 <__mulsi3>
 b002d50:	b80b883a 	mov	r5,r23
 b002d54:	8009883a 	mov	r4,r16
 b002d58:	d8800415 	stw	r2,16(sp)
 b002d5c:	b003fb80 	call	b003fb8 <__mulsi3>
 b002d60:	da800317 	ldw	r10,12(sp)
 b002d64:	d9c00217 	ldw	r7,8(sp)
 b002d68:	d9000017 	ldw	r4,0(sp)
 b002d6c:	502ed43a 	srli	r23,r10,16
 b002d70:	11c5883a 	add	r2,r2,r7
 b002d74:	24e5883a 	add	r18,r4,r19
 b002d78:	b885883a 	add	r2,r23,r2
 b002d7c:	d8c00517 	ldw	r3,20(sp)
 b002d80:	d9800717 	ldw	r6,28(sp)
 b002d84:	da000617 	ldw	r8,24(sp)
 b002d88:	da400417 	ldw	r9,16(sp)
 b002d8c:	11c0022e 	bgeu	r2,r7,b002d98 <__muldf3+0x4f4>
 b002d90:	01000074 	movhi	r4,1
 b002d94:	4913883a 	add	r9,r9,r4
 b002d98:	100ed43a 	srli	r7,r2,16
 b002d9c:	1004943a 	slli	r2,r2,16
 b002da0:	55ffffcc 	andi	r23,r10,65535
 b002da4:	3a53883a 	add	r9,r7,r9
 b002da8:	8809883a 	mov	r4,r17
 b002dac:	800b883a 	mov	r5,r16
 b002db0:	d8c00515 	stw	r3,20(sp)
 b002db4:	d9800715 	stw	r6,28(sp)
 b002db8:	da000615 	stw	r8,24(sp)
 b002dbc:	da400415 	stw	r9,16(sp)
 b002dc0:	15ef883a 	add	r23,r2,r23
 b002dc4:	b003fb80 	call	b003fb8 <__mulsi3>
 b002dc8:	8809883a 	mov	r4,r17
 b002dcc:	b00b883a 	mov	r5,r22
 b002dd0:	d8800215 	stw	r2,8(sp)
 b002dd4:	b003fb80 	call	b003fb8 <__mulsi3>
 b002dd8:	b00b883a 	mov	r5,r22
 b002ddc:	a809883a 	mov	r4,r21
 b002de0:	d8800315 	stw	r2,12(sp)
 b002de4:	b003fb80 	call	b003fb8 <__mulsi3>
 b002de8:	8009883a 	mov	r4,r16
 b002dec:	a80b883a 	mov	r5,r21
 b002df0:	1023883a 	mov	r17,r2
 b002df4:	b003fb80 	call	b003fb8 <__mulsi3>
 b002df8:	d9c00217 	ldw	r7,8(sp)
 b002dfc:	da800317 	ldw	r10,12(sp)
 b002e00:	d8c00517 	ldw	r3,20(sp)
 b002e04:	3808d43a 	srli	r4,r7,16
 b002e08:	1285883a 	add	r2,r2,r10
 b002e0c:	d9800717 	ldw	r6,28(sp)
 b002e10:	2085883a 	add	r2,r4,r2
 b002e14:	da000617 	ldw	r8,24(sp)
 b002e18:	da400417 	ldw	r9,16(sp)
 b002e1c:	1280022e 	bgeu	r2,r10,b002e28 <__muldf3+0x584>
 b002e20:	01000074 	movhi	r4,1
 b002e24:	8923883a 	add	r17,r17,r4
 b002e28:	1008943a 	slli	r4,r2,16
 b002e2c:	39ffffcc 	andi	r7,r7,65535
 b002e30:	e4b9883a 	add	fp,fp,r18
 b002e34:	21cf883a 	add	r7,r4,r7
 b002e38:	e4e7803a 	cmpltu	r19,fp,r19
 b002e3c:	3d0f883a 	add	r7,r7,r20
 b002e40:	bf39883a 	add	fp,r23,fp
 b002e44:	99c9883a 	add	r4,r19,r7
 b002e48:	e5ef803a 	cmpltu	r23,fp,r23
 b002e4c:	490b883a 	add	r5,r9,r4
 b002e50:	1004d43a 	srli	r2,r2,16
 b002e54:	b965883a 	add	r18,r23,r5
 b002e58:	24c9803a 	cmpltu	r4,r4,r19
 b002e5c:	3d29803a 	cmpltu	r20,r7,r20
 b002e60:	a128b03a 	or	r20,r20,r4
 b002e64:	95ef803a 	cmpltu	r23,r18,r23
 b002e68:	2a53803a 	cmpltu	r9,r5,r9
 b002e6c:	a0a9883a 	add	r20,r20,r2
 b002e70:	4deeb03a 	or	r23,r9,r23
 b002e74:	a5ef883a 	add	r23,r20,r23
 b002e78:	bc63883a 	add	r17,r23,r17
 b002e7c:	e004927a 	slli	r2,fp,9
 b002e80:	d9000117 	ldw	r4,4(sp)
 b002e84:	882e927a 	slli	r23,r17,9
 b002e88:	9022d5fa 	srli	r17,r18,23
 b002e8c:	e038d5fa 	srli	fp,fp,23
 b002e90:	1104b03a 	or	r2,r2,r4
 b002e94:	9024927a 	slli	r18,r18,9
 b002e98:	1004c03a 	cmpne	r2,r2,zero
 b002e9c:	bc62b03a 	or	r17,r23,r17
 b002ea0:	1738b03a 	or	fp,r2,fp
 b002ea4:	8880402c 	andhi	r2,r17,256
 b002ea8:	e4a4b03a 	or	r18,fp,r18
 b002eac:	10000726 	beq	r2,zero,b002ecc <__muldf3+0x628>
 b002eb0:	9006d07a 	srli	r3,r18,1
 b002eb4:	880497fa 	slli	r2,r17,31
 b002eb8:	9480004c 	andi	r18,r18,1
 b002ebc:	8822d07a 	srli	r17,r17,1
 b002ec0:	1ca4b03a 	or	r18,r3,r18
 b002ec4:	14a4b03a 	or	r18,r2,r18
 b002ec8:	4007883a 	mov	r3,r8
 b002ecc:	1880ffc4 	addi	r2,r3,1023
 b002ed0:	0080460e 	bge	zero,r2,b002fec <__muldf3+0x748>
 b002ed4:	910001cc 	andi	r4,r18,7
 b002ed8:	20000726 	beq	r4,zero,b002ef8 <__muldf3+0x654>
 b002edc:	910003cc 	andi	r4,r18,15
 b002ee0:	01400104 	movi	r5,4
 b002ee4:	21400426 	beq	r4,r5,b002ef8 <__muldf3+0x654>
 b002ee8:	9149883a 	add	r4,r18,r5
 b002eec:	24a5803a 	cmpltu	r18,r4,r18
 b002ef0:	8ca3883a 	add	r17,r17,r18
 b002ef4:	2025883a 	mov	r18,r4
 b002ef8:	8900402c 	andhi	r4,r17,256
 b002efc:	20000426 	beq	r4,zero,b002f10 <__muldf3+0x66c>
 b002f00:	18810004 	addi	r2,r3,1024
 b002f04:	00ffc034 	movhi	r3,65280
 b002f08:	18ffffc4 	addi	r3,r3,-1
 b002f0c:	88e2703a 	and	r17,r17,r3
 b002f10:	00c1ff84 	movi	r3,2046
 b002f14:	18bf1316 	blt	r3,r2,b002b64 <__alt_mem_flash+0xff001b64>
 b002f18:	882c977a 	slli	r22,r17,29
 b002f1c:	9024d0fa 	srli	r18,r18,3
 b002f20:	8822927a 	slli	r17,r17,9
 b002f24:	1081ffcc 	andi	r2,r2,2047
 b002f28:	b4acb03a 	or	r22,r22,r18
 b002f2c:	8820d33a 	srli	r16,r17,12
 b002f30:	3027883a 	mov	r19,r6
 b002f34:	003eba06 	br	b002a20 <__alt_mem_flash+0xff001a20>
 b002f38:	8080022c 	andhi	r2,r16,8
 b002f3c:	10000926 	beq	r2,zero,b002f64 <__muldf3+0x6c0>
 b002f40:	8880022c 	andhi	r2,r17,8
 b002f44:	1000071e 	bne	r2,zero,b002f64 <__muldf3+0x6c0>
 b002f48:	00800434 	movhi	r2,16
 b002f4c:	8c000234 	orhi	r16,r17,8
 b002f50:	10bfffc4 	addi	r2,r2,-1
 b002f54:	e027883a 	mov	r19,fp
 b002f58:	80a0703a 	and	r16,r16,r2
 b002f5c:	902d883a 	mov	r22,r18
 b002f60:	003f1706 	br	b002bc0 <__alt_mem_flash+0xff001bc0>
 b002f64:	00800434 	movhi	r2,16
 b002f68:	84000234 	orhi	r16,r16,8
 b002f6c:	10bfffc4 	addi	r2,r2,-1
 b002f70:	80a0703a 	and	r16,r16,r2
 b002f74:	003f1206 	br	b002bc0 <__alt_mem_flash+0xff001bc0>
 b002f78:	147ff604 	addi	r17,r2,-40
 b002f7c:	3462983a 	sll	r17,r6,r17
 b002f80:	0025883a 	mov	r18,zero
 b002f84:	003ef306 	br	b002b54 <__alt_mem_flash+0xff001b54>
 b002f88:	3009883a 	mov	r4,r6
 b002f8c:	d9400215 	stw	r5,8(sp)
 b002f90:	d9800715 	stw	r6,28(sp)
 b002f94:	da400415 	stw	r9,16(sp)
 b002f98:	da800315 	stw	r10,12(sp)
 b002f9c:	b003da00 	call	b003da0 <__clzsi2>
 b002fa0:	10800804 	addi	r2,r2,32
 b002fa4:	da800317 	ldw	r10,12(sp)
 b002fa8:	da400417 	ldw	r9,16(sp)
 b002fac:	d9800717 	ldw	r6,28(sp)
 b002fb0:	d9400217 	ldw	r5,8(sp)
 b002fb4:	003edd06 	br	b002b2c <__alt_mem_flash+0xff001b2c>
 b002fb8:	143ff604 	addi	r16,r2,-40
 b002fbc:	ac20983a 	sll	r16,r21,r16
 b002fc0:	002d883a 	mov	r22,zero
 b002fc4:	003ec106 	br	b002acc <__alt_mem_flash+0xff001acc>
 b002fc8:	d9800715 	stw	r6,28(sp)
 b002fcc:	d9c00215 	stw	r7,8(sp)
 b002fd0:	da400415 	stw	r9,16(sp)
 b002fd4:	b003da00 	call	b003da0 <__clzsi2>
 b002fd8:	10800804 	addi	r2,r2,32
 b002fdc:	da400417 	ldw	r9,16(sp)
 b002fe0:	d9c00217 	ldw	r7,8(sp)
 b002fe4:	d9800717 	ldw	r6,28(sp)
 b002fe8:	003eae06 	br	b002aa4 <__alt_mem_flash+0xff001aa4>
 b002fec:	00c00044 	movi	r3,1
 b002ff0:	1887c83a 	sub	r3,r3,r2
 b002ff4:	01000e04 	movi	r4,56
 b002ff8:	20fe8516 	blt	r4,r3,b002a10 <__alt_mem_flash+0xff001a10>
 b002ffc:	010007c4 	movi	r4,31
 b003000:	20c01b16 	blt	r4,r3,b003070 <__muldf3+0x7cc>
 b003004:	00800804 	movi	r2,32
 b003008:	10c5c83a 	sub	r2,r2,r3
 b00300c:	888a983a 	sll	r5,r17,r2
 b003010:	90c8d83a 	srl	r4,r18,r3
 b003014:	9084983a 	sll	r2,r18,r2
 b003018:	88e2d83a 	srl	r17,r17,r3
 b00301c:	2906b03a 	or	r3,r5,r4
 b003020:	1004c03a 	cmpne	r2,r2,zero
 b003024:	1886b03a 	or	r3,r3,r2
 b003028:	188001cc 	andi	r2,r3,7
 b00302c:	10000726 	beq	r2,zero,b00304c <__muldf3+0x7a8>
 b003030:	188003cc 	andi	r2,r3,15
 b003034:	01000104 	movi	r4,4
 b003038:	11000426 	beq	r2,r4,b00304c <__muldf3+0x7a8>
 b00303c:	1805883a 	mov	r2,r3
 b003040:	10c00104 	addi	r3,r2,4
 b003044:	1885803a 	cmpltu	r2,r3,r2
 b003048:	88a3883a 	add	r17,r17,r2
 b00304c:	8880202c 	andhi	r2,r17,128
 b003050:	10001c26 	beq	r2,zero,b0030c4 <__muldf3+0x820>
 b003054:	3027883a 	mov	r19,r6
 b003058:	00800044 	movi	r2,1
 b00305c:	0021883a 	mov	r16,zero
 b003060:	002d883a 	mov	r22,zero
 b003064:	003e6e06 	br	b002a20 <__alt_mem_flash+0xff001a20>
 b003068:	4007883a 	mov	r3,r8
 b00306c:	003f9706 	br	b002ecc <__alt_mem_flash+0xff001ecc>
 b003070:	017ff844 	movi	r5,-31
 b003074:	2885c83a 	sub	r2,r5,r2
 b003078:	888ad83a 	srl	r5,r17,r2
 b00307c:	00800804 	movi	r2,32
 b003080:	18801a26 	beq	r3,r2,b0030ec <__muldf3+0x848>
 b003084:	01001004 	movi	r4,64
 b003088:	20c7c83a 	sub	r3,r4,r3
 b00308c:	88e2983a 	sll	r17,r17,r3
 b003090:	8ca4b03a 	or	r18,r17,r18
 b003094:	9004c03a 	cmpne	r2,r18,zero
 b003098:	2884b03a 	or	r2,r5,r2
 b00309c:	144001cc 	andi	r17,r2,7
 b0030a0:	88000d1e 	bne	r17,zero,b0030d8 <__muldf3+0x834>
 b0030a4:	0021883a 	mov	r16,zero
 b0030a8:	102cd0fa 	srli	r22,r2,3
 b0030ac:	3027883a 	mov	r19,r6
 b0030b0:	0005883a 	mov	r2,zero
 b0030b4:	b46cb03a 	or	r22,r22,r17
 b0030b8:	003e5906 	br	b002a20 <__alt_mem_flash+0xff001a20>
 b0030bc:	1007883a 	mov	r3,r2
 b0030c0:	0023883a 	mov	r17,zero
 b0030c4:	8820927a 	slli	r16,r17,9
 b0030c8:	1805883a 	mov	r2,r3
 b0030cc:	8822977a 	slli	r17,r17,29
 b0030d0:	8020d33a 	srli	r16,r16,12
 b0030d4:	003ff406 	br	b0030a8 <__alt_mem_flash+0xff0020a8>
 b0030d8:	10c003cc 	andi	r3,r2,15
 b0030dc:	01000104 	movi	r4,4
 b0030e0:	193ff626 	beq	r3,r4,b0030bc <__alt_mem_flash+0xff0020bc>
 b0030e4:	0023883a 	mov	r17,zero
 b0030e8:	003fd506 	br	b003040 <__alt_mem_flash+0xff002040>
 b0030ec:	0023883a 	mov	r17,zero
 b0030f0:	003fe706 	br	b003090 <__alt_mem_flash+0xff002090>
 b0030f4:	00800434 	movhi	r2,16
 b0030f8:	8c000234 	orhi	r16,r17,8
 b0030fc:	10bfffc4 	addi	r2,r2,-1
 b003100:	3027883a 	mov	r19,r6
 b003104:	80a0703a 	and	r16,r16,r2
 b003108:	902d883a 	mov	r22,r18
 b00310c:	003eac06 	br	b002bc0 <__alt_mem_flash+0xff001bc0>

0b003110 <__subdf3>:
 b003110:	02000434 	movhi	r8,16
 b003114:	423fffc4 	addi	r8,r8,-1
 b003118:	defffb04 	addi	sp,sp,-20
 b00311c:	2a14703a 	and	r10,r5,r8
 b003120:	3812d53a 	srli	r9,r7,20
 b003124:	3a10703a 	and	r8,r7,r8
 b003128:	2006d77a 	srli	r3,r4,29
 b00312c:	3004d77a 	srli	r2,r6,29
 b003130:	dc000015 	stw	r16,0(sp)
 b003134:	501490fa 	slli	r10,r10,3
 b003138:	2820d53a 	srli	r16,r5,20
 b00313c:	401090fa 	slli	r8,r8,3
 b003140:	dc800215 	stw	r18,8(sp)
 b003144:	dc400115 	stw	r17,4(sp)
 b003148:	dfc00415 	stw	ra,16(sp)
 b00314c:	202290fa 	slli	r17,r4,3
 b003150:	dcc00315 	stw	r19,12(sp)
 b003154:	4a41ffcc 	andi	r9,r9,2047
 b003158:	0101ffc4 	movi	r4,2047
 b00315c:	2824d7fa 	srli	r18,r5,31
 b003160:	8401ffcc 	andi	r16,r16,2047
 b003164:	50c6b03a 	or	r3,r10,r3
 b003168:	380ed7fa 	srli	r7,r7,31
 b00316c:	408ab03a 	or	r5,r8,r2
 b003170:	300c90fa 	slli	r6,r6,3
 b003174:	49009626 	beq	r9,r4,b0033d0 <__subdf3+0x2c0>
 b003178:	39c0005c 	xori	r7,r7,1
 b00317c:	8245c83a 	sub	r2,r16,r9
 b003180:	3c807426 	beq	r7,r18,b003354 <__subdf3+0x244>
 b003184:	0080af0e 	bge	zero,r2,b003444 <__subdf3+0x334>
 b003188:	48002a1e 	bne	r9,zero,b003234 <__subdf3+0x124>
 b00318c:	2988b03a 	or	r4,r5,r6
 b003190:	20009a1e 	bne	r4,zero,b0033fc <__subdf3+0x2ec>
 b003194:	888001cc 	andi	r2,r17,7
 b003198:	10000726 	beq	r2,zero,b0031b8 <__subdf3+0xa8>
 b00319c:	888003cc 	andi	r2,r17,15
 b0031a0:	01000104 	movi	r4,4
 b0031a4:	11000426 	beq	r2,r4,b0031b8 <__subdf3+0xa8>
 b0031a8:	890b883a 	add	r5,r17,r4
 b0031ac:	2c63803a 	cmpltu	r17,r5,r17
 b0031b0:	1c47883a 	add	r3,r3,r17
 b0031b4:	2823883a 	mov	r17,r5
 b0031b8:	1880202c 	andhi	r2,r3,128
 b0031bc:	10005926 	beq	r2,zero,b003324 <__subdf3+0x214>
 b0031c0:	84000044 	addi	r16,r16,1
 b0031c4:	0081ffc4 	movi	r2,2047
 b0031c8:	8080be26 	beq	r16,r2,b0034c4 <__subdf3+0x3b4>
 b0031cc:	017fe034 	movhi	r5,65408
 b0031d0:	297fffc4 	addi	r5,r5,-1
 b0031d4:	1946703a 	and	r3,r3,r5
 b0031d8:	1804977a 	slli	r2,r3,29
 b0031dc:	1806927a 	slli	r3,r3,9
 b0031e0:	8822d0fa 	srli	r17,r17,3
 b0031e4:	8401ffcc 	andi	r16,r16,2047
 b0031e8:	180ad33a 	srli	r5,r3,12
 b0031ec:	9100004c 	andi	r4,r18,1
 b0031f0:	1444b03a 	or	r2,r2,r17
 b0031f4:	80c1ffcc 	andi	r3,r16,2047
 b0031f8:	1820953a 	slli	r16,r3,20
 b0031fc:	20c03fcc 	andi	r3,r4,255
 b003200:	180897fa 	slli	r4,r3,31
 b003204:	00c00434 	movhi	r3,16
 b003208:	18ffffc4 	addi	r3,r3,-1
 b00320c:	28c6703a 	and	r3,r5,r3
 b003210:	1c06b03a 	or	r3,r3,r16
 b003214:	1906b03a 	or	r3,r3,r4
 b003218:	dfc00417 	ldw	ra,16(sp)
 b00321c:	dcc00317 	ldw	r19,12(sp)
 b003220:	dc800217 	ldw	r18,8(sp)
 b003224:	dc400117 	ldw	r17,4(sp)
 b003228:	dc000017 	ldw	r16,0(sp)
 b00322c:	dec00504 	addi	sp,sp,20
 b003230:	f800283a 	ret
 b003234:	0101ffc4 	movi	r4,2047
 b003238:	813fd626 	beq	r16,r4,b003194 <__alt_mem_flash+0xff002194>
 b00323c:	29402034 	orhi	r5,r5,128
 b003240:	01000e04 	movi	r4,56
 b003244:	2080a316 	blt	r4,r2,b0034d4 <__subdf3+0x3c4>
 b003248:	010007c4 	movi	r4,31
 b00324c:	2080c616 	blt	r4,r2,b003568 <__subdf3+0x458>
 b003250:	01000804 	movi	r4,32
 b003254:	2089c83a 	sub	r4,r4,r2
 b003258:	2910983a 	sll	r8,r5,r4
 b00325c:	308ed83a 	srl	r7,r6,r2
 b003260:	3108983a 	sll	r4,r6,r4
 b003264:	2884d83a 	srl	r2,r5,r2
 b003268:	41ccb03a 	or	r6,r8,r7
 b00326c:	2008c03a 	cmpne	r4,r4,zero
 b003270:	310cb03a 	or	r6,r6,r4
 b003274:	898dc83a 	sub	r6,r17,r6
 b003278:	89a3803a 	cmpltu	r17,r17,r6
 b00327c:	1887c83a 	sub	r3,r3,r2
 b003280:	1c47c83a 	sub	r3,r3,r17
 b003284:	3023883a 	mov	r17,r6
 b003288:	1880202c 	andhi	r2,r3,128
 b00328c:	10002326 	beq	r2,zero,b00331c <__subdf3+0x20c>
 b003290:	04c02034 	movhi	r19,128
 b003294:	9cffffc4 	addi	r19,r19,-1
 b003298:	1ce6703a 	and	r19,r3,r19
 b00329c:	98007a26 	beq	r19,zero,b003488 <__subdf3+0x378>
 b0032a0:	9809883a 	mov	r4,r19
 b0032a4:	b003da00 	call	b003da0 <__clzsi2>
 b0032a8:	113ffe04 	addi	r4,r2,-8
 b0032ac:	00c007c4 	movi	r3,31
 b0032b0:	19007b16 	blt	r3,r4,b0034a0 <__subdf3+0x390>
 b0032b4:	00800804 	movi	r2,32
 b0032b8:	1105c83a 	sub	r2,r2,r4
 b0032bc:	8884d83a 	srl	r2,r17,r2
 b0032c0:	9906983a 	sll	r3,r19,r4
 b0032c4:	8922983a 	sll	r17,r17,r4
 b0032c8:	10c4b03a 	or	r2,r2,r3
 b0032cc:	24007816 	blt	r4,r16,b0034b0 <__subdf3+0x3a0>
 b0032d0:	2421c83a 	sub	r16,r4,r16
 b0032d4:	80c00044 	addi	r3,r16,1
 b0032d8:	010007c4 	movi	r4,31
 b0032dc:	20c09516 	blt	r4,r3,b003534 <__subdf3+0x424>
 b0032e0:	01400804 	movi	r5,32
 b0032e4:	28cbc83a 	sub	r5,r5,r3
 b0032e8:	88c8d83a 	srl	r4,r17,r3
 b0032ec:	8962983a 	sll	r17,r17,r5
 b0032f0:	114a983a 	sll	r5,r2,r5
 b0032f4:	10c6d83a 	srl	r3,r2,r3
 b0032f8:	8804c03a 	cmpne	r2,r17,zero
 b0032fc:	290ab03a 	or	r5,r5,r4
 b003300:	28a2b03a 	or	r17,r5,r2
 b003304:	0021883a 	mov	r16,zero
 b003308:	003fa206 	br	b003194 <__alt_mem_flash+0xff002194>
 b00330c:	2090b03a 	or	r8,r4,r2
 b003310:	40018e26 	beq	r8,zero,b00394c <__subdf3+0x83c>
 b003314:	1007883a 	mov	r3,r2
 b003318:	2023883a 	mov	r17,r4
 b00331c:	888001cc 	andi	r2,r17,7
 b003320:	103f9e1e 	bne	r2,zero,b00319c <__alt_mem_flash+0xff00219c>
 b003324:	1804977a 	slli	r2,r3,29
 b003328:	8822d0fa 	srli	r17,r17,3
 b00332c:	1810d0fa 	srli	r8,r3,3
 b003330:	9100004c 	andi	r4,r18,1
 b003334:	1444b03a 	or	r2,r2,r17
 b003338:	00c1ffc4 	movi	r3,2047
 b00333c:	80c02826 	beq	r16,r3,b0033e0 <__subdf3+0x2d0>
 b003340:	01400434 	movhi	r5,16
 b003344:	297fffc4 	addi	r5,r5,-1
 b003348:	80e0703a 	and	r16,r16,r3
 b00334c:	414a703a 	and	r5,r8,r5
 b003350:	003fa806 	br	b0031f4 <__alt_mem_flash+0xff0021f4>
 b003354:	0080630e 	bge	zero,r2,b0034e4 <__subdf3+0x3d4>
 b003358:	48003026 	beq	r9,zero,b00341c <__subdf3+0x30c>
 b00335c:	0101ffc4 	movi	r4,2047
 b003360:	813f8c26 	beq	r16,r4,b003194 <__alt_mem_flash+0xff002194>
 b003364:	29402034 	orhi	r5,r5,128
 b003368:	01000e04 	movi	r4,56
 b00336c:	2080a90e 	bge	r4,r2,b003614 <__subdf3+0x504>
 b003370:	298cb03a 	or	r6,r5,r6
 b003374:	3012c03a 	cmpne	r9,r6,zero
 b003378:	0005883a 	mov	r2,zero
 b00337c:	4c53883a 	add	r9,r9,r17
 b003380:	4c63803a 	cmpltu	r17,r9,r17
 b003384:	10c7883a 	add	r3,r2,r3
 b003388:	88c7883a 	add	r3,r17,r3
 b00338c:	4823883a 	mov	r17,r9
 b003390:	1880202c 	andhi	r2,r3,128
 b003394:	1000d026 	beq	r2,zero,b0036d8 <__subdf3+0x5c8>
 b003398:	84000044 	addi	r16,r16,1
 b00339c:	0081ffc4 	movi	r2,2047
 b0033a0:	8080fe26 	beq	r16,r2,b00379c <__subdf3+0x68c>
 b0033a4:	00bfe034 	movhi	r2,65408
 b0033a8:	10bfffc4 	addi	r2,r2,-1
 b0033ac:	1886703a 	and	r3,r3,r2
 b0033b0:	880ad07a 	srli	r5,r17,1
 b0033b4:	180497fa 	slli	r2,r3,31
 b0033b8:	8900004c 	andi	r4,r17,1
 b0033bc:	2922b03a 	or	r17,r5,r4
 b0033c0:	1806d07a 	srli	r3,r3,1
 b0033c4:	1462b03a 	or	r17,r2,r17
 b0033c8:	3825883a 	mov	r18,r7
 b0033cc:	003f7106 	br	b003194 <__alt_mem_flash+0xff002194>
 b0033d0:	2984b03a 	or	r2,r5,r6
 b0033d4:	103f6826 	beq	r2,zero,b003178 <__alt_mem_flash+0xff002178>
 b0033d8:	39c03fcc 	andi	r7,r7,255
 b0033dc:	003f6706 	br	b00317c <__alt_mem_flash+0xff00217c>
 b0033e0:	4086b03a 	or	r3,r8,r2
 b0033e4:	18015226 	beq	r3,zero,b003930 <__subdf3+0x820>
 b0033e8:	00c00434 	movhi	r3,16
 b0033ec:	41400234 	orhi	r5,r8,8
 b0033f0:	18ffffc4 	addi	r3,r3,-1
 b0033f4:	28ca703a 	and	r5,r5,r3
 b0033f8:	003f7e06 	br	b0031f4 <__alt_mem_flash+0xff0021f4>
 b0033fc:	10bfffc4 	addi	r2,r2,-1
 b003400:	1000491e 	bne	r2,zero,b003528 <__subdf3+0x418>
 b003404:	898fc83a 	sub	r7,r17,r6
 b003408:	89e3803a 	cmpltu	r17,r17,r7
 b00340c:	1947c83a 	sub	r3,r3,r5
 b003410:	1c47c83a 	sub	r3,r3,r17
 b003414:	3823883a 	mov	r17,r7
 b003418:	003f9b06 	br	b003288 <__alt_mem_flash+0xff002288>
 b00341c:	2988b03a 	or	r4,r5,r6
 b003420:	203f5c26 	beq	r4,zero,b003194 <__alt_mem_flash+0xff002194>
 b003424:	10bfffc4 	addi	r2,r2,-1
 b003428:	1000931e 	bne	r2,zero,b003678 <__subdf3+0x568>
 b00342c:	898d883a 	add	r6,r17,r6
 b003430:	3463803a 	cmpltu	r17,r6,r17
 b003434:	1947883a 	add	r3,r3,r5
 b003438:	88c7883a 	add	r3,r17,r3
 b00343c:	3023883a 	mov	r17,r6
 b003440:	003fd306 	br	b003390 <__alt_mem_flash+0xff002390>
 b003444:	1000541e 	bne	r2,zero,b003598 <__subdf3+0x488>
 b003448:	80800044 	addi	r2,r16,1
 b00344c:	1081ffcc 	andi	r2,r2,2047
 b003450:	01000044 	movi	r4,1
 b003454:	2080a20e 	bge	r4,r2,b0036e0 <__subdf3+0x5d0>
 b003458:	8989c83a 	sub	r4,r17,r6
 b00345c:	8905803a 	cmpltu	r2,r17,r4
 b003460:	1967c83a 	sub	r19,r3,r5
 b003464:	98a7c83a 	sub	r19,r19,r2
 b003468:	9880202c 	andhi	r2,r19,128
 b00346c:	10006326 	beq	r2,zero,b0035fc <__subdf3+0x4ec>
 b003470:	3463c83a 	sub	r17,r6,r17
 b003474:	28c7c83a 	sub	r3,r5,r3
 b003478:	344d803a 	cmpltu	r6,r6,r17
 b00347c:	19a7c83a 	sub	r19,r3,r6
 b003480:	3825883a 	mov	r18,r7
 b003484:	983f861e 	bne	r19,zero,b0032a0 <__alt_mem_flash+0xff0022a0>
 b003488:	8809883a 	mov	r4,r17
 b00348c:	b003da00 	call	b003da0 <__clzsi2>
 b003490:	10800804 	addi	r2,r2,32
 b003494:	113ffe04 	addi	r4,r2,-8
 b003498:	00c007c4 	movi	r3,31
 b00349c:	193f850e 	bge	r3,r4,b0032b4 <__alt_mem_flash+0xff0022b4>
 b0034a0:	10bff604 	addi	r2,r2,-40
 b0034a4:	8884983a 	sll	r2,r17,r2
 b0034a8:	0023883a 	mov	r17,zero
 b0034ac:	243f880e 	bge	r4,r16,b0032d0 <__alt_mem_flash+0xff0022d0>
 b0034b0:	00ffe034 	movhi	r3,65408
 b0034b4:	18ffffc4 	addi	r3,r3,-1
 b0034b8:	8121c83a 	sub	r16,r16,r4
 b0034bc:	10c6703a 	and	r3,r2,r3
 b0034c0:	003f3406 	br	b003194 <__alt_mem_flash+0xff002194>
 b0034c4:	9100004c 	andi	r4,r18,1
 b0034c8:	000b883a 	mov	r5,zero
 b0034cc:	0005883a 	mov	r2,zero
 b0034d0:	003f4806 	br	b0031f4 <__alt_mem_flash+0xff0021f4>
 b0034d4:	298cb03a 	or	r6,r5,r6
 b0034d8:	300cc03a 	cmpne	r6,r6,zero
 b0034dc:	0005883a 	mov	r2,zero
 b0034e0:	003f6406 	br	b003274 <__alt_mem_flash+0xff002274>
 b0034e4:	10009a1e 	bne	r2,zero,b003750 <__subdf3+0x640>
 b0034e8:	82400044 	addi	r9,r16,1
 b0034ec:	4881ffcc 	andi	r2,r9,2047
 b0034f0:	02800044 	movi	r10,1
 b0034f4:	5080670e 	bge	r10,r2,b003694 <__subdf3+0x584>
 b0034f8:	0081ffc4 	movi	r2,2047
 b0034fc:	4880af26 	beq	r9,r2,b0037bc <__subdf3+0x6ac>
 b003500:	898d883a 	add	r6,r17,r6
 b003504:	1945883a 	add	r2,r3,r5
 b003508:	3447803a 	cmpltu	r3,r6,r17
 b00350c:	1887883a 	add	r3,r3,r2
 b003510:	182297fa 	slli	r17,r3,31
 b003514:	300cd07a 	srli	r6,r6,1
 b003518:	1806d07a 	srli	r3,r3,1
 b00351c:	4821883a 	mov	r16,r9
 b003520:	89a2b03a 	or	r17,r17,r6
 b003524:	003f1b06 	br	b003194 <__alt_mem_flash+0xff002194>
 b003528:	0101ffc4 	movi	r4,2047
 b00352c:	813f441e 	bne	r16,r4,b003240 <__alt_mem_flash+0xff002240>
 b003530:	003f1806 	br	b003194 <__alt_mem_flash+0xff002194>
 b003534:	843ff844 	addi	r16,r16,-31
 b003538:	01400804 	movi	r5,32
 b00353c:	1408d83a 	srl	r4,r2,r16
 b003540:	19405026 	beq	r3,r5,b003684 <__subdf3+0x574>
 b003544:	01401004 	movi	r5,64
 b003548:	28c7c83a 	sub	r3,r5,r3
 b00354c:	10c4983a 	sll	r2,r2,r3
 b003550:	88a2b03a 	or	r17,r17,r2
 b003554:	8822c03a 	cmpne	r17,r17,zero
 b003558:	2462b03a 	or	r17,r4,r17
 b00355c:	0007883a 	mov	r3,zero
 b003560:	0021883a 	mov	r16,zero
 b003564:	003f6d06 	br	b00331c <__alt_mem_flash+0xff00231c>
 b003568:	11fff804 	addi	r7,r2,-32
 b00356c:	01000804 	movi	r4,32
 b003570:	29ced83a 	srl	r7,r5,r7
 b003574:	11004526 	beq	r2,r4,b00368c <__subdf3+0x57c>
 b003578:	01001004 	movi	r4,64
 b00357c:	2089c83a 	sub	r4,r4,r2
 b003580:	2904983a 	sll	r2,r5,r4
 b003584:	118cb03a 	or	r6,r2,r6
 b003588:	300cc03a 	cmpne	r6,r6,zero
 b00358c:	398cb03a 	or	r6,r7,r6
 b003590:	0005883a 	mov	r2,zero
 b003594:	003f3706 	br	b003274 <__alt_mem_flash+0xff002274>
 b003598:	80002a26 	beq	r16,zero,b003644 <__subdf3+0x534>
 b00359c:	0101ffc4 	movi	r4,2047
 b0035a0:	49006626 	beq	r9,r4,b00373c <__subdf3+0x62c>
 b0035a4:	0085c83a 	sub	r2,zero,r2
 b0035a8:	18c02034 	orhi	r3,r3,128
 b0035ac:	01000e04 	movi	r4,56
 b0035b0:	20807e16 	blt	r4,r2,b0037ac <__subdf3+0x69c>
 b0035b4:	010007c4 	movi	r4,31
 b0035b8:	2080e716 	blt	r4,r2,b003958 <__subdf3+0x848>
 b0035bc:	01000804 	movi	r4,32
 b0035c0:	2089c83a 	sub	r4,r4,r2
 b0035c4:	1914983a 	sll	r10,r3,r4
 b0035c8:	8890d83a 	srl	r8,r17,r2
 b0035cc:	8908983a 	sll	r4,r17,r4
 b0035d0:	1884d83a 	srl	r2,r3,r2
 b0035d4:	5222b03a 	or	r17,r10,r8
 b0035d8:	2006c03a 	cmpne	r3,r4,zero
 b0035dc:	88e2b03a 	or	r17,r17,r3
 b0035e0:	3463c83a 	sub	r17,r6,r17
 b0035e4:	2885c83a 	sub	r2,r5,r2
 b0035e8:	344d803a 	cmpltu	r6,r6,r17
 b0035ec:	1187c83a 	sub	r3,r2,r6
 b0035f0:	4821883a 	mov	r16,r9
 b0035f4:	3825883a 	mov	r18,r7
 b0035f8:	003f2306 	br	b003288 <__alt_mem_flash+0xff002288>
 b0035fc:	24d0b03a 	or	r8,r4,r19
 b003600:	40001b1e 	bne	r8,zero,b003670 <__subdf3+0x560>
 b003604:	0005883a 	mov	r2,zero
 b003608:	0009883a 	mov	r4,zero
 b00360c:	0021883a 	mov	r16,zero
 b003610:	003f4906 	br	b003338 <__alt_mem_flash+0xff002338>
 b003614:	010007c4 	movi	r4,31
 b003618:	20803a16 	blt	r4,r2,b003704 <__subdf3+0x5f4>
 b00361c:	01000804 	movi	r4,32
 b003620:	2089c83a 	sub	r4,r4,r2
 b003624:	2912983a 	sll	r9,r5,r4
 b003628:	3090d83a 	srl	r8,r6,r2
 b00362c:	3108983a 	sll	r4,r6,r4
 b003630:	2884d83a 	srl	r2,r5,r2
 b003634:	4a12b03a 	or	r9,r9,r8
 b003638:	2008c03a 	cmpne	r4,r4,zero
 b00363c:	4912b03a 	or	r9,r9,r4
 b003640:	003f4e06 	br	b00337c <__alt_mem_flash+0xff00237c>
 b003644:	1c48b03a 	or	r4,r3,r17
 b003648:	20003c26 	beq	r4,zero,b00373c <__subdf3+0x62c>
 b00364c:	0084303a 	nor	r2,zero,r2
 b003650:	1000381e 	bne	r2,zero,b003734 <__subdf3+0x624>
 b003654:	3463c83a 	sub	r17,r6,r17
 b003658:	28c5c83a 	sub	r2,r5,r3
 b00365c:	344d803a 	cmpltu	r6,r6,r17
 b003660:	1187c83a 	sub	r3,r2,r6
 b003664:	4821883a 	mov	r16,r9
 b003668:	3825883a 	mov	r18,r7
 b00366c:	003f0606 	br	b003288 <__alt_mem_flash+0xff002288>
 b003670:	2023883a 	mov	r17,r4
 b003674:	003f0906 	br	b00329c <__alt_mem_flash+0xff00229c>
 b003678:	0101ffc4 	movi	r4,2047
 b00367c:	813f3a1e 	bne	r16,r4,b003368 <__alt_mem_flash+0xff002368>
 b003680:	003ec406 	br	b003194 <__alt_mem_flash+0xff002194>
 b003684:	0005883a 	mov	r2,zero
 b003688:	003fb106 	br	b003550 <__alt_mem_flash+0xff002550>
 b00368c:	0005883a 	mov	r2,zero
 b003690:	003fbc06 	br	b003584 <__alt_mem_flash+0xff002584>
 b003694:	1c44b03a 	or	r2,r3,r17
 b003698:	80008e1e 	bne	r16,zero,b0038d4 <__subdf3+0x7c4>
 b00369c:	1000c826 	beq	r2,zero,b0039c0 <__subdf3+0x8b0>
 b0036a0:	2984b03a 	or	r2,r5,r6
 b0036a4:	103ebb26 	beq	r2,zero,b003194 <__alt_mem_flash+0xff002194>
 b0036a8:	8989883a 	add	r4,r17,r6
 b0036ac:	1945883a 	add	r2,r3,r5
 b0036b0:	2447803a 	cmpltu	r3,r4,r17
 b0036b4:	1887883a 	add	r3,r3,r2
 b0036b8:	1880202c 	andhi	r2,r3,128
 b0036bc:	2023883a 	mov	r17,r4
 b0036c0:	103f1626 	beq	r2,zero,b00331c <__alt_mem_flash+0xff00231c>
 b0036c4:	00bfe034 	movhi	r2,65408
 b0036c8:	10bfffc4 	addi	r2,r2,-1
 b0036cc:	5021883a 	mov	r16,r10
 b0036d0:	1886703a 	and	r3,r3,r2
 b0036d4:	003eaf06 	br	b003194 <__alt_mem_flash+0xff002194>
 b0036d8:	3825883a 	mov	r18,r7
 b0036dc:	003f0f06 	br	b00331c <__alt_mem_flash+0xff00231c>
 b0036e0:	1c44b03a 	or	r2,r3,r17
 b0036e4:	8000251e 	bne	r16,zero,b00377c <__subdf3+0x66c>
 b0036e8:	1000661e 	bne	r2,zero,b003884 <__subdf3+0x774>
 b0036ec:	2990b03a 	or	r8,r5,r6
 b0036f0:	40009626 	beq	r8,zero,b00394c <__subdf3+0x83c>
 b0036f4:	2807883a 	mov	r3,r5
 b0036f8:	3023883a 	mov	r17,r6
 b0036fc:	3825883a 	mov	r18,r7
 b003700:	003ea406 	br	b003194 <__alt_mem_flash+0xff002194>
 b003704:	127ff804 	addi	r9,r2,-32
 b003708:	01000804 	movi	r4,32
 b00370c:	2a52d83a 	srl	r9,r5,r9
 b003710:	11008c26 	beq	r2,r4,b003944 <__subdf3+0x834>
 b003714:	01001004 	movi	r4,64
 b003718:	2085c83a 	sub	r2,r4,r2
 b00371c:	2884983a 	sll	r2,r5,r2
 b003720:	118cb03a 	or	r6,r2,r6
 b003724:	300cc03a 	cmpne	r6,r6,zero
 b003728:	4992b03a 	or	r9,r9,r6
 b00372c:	0005883a 	mov	r2,zero
 b003730:	003f1206 	br	b00337c <__alt_mem_flash+0xff00237c>
 b003734:	0101ffc4 	movi	r4,2047
 b003738:	493f9c1e 	bne	r9,r4,b0035ac <__alt_mem_flash+0xff0025ac>
 b00373c:	2807883a 	mov	r3,r5
 b003740:	3023883a 	mov	r17,r6
 b003744:	4821883a 	mov	r16,r9
 b003748:	3825883a 	mov	r18,r7
 b00374c:	003e9106 	br	b003194 <__alt_mem_flash+0xff002194>
 b003750:	80001f1e 	bne	r16,zero,b0037d0 <__subdf3+0x6c0>
 b003754:	1c48b03a 	or	r4,r3,r17
 b003758:	20005a26 	beq	r4,zero,b0038c4 <__subdf3+0x7b4>
 b00375c:	0084303a 	nor	r2,zero,r2
 b003760:	1000561e 	bne	r2,zero,b0038bc <__subdf3+0x7ac>
 b003764:	89a3883a 	add	r17,r17,r6
 b003768:	1945883a 	add	r2,r3,r5
 b00376c:	898d803a 	cmpltu	r6,r17,r6
 b003770:	3087883a 	add	r3,r6,r2
 b003774:	4821883a 	mov	r16,r9
 b003778:	003f0506 	br	b003390 <__alt_mem_flash+0xff002390>
 b00377c:	10002b1e 	bne	r2,zero,b00382c <__subdf3+0x71c>
 b003780:	2984b03a 	or	r2,r5,r6
 b003784:	10008026 	beq	r2,zero,b003988 <__subdf3+0x878>
 b003788:	2807883a 	mov	r3,r5
 b00378c:	3023883a 	mov	r17,r6
 b003790:	3825883a 	mov	r18,r7
 b003794:	0401ffc4 	movi	r16,2047
 b003798:	003e7e06 	br	b003194 <__alt_mem_flash+0xff002194>
 b00379c:	3809883a 	mov	r4,r7
 b0037a0:	0011883a 	mov	r8,zero
 b0037a4:	0005883a 	mov	r2,zero
 b0037a8:	003ee306 	br	b003338 <__alt_mem_flash+0xff002338>
 b0037ac:	1c62b03a 	or	r17,r3,r17
 b0037b0:	8822c03a 	cmpne	r17,r17,zero
 b0037b4:	0005883a 	mov	r2,zero
 b0037b8:	003f8906 	br	b0035e0 <__alt_mem_flash+0xff0025e0>
 b0037bc:	3809883a 	mov	r4,r7
 b0037c0:	4821883a 	mov	r16,r9
 b0037c4:	0011883a 	mov	r8,zero
 b0037c8:	0005883a 	mov	r2,zero
 b0037cc:	003eda06 	br	b003338 <__alt_mem_flash+0xff002338>
 b0037d0:	0101ffc4 	movi	r4,2047
 b0037d4:	49003b26 	beq	r9,r4,b0038c4 <__subdf3+0x7b4>
 b0037d8:	0085c83a 	sub	r2,zero,r2
 b0037dc:	18c02034 	orhi	r3,r3,128
 b0037e0:	01000e04 	movi	r4,56
 b0037e4:	20806e16 	blt	r4,r2,b0039a0 <__subdf3+0x890>
 b0037e8:	010007c4 	movi	r4,31
 b0037ec:	20807716 	blt	r4,r2,b0039cc <__subdf3+0x8bc>
 b0037f0:	01000804 	movi	r4,32
 b0037f4:	2089c83a 	sub	r4,r4,r2
 b0037f8:	1914983a 	sll	r10,r3,r4
 b0037fc:	8890d83a 	srl	r8,r17,r2
 b003800:	8908983a 	sll	r4,r17,r4
 b003804:	1884d83a 	srl	r2,r3,r2
 b003808:	5222b03a 	or	r17,r10,r8
 b00380c:	2006c03a 	cmpne	r3,r4,zero
 b003810:	88e2b03a 	or	r17,r17,r3
 b003814:	89a3883a 	add	r17,r17,r6
 b003818:	1145883a 	add	r2,r2,r5
 b00381c:	898d803a 	cmpltu	r6,r17,r6
 b003820:	3087883a 	add	r3,r6,r2
 b003824:	4821883a 	mov	r16,r9
 b003828:	003ed906 	br	b003390 <__alt_mem_flash+0xff002390>
 b00382c:	2984b03a 	or	r2,r5,r6
 b003830:	10004226 	beq	r2,zero,b00393c <__subdf3+0x82c>
 b003834:	1808d0fa 	srli	r4,r3,3
 b003838:	8822d0fa 	srli	r17,r17,3
 b00383c:	1806977a 	slli	r3,r3,29
 b003840:	2080022c 	andhi	r2,r4,8
 b003844:	1c62b03a 	or	r17,r3,r17
 b003848:	10000826 	beq	r2,zero,b00386c <__subdf3+0x75c>
 b00384c:	2812d0fa 	srli	r9,r5,3
 b003850:	4880022c 	andhi	r2,r9,8
 b003854:	1000051e 	bne	r2,zero,b00386c <__subdf3+0x75c>
 b003858:	300cd0fa 	srli	r6,r6,3
 b00385c:	2804977a 	slli	r2,r5,29
 b003860:	4809883a 	mov	r4,r9
 b003864:	3825883a 	mov	r18,r7
 b003868:	11a2b03a 	or	r17,r2,r6
 b00386c:	8806d77a 	srli	r3,r17,29
 b003870:	200890fa 	slli	r4,r4,3
 b003874:	882290fa 	slli	r17,r17,3
 b003878:	0401ffc4 	movi	r16,2047
 b00387c:	1906b03a 	or	r3,r3,r4
 b003880:	003e4406 	br	b003194 <__alt_mem_flash+0xff002194>
 b003884:	2984b03a 	or	r2,r5,r6
 b003888:	103e4226 	beq	r2,zero,b003194 <__alt_mem_flash+0xff002194>
 b00388c:	8989c83a 	sub	r4,r17,r6
 b003890:	8911803a 	cmpltu	r8,r17,r4
 b003894:	1945c83a 	sub	r2,r3,r5
 b003898:	1205c83a 	sub	r2,r2,r8
 b00389c:	1200202c 	andhi	r8,r2,128
 b0038a0:	403e9a26 	beq	r8,zero,b00330c <__alt_mem_flash+0xff00230c>
 b0038a4:	3463c83a 	sub	r17,r6,r17
 b0038a8:	28c5c83a 	sub	r2,r5,r3
 b0038ac:	344d803a 	cmpltu	r6,r6,r17
 b0038b0:	1187c83a 	sub	r3,r2,r6
 b0038b4:	3825883a 	mov	r18,r7
 b0038b8:	003e3606 	br	b003194 <__alt_mem_flash+0xff002194>
 b0038bc:	0101ffc4 	movi	r4,2047
 b0038c0:	493fc71e 	bne	r9,r4,b0037e0 <__alt_mem_flash+0xff0027e0>
 b0038c4:	2807883a 	mov	r3,r5
 b0038c8:	3023883a 	mov	r17,r6
 b0038cc:	4821883a 	mov	r16,r9
 b0038d0:	003e3006 	br	b003194 <__alt_mem_flash+0xff002194>
 b0038d4:	10003626 	beq	r2,zero,b0039b0 <__subdf3+0x8a0>
 b0038d8:	2984b03a 	or	r2,r5,r6
 b0038dc:	10001726 	beq	r2,zero,b00393c <__subdf3+0x82c>
 b0038e0:	1808d0fa 	srli	r4,r3,3
 b0038e4:	8822d0fa 	srli	r17,r17,3
 b0038e8:	1806977a 	slli	r3,r3,29
 b0038ec:	2080022c 	andhi	r2,r4,8
 b0038f0:	1c62b03a 	or	r17,r3,r17
 b0038f4:	10000726 	beq	r2,zero,b003914 <__subdf3+0x804>
 b0038f8:	2812d0fa 	srli	r9,r5,3
 b0038fc:	4880022c 	andhi	r2,r9,8
 b003900:	1000041e 	bne	r2,zero,b003914 <__subdf3+0x804>
 b003904:	300cd0fa 	srli	r6,r6,3
 b003908:	2804977a 	slli	r2,r5,29
 b00390c:	4809883a 	mov	r4,r9
 b003910:	11a2b03a 	or	r17,r2,r6
 b003914:	8806d77a 	srli	r3,r17,29
 b003918:	200890fa 	slli	r4,r4,3
 b00391c:	882290fa 	slli	r17,r17,3
 b003920:	3825883a 	mov	r18,r7
 b003924:	1906b03a 	or	r3,r3,r4
 b003928:	0401ffc4 	movi	r16,2047
 b00392c:	003e1906 	br	b003194 <__alt_mem_flash+0xff002194>
 b003930:	000b883a 	mov	r5,zero
 b003934:	0005883a 	mov	r2,zero
 b003938:	003e2e06 	br	b0031f4 <__alt_mem_flash+0xff0021f4>
 b00393c:	0401ffc4 	movi	r16,2047
 b003940:	003e1406 	br	b003194 <__alt_mem_flash+0xff002194>
 b003944:	0005883a 	mov	r2,zero
 b003948:	003f7506 	br	b003720 <__alt_mem_flash+0xff002720>
 b00394c:	0005883a 	mov	r2,zero
 b003950:	0009883a 	mov	r4,zero
 b003954:	003e7806 	br	b003338 <__alt_mem_flash+0xff002338>
 b003958:	123ff804 	addi	r8,r2,-32
 b00395c:	01000804 	movi	r4,32
 b003960:	1a10d83a 	srl	r8,r3,r8
 b003964:	11002526 	beq	r2,r4,b0039fc <__subdf3+0x8ec>
 b003968:	01001004 	movi	r4,64
 b00396c:	2085c83a 	sub	r2,r4,r2
 b003970:	1884983a 	sll	r2,r3,r2
 b003974:	1444b03a 	or	r2,r2,r17
 b003978:	1004c03a 	cmpne	r2,r2,zero
 b00397c:	40a2b03a 	or	r17,r8,r2
 b003980:	0005883a 	mov	r2,zero
 b003984:	003f1606 	br	b0035e0 <__alt_mem_flash+0xff0025e0>
 b003988:	02000434 	movhi	r8,16
 b00398c:	0009883a 	mov	r4,zero
 b003990:	423fffc4 	addi	r8,r8,-1
 b003994:	00bfffc4 	movi	r2,-1
 b003998:	0401ffc4 	movi	r16,2047
 b00399c:	003e6606 	br	b003338 <__alt_mem_flash+0xff002338>
 b0039a0:	1c62b03a 	or	r17,r3,r17
 b0039a4:	8822c03a 	cmpne	r17,r17,zero
 b0039a8:	0005883a 	mov	r2,zero
 b0039ac:	003f9906 	br	b003814 <__alt_mem_flash+0xff002814>
 b0039b0:	2807883a 	mov	r3,r5
 b0039b4:	3023883a 	mov	r17,r6
 b0039b8:	0401ffc4 	movi	r16,2047
 b0039bc:	003df506 	br	b003194 <__alt_mem_flash+0xff002194>
 b0039c0:	2807883a 	mov	r3,r5
 b0039c4:	3023883a 	mov	r17,r6
 b0039c8:	003df206 	br	b003194 <__alt_mem_flash+0xff002194>
 b0039cc:	123ff804 	addi	r8,r2,-32
 b0039d0:	01000804 	movi	r4,32
 b0039d4:	1a10d83a 	srl	r8,r3,r8
 b0039d8:	11000a26 	beq	r2,r4,b003a04 <__subdf3+0x8f4>
 b0039dc:	01001004 	movi	r4,64
 b0039e0:	2085c83a 	sub	r2,r4,r2
 b0039e4:	1884983a 	sll	r2,r3,r2
 b0039e8:	1444b03a 	or	r2,r2,r17
 b0039ec:	1004c03a 	cmpne	r2,r2,zero
 b0039f0:	40a2b03a 	or	r17,r8,r2
 b0039f4:	0005883a 	mov	r2,zero
 b0039f8:	003f8606 	br	b003814 <__alt_mem_flash+0xff002814>
 b0039fc:	0005883a 	mov	r2,zero
 b003a00:	003fdc06 	br	b003974 <__alt_mem_flash+0xff002974>
 b003a04:	0005883a 	mov	r2,zero
 b003a08:	003ff706 	br	b0039e8 <__alt_mem_flash+0xff0029e8>

0b003a0c <__floatsidf>:
 b003a0c:	defffd04 	addi	sp,sp,-12
 b003a10:	dfc00215 	stw	ra,8(sp)
 b003a14:	dc400115 	stw	r17,4(sp)
 b003a18:	dc000015 	stw	r16,0(sp)
 b003a1c:	20002b26 	beq	r4,zero,b003acc <__floatsidf+0xc0>
 b003a20:	2023883a 	mov	r17,r4
 b003a24:	2020d7fa 	srli	r16,r4,31
 b003a28:	20002d16 	blt	r4,zero,b003ae0 <__floatsidf+0xd4>
 b003a2c:	8809883a 	mov	r4,r17
 b003a30:	b003da00 	call	b003da0 <__clzsi2>
 b003a34:	01410784 	movi	r5,1054
 b003a38:	288bc83a 	sub	r5,r5,r2
 b003a3c:	01010cc4 	movi	r4,1075
 b003a40:	2149c83a 	sub	r4,r4,r5
 b003a44:	00c007c4 	movi	r3,31
 b003a48:	1900160e 	bge	r3,r4,b003aa4 <__floatsidf+0x98>
 b003a4c:	00c104c4 	movi	r3,1043
 b003a50:	1947c83a 	sub	r3,r3,r5
 b003a54:	88c6983a 	sll	r3,r17,r3
 b003a58:	00800434 	movhi	r2,16
 b003a5c:	10bfffc4 	addi	r2,r2,-1
 b003a60:	1886703a 	and	r3,r3,r2
 b003a64:	2941ffcc 	andi	r5,r5,2047
 b003a68:	800d883a 	mov	r6,r16
 b003a6c:	0005883a 	mov	r2,zero
 b003a70:	280a953a 	slli	r5,r5,20
 b003a74:	31803fcc 	andi	r6,r6,255
 b003a78:	01000434 	movhi	r4,16
 b003a7c:	300c97fa 	slli	r6,r6,31
 b003a80:	213fffc4 	addi	r4,r4,-1
 b003a84:	1906703a 	and	r3,r3,r4
 b003a88:	1946b03a 	or	r3,r3,r5
 b003a8c:	1986b03a 	or	r3,r3,r6
 b003a90:	dfc00217 	ldw	ra,8(sp)
 b003a94:	dc400117 	ldw	r17,4(sp)
 b003a98:	dc000017 	ldw	r16,0(sp)
 b003a9c:	dec00304 	addi	sp,sp,12
 b003aa0:	f800283a 	ret
 b003aa4:	00c002c4 	movi	r3,11
 b003aa8:	1887c83a 	sub	r3,r3,r2
 b003aac:	88c6d83a 	srl	r3,r17,r3
 b003ab0:	8904983a 	sll	r2,r17,r4
 b003ab4:	01000434 	movhi	r4,16
 b003ab8:	213fffc4 	addi	r4,r4,-1
 b003abc:	2941ffcc 	andi	r5,r5,2047
 b003ac0:	1906703a 	and	r3,r3,r4
 b003ac4:	800d883a 	mov	r6,r16
 b003ac8:	003fe906 	br	b003a70 <__alt_mem_flash+0xff002a70>
 b003acc:	000d883a 	mov	r6,zero
 b003ad0:	000b883a 	mov	r5,zero
 b003ad4:	0007883a 	mov	r3,zero
 b003ad8:	0005883a 	mov	r2,zero
 b003adc:	003fe406 	br	b003a70 <__alt_mem_flash+0xff002a70>
 b003ae0:	0123c83a 	sub	r17,zero,r4
 b003ae4:	003fd106 	br	b003a2c <__alt_mem_flash+0xff002a2c>

0b003ae8 <__extendsfdf2>:
 b003ae8:	200ad5fa 	srli	r5,r4,23
 b003aec:	defffd04 	addi	sp,sp,-12
 b003af0:	dc400115 	stw	r17,4(sp)
 b003af4:	29403fcc 	andi	r5,r5,255
 b003af8:	29800044 	addi	r6,r5,1
 b003afc:	04402034 	movhi	r17,128
 b003b00:	dc000015 	stw	r16,0(sp)
 b003b04:	8c7fffc4 	addi	r17,r17,-1
 b003b08:	dfc00215 	stw	ra,8(sp)
 b003b0c:	31803fcc 	andi	r6,r6,255
 b003b10:	00800044 	movi	r2,1
 b003b14:	8922703a 	and	r17,r17,r4
 b003b18:	2020d7fa 	srli	r16,r4,31
 b003b1c:	1180110e 	bge	r2,r6,b003b64 <__extendsfdf2+0x7c>
 b003b20:	880cd0fa 	srli	r6,r17,3
 b003b24:	8822977a 	slli	r17,r17,29
 b003b28:	2940e004 	addi	r5,r5,896
 b003b2c:	2941ffcc 	andi	r5,r5,2047
 b003b30:	2804953a 	slli	r2,r5,20
 b003b34:	01400434 	movhi	r5,16
 b003b38:	800697fa 	slli	r3,r16,31
 b003b3c:	297fffc4 	addi	r5,r5,-1
 b003b40:	314a703a 	and	r5,r6,r5
 b003b44:	288ab03a 	or	r5,r5,r2
 b003b48:	28c6b03a 	or	r3,r5,r3
 b003b4c:	8805883a 	mov	r2,r17
 b003b50:	dfc00217 	ldw	ra,8(sp)
 b003b54:	dc400117 	ldw	r17,4(sp)
 b003b58:	dc000017 	ldw	r16,0(sp)
 b003b5c:	dec00304 	addi	sp,sp,12
 b003b60:	f800283a 	ret
 b003b64:	2800111e 	bne	r5,zero,b003bac <__extendsfdf2+0xc4>
 b003b68:	88001c26 	beq	r17,zero,b003bdc <__extendsfdf2+0xf4>
 b003b6c:	8809883a 	mov	r4,r17
 b003b70:	b003da00 	call	b003da0 <__clzsi2>
 b003b74:	00c00284 	movi	r3,10
 b003b78:	18801b16 	blt	r3,r2,b003be8 <__extendsfdf2+0x100>
 b003b7c:	018002c4 	movi	r6,11
 b003b80:	308dc83a 	sub	r6,r6,r2
 b003b84:	11000544 	addi	r4,r2,21
 b003b88:	8986d83a 	srl	r3,r17,r6
 b003b8c:	8922983a 	sll	r17,r17,r4
 b003b90:	0180e244 	movi	r6,905
 b003b94:	01400434 	movhi	r5,16
 b003b98:	3085c83a 	sub	r2,r6,r2
 b003b9c:	297fffc4 	addi	r5,r5,-1
 b003ba0:	194c703a 	and	r6,r3,r5
 b003ba4:	1141ffcc 	andi	r5,r2,2047
 b003ba8:	003fe006 	br	b003b2c <__alt_mem_flash+0xff002b2c>
 b003bac:	88000826 	beq	r17,zero,b003bd0 <__extendsfdf2+0xe8>
 b003bb0:	880cd0fa 	srli	r6,r17,3
 b003bb4:	00800434 	movhi	r2,16
 b003bb8:	10bfffc4 	addi	r2,r2,-1
 b003bbc:	31800234 	orhi	r6,r6,8
 b003bc0:	8822977a 	slli	r17,r17,29
 b003bc4:	308c703a 	and	r6,r6,r2
 b003bc8:	0141ffc4 	movi	r5,2047
 b003bcc:	003fd706 	br	b003b2c <__alt_mem_flash+0xff002b2c>
 b003bd0:	0141ffc4 	movi	r5,2047
 b003bd4:	000d883a 	mov	r6,zero
 b003bd8:	003fd406 	br	b003b2c <__alt_mem_flash+0xff002b2c>
 b003bdc:	000b883a 	mov	r5,zero
 b003be0:	000d883a 	mov	r6,zero
 b003be4:	003fd106 	br	b003b2c <__alt_mem_flash+0xff002b2c>
 b003be8:	11bffd44 	addi	r6,r2,-11
 b003bec:	8986983a 	sll	r3,r17,r6
 b003bf0:	0023883a 	mov	r17,zero
 b003bf4:	003fe606 	br	b003b90 <__alt_mem_flash+0xff002b90>

0b003bf8 <__truncdfsf2>:
 b003bf8:	2810d53a 	srli	r8,r5,20
 b003bfc:	01c00434 	movhi	r7,16
 b003c00:	39ffffc4 	addi	r7,r7,-1
 b003c04:	29ce703a 	and	r7,r5,r7
 b003c08:	4201ffcc 	andi	r8,r8,2047
 b003c0c:	380e90fa 	slli	r7,r7,3
 b003c10:	200cd77a 	srli	r6,r4,29
 b003c14:	42400044 	addi	r9,r8,1
 b003c18:	4a41ffcc 	andi	r9,r9,2047
 b003c1c:	00c00044 	movi	r3,1
 b003c20:	280ad7fa 	srli	r5,r5,31
 b003c24:	31ceb03a 	or	r7,r6,r7
 b003c28:	200490fa 	slli	r2,r4,3
 b003c2c:	1a40230e 	bge	r3,r9,b003cbc <__truncdfsf2+0xc4>
 b003c30:	40ff2004 	addi	r3,r8,-896
 b003c34:	01803f84 	movi	r6,254
 b003c38:	30c01516 	blt	r6,r3,b003c90 <__truncdfsf2+0x98>
 b003c3c:	00c0380e 	bge	zero,r3,b003d20 <__truncdfsf2+0x128>
 b003c40:	200c91ba 	slli	r6,r4,6
 b003c44:	380e90fa 	slli	r7,r7,3
 b003c48:	1004d77a 	srli	r2,r2,29
 b003c4c:	300cc03a 	cmpne	r6,r6,zero
 b003c50:	31ccb03a 	or	r6,r6,r7
 b003c54:	308cb03a 	or	r6,r6,r2
 b003c58:	308001cc 	andi	r2,r6,7
 b003c5c:	10000426 	beq	r2,zero,b003c70 <__truncdfsf2+0x78>
 b003c60:	308003cc 	andi	r2,r6,15
 b003c64:	01000104 	movi	r4,4
 b003c68:	11000126 	beq	r2,r4,b003c70 <__truncdfsf2+0x78>
 b003c6c:	31800104 	addi	r6,r6,4
 b003c70:	3081002c 	andhi	r2,r6,1024
 b003c74:	10001626 	beq	r2,zero,b003cd0 <__truncdfsf2+0xd8>
 b003c78:	18c00044 	addi	r3,r3,1
 b003c7c:	00803fc4 	movi	r2,255
 b003c80:	18800326 	beq	r3,r2,b003c90 <__truncdfsf2+0x98>
 b003c84:	300c91ba 	slli	r6,r6,6
 b003c88:	300cd27a 	srli	r6,r6,9
 b003c8c:	00000206 	br	b003c98 <__truncdfsf2+0xa0>
 b003c90:	00ffffc4 	movi	r3,-1
 b003c94:	000d883a 	mov	r6,zero
 b003c98:	18c03fcc 	andi	r3,r3,255
 b003c9c:	180895fa 	slli	r4,r3,23
 b003ca0:	00c02034 	movhi	r3,128
 b003ca4:	280a97fa 	slli	r5,r5,31
 b003ca8:	18ffffc4 	addi	r3,r3,-1
 b003cac:	30c6703a 	and	r3,r6,r3
 b003cb0:	1906b03a 	or	r3,r3,r4
 b003cb4:	1944b03a 	or	r2,r3,r5
 b003cb8:	f800283a 	ret
 b003cbc:	40000b1e 	bne	r8,zero,b003cec <__truncdfsf2+0xf4>
 b003cc0:	388cb03a 	or	r6,r7,r2
 b003cc4:	0007883a 	mov	r3,zero
 b003cc8:	30000426 	beq	r6,zero,b003cdc <__truncdfsf2+0xe4>
 b003ccc:	01800144 	movi	r6,5
 b003cd0:	00803fc4 	movi	r2,255
 b003cd4:	300cd0fa 	srli	r6,r6,3
 b003cd8:	18800a26 	beq	r3,r2,b003d04 <__truncdfsf2+0x10c>
 b003cdc:	00802034 	movhi	r2,128
 b003ce0:	10bfffc4 	addi	r2,r2,-1
 b003ce4:	308c703a 	and	r6,r6,r2
 b003ce8:	003feb06 	br	b003c98 <__alt_mem_flash+0xff002c98>
 b003cec:	3888b03a 	or	r4,r7,r2
 b003cf0:	203fe726 	beq	r4,zero,b003c90 <__alt_mem_flash+0xff002c90>
 b003cf4:	380c90fa 	slli	r6,r7,3
 b003cf8:	00c03fc4 	movi	r3,255
 b003cfc:	31808034 	orhi	r6,r6,512
 b003d00:	003fd506 	br	b003c58 <__alt_mem_flash+0xff002c58>
 b003d04:	303fe226 	beq	r6,zero,b003c90 <__alt_mem_flash+0xff002c90>
 b003d08:	00802034 	movhi	r2,128
 b003d0c:	31801034 	orhi	r6,r6,64
 b003d10:	10bfffc4 	addi	r2,r2,-1
 b003d14:	00ffffc4 	movi	r3,-1
 b003d18:	308c703a 	and	r6,r6,r2
 b003d1c:	003fde06 	br	b003c98 <__alt_mem_flash+0xff002c98>
 b003d20:	013ffa44 	movi	r4,-23
 b003d24:	19000e16 	blt	r3,r4,b003d60 <__truncdfsf2+0x168>
 b003d28:	01000784 	movi	r4,30
 b003d2c:	20c9c83a 	sub	r4,r4,r3
 b003d30:	018007c4 	movi	r6,31
 b003d34:	39c02034 	orhi	r7,r7,128
 b003d38:	31000b16 	blt	r6,r4,b003d68 <__truncdfsf2+0x170>
 b003d3c:	423f2084 	addi	r8,r8,-894
 b003d40:	120c983a 	sll	r6,r2,r8
 b003d44:	3a0e983a 	sll	r7,r7,r8
 b003d48:	1104d83a 	srl	r2,r2,r4
 b003d4c:	300cc03a 	cmpne	r6,r6,zero
 b003d50:	31ceb03a 	or	r7,r6,r7
 b003d54:	388cb03a 	or	r6,r7,r2
 b003d58:	0007883a 	mov	r3,zero
 b003d5c:	003fbe06 	br	b003c58 <__alt_mem_flash+0xff002c58>
 b003d60:	0007883a 	mov	r3,zero
 b003d64:	003fd906 	br	b003ccc <__alt_mem_flash+0xff002ccc>
 b003d68:	01bfff84 	movi	r6,-2
 b003d6c:	30cdc83a 	sub	r6,r6,r3
 b003d70:	00c00804 	movi	r3,32
 b003d74:	398cd83a 	srl	r6,r7,r6
 b003d78:	20c00726 	beq	r4,r3,b003d98 <__truncdfsf2+0x1a0>
 b003d7c:	423f2884 	addi	r8,r8,-862
 b003d80:	3a0e983a 	sll	r7,r7,r8
 b003d84:	3884b03a 	or	r2,r7,r2
 b003d88:	1004c03a 	cmpne	r2,r2,zero
 b003d8c:	118cb03a 	or	r6,r2,r6
 b003d90:	0007883a 	mov	r3,zero
 b003d94:	003fb006 	br	b003c58 <__alt_mem_flash+0xff002c58>
 b003d98:	000f883a 	mov	r7,zero
 b003d9c:	003ff906 	br	b003d84 <__alt_mem_flash+0xff002d84>

0b003da0 <__clzsi2>:
 b003da0:	00bfffd4 	movui	r2,65535
 b003da4:	11000536 	bltu	r2,r4,b003dbc <__clzsi2+0x1c>
 b003da8:	00803fc4 	movi	r2,255
 b003dac:	11000f36 	bltu	r2,r4,b003dec <__clzsi2+0x4c>
 b003db0:	00800804 	movi	r2,32
 b003db4:	0007883a 	mov	r3,zero
 b003db8:	00000506 	br	b003dd0 <__clzsi2+0x30>
 b003dbc:	00804034 	movhi	r2,256
 b003dc0:	10bfffc4 	addi	r2,r2,-1
 b003dc4:	11000c2e 	bgeu	r2,r4,b003df8 <__clzsi2+0x58>
 b003dc8:	00800204 	movi	r2,8
 b003dcc:	00c00604 	movi	r3,24
 b003dd0:	20c8d83a 	srl	r4,r4,r3
 b003dd4:	00c2c074 	movhi	r3,2817
 b003dd8:	18e07444 	addi	r3,r3,-32303
 b003ddc:	1909883a 	add	r4,r3,r4
 b003de0:	20c00003 	ldbu	r3,0(r4)
 b003de4:	10c5c83a 	sub	r2,r2,r3
 b003de8:	f800283a 	ret
 b003dec:	00800604 	movi	r2,24
 b003df0:	00c00204 	movi	r3,8
 b003df4:	003ff606 	br	b003dd0 <__alt_mem_flash+0xff002dd0>
 b003df8:	00800404 	movi	r2,16
 b003dfc:	1007883a 	mov	r3,r2
 b003e00:	003ff306 	br	b003dd0 <__alt_mem_flash+0xff002dd0>

0b003e04 <__divsi3>:
 b003e04:	20001b16 	blt	r4,zero,b003e74 <__divsi3+0x70>
 b003e08:	000f883a 	mov	r7,zero
 b003e0c:	28001616 	blt	r5,zero,b003e68 <__divsi3+0x64>
 b003e10:	200d883a 	mov	r6,r4
 b003e14:	29001a2e 	bgeu	r5,r4,b003e80 <__divsi3+0x7c>
 b003e18:	00800804 	movi	r2,32
 b003e1c:	00c00044 	movi	r3,1
 b003e20:	00000106 	br	b003e28 <__divsi3+0x24>
 b003e24:	10000d26 	beq	r2,zero,b003e5c <__divsi3+0x58>
 b003e28:	294b883a 	add	r5,r5,r5
 b003e2c:	10bfffc4 	addi	r2,r2,-1
 b003e30:	18c7883a 	add	r3,r3,r3
 b003e34:	293ffb36 	bltu	r5,r4,b003e24 <__alt_mem_flash+0xff002e24>
 b003e38:	0005883a 	mov	r2,zero
 b003e3c:	18000726 	beq	r3,zero,b003e5c <__divsi3+0x58>
 b003e40:	0005883a 	mov	r2,zero
 b003e44:	31400236 	bltu	r6,r5,b003e50 <__divsi3+0x4c>
 b003e48:	314dc83a 	sub	r6,r6,r5
 b003e4c:	10c4b03a 	or	r2,r2,r3
 b003e50:	1806d07a 	srli	r3,r3,1
 b003e54:	280ad07a 	srli	r5,r5,1
 b003e58:	183ffa1e 	bne	r3,zero,b003e44 <__alt_mem_flash+0xff002e44>
 b003e5c:	38000126 	beq	r7,zero,b003e64 <__divsi3+0x60>
 b003e60:	0085c83a 	sub	r2,zero,r2
 b003e64:	f800283a 	ret
 b003e68:	014bc83a 	sub	r5,zero,r5
 b003e6c:	39c0005c 	xori	r7,r7,1
 b003e70:	003fe706 	br	b003e10 <__alt_mem_flash+0xff002e10>
 b003e74:	0109c83a 	sub	r4,zero,r4
 b003e78:	01c00044 	movi	r7,1
 b003e7c:	003fe306 	br	b003e0c <__alt_mem_flash+0xff002e0c>
 b003e80:	00c00044 	movi	r3,1
 b003e84:	003fee06 	br	b003e40 <__alt_mem_flash+0xff002e40>

0b003e88 <__modsi3>:
 b003e88:	20001716 	blt	r4,zero,b003ee8 <__modsi3+0x60>
 b003e8c:	000f883a 	mov	r7,zero
 b003e90:	2005883a 	mov	r2,r4
 b003e94:	28001216 	blt	r5,zero,b003ee0 <__modsi3+0x58>
 b003e98:	2900162e 	bgeu	r5,r4,b003ef4 <__modsi3+0x6c>
 b003e9c:	01800804 	movi	r6,32
 b003ea0:	00c00044 	movi	r3,1
 b003ea4:	00000106 	br	b003eac <__modsi3+0x24>
 b003ea8:	30000a26 	beq	r6,zero,b003ed4 <__modsi3+0x4c>
 b003eac:	294b883a 	add	r5,r5,r5
 b003eb0:	31bfffc4 	addi	r6,r6,-1
 b003eb4:	18c7883a 	add	r3,r3,r3
 b003eb8:	293ffb36 	bltu	r5,r4,b003ea8 <__alt_mem_flash+0xff002ea8>
 b003ebc:	18000526 	beq	r3,zero,b003ed4 <__modsi3+0x4c>
 b003ec0:	1806d07a 	srli	r3,r3,1
 b003ec4:	11400136 	bltu	r2,r5,b003ecc <__modsi3+0x44>
 b003ec8:	1145c83a 	sub	r2,r2,r5
 b003ecc:	280ad07a 	srli	r5,r5,1
 b003ed0:	183ffb1e 	bne	r3,zero,b003ec0 <__alt_mem_flash+0xff002ec0>
 b003ed4:	38000126 	beq	r7,zero,b003edc <__modsi3+0x54>
 b003ed8:	0085c83a 	sub	r2,zero,r2
 b003edc:	f800283a 	ret
 b003ee0:	014bc83a 	sub	r5,zero,r5
 b003ee4:	003fec06 	br	b003e98 <__alt_mem_flash+0xff002e98>
 b003ee8:	0109c83a 	sub	r4,zero,r4
 b003eec:	01c00044 	movi	r7,1
 b003ef0:	003fe706 	br	b003e90 <__alt_mem_flash+0xff002e90>
 b003ef4:	00c00044 	movi	r3,1
 b003ef8:	003ff106 	br	b003ec0 <__alt_mem_flash+0xff002ec0>

0b003efc <__udivsi3>:
 b003efc:	200d883a 	mov	r6,r4
 b003f00:	2900152e 	bgeu	r5,r4,b003f58 <__udivsi3+0x5c>
 b003f04:	28001416 	blt	r5,zero,b003f58 <__udivsi3+0x5c>
 b003f08:	00800804 	movi	r2,32
 b003f0c:	00c00044 	movi	r3,1
 b003f10:	00000206 	br	b003f1c <__udivsi3+0x20>
 b003f14:	10000e26 	beq	r2,zero,b003f50 <__udivsi3+0x54>
 b003f18:	28000516 	blt	r5,zero,b003f30 <__udivsi3+0x34>
 b003f1c:	294b883a 	add	r5,r5,r5
 b003f20:	10bfffc4 	addi	r2,r2,-1
 b003f24:	18c7883a 	add	r3,r3,r3
 b003f28:	293ffa36 	bltu	r5,r4,b003f14 <__alt_mem_flash+0xff002f14>
 b003f2c:	18000826 	beq	r3,zero,b003f50 <__udivsi3+0x54>
 b003f30:	0005883a 	mov	r2,zero
 b003f34:	31400236 	bltu	r6,r5,b003f40 <__udivsi3+0x44>
 b003f38:	314dc83a 	sub	r6,r6,r5
 b003f3c:	10c4b03a 	or	r2,r2,r3
 b003f40:	1806d07a 	srli	r3,r3,1
 b003f44:	280ad07a 	srli	r5,r5,1
 b003f48:	183ffa1e 	bne	r3,zero,b003f34 <__alt_mem_flash+0xff002f34>
 b003f4c:	f800283a 	ret
 b003f50:	0005883a 	mov	r2,zero
 b003f54:	f800283a 	ret
 b003f58:	00c00044 	movi	r3,1
 b003f5c:	003ff406 	br	b003f30 <__alt_mem_flash+0xff002f30>

0b003f60 <__umodsi3>:
 b003f60:	2005883a 	mov	r2,r4
 b003f64:	2900122e 	bgeu	r5,r4,b003fb0 <__umodsi3+0x50>
 b003f68:	28001116 	blt	r5,zero,b003fb0 <__umodsi3+0x50>
 b003f6c:	01800804 	movi	r6,32
 b003f70:	00c00044 	movi	r3,1
 b003f74:	00000206 	br	b003f80 <__umodsi3+0x20>
 b003f78:	30000c26 	beq	r6,zero,b003fac <__umodsi3+0x4c>
 b003f7c:	28000516 	blt	r5,zero,b003f94 <__umodsi3+0x34>
 b003f80:	294b883a 	add	r5,r5,r5
 b003f84:	31bfffc4 	addi	r6,r6,-1
 b003f88:	18c7883a 	add	r3,r3,r3
 b003f8c:	293ffa36 	bltu	r5,r4,b003f78 <__alt_mem_flash+0xff002f78>
 b003f90:	18000626 	beq	r3,zero,b003fac <__umodsi3+0x4c>
 b003f94:	1806d07a 	srli	r3,r3,1
 b003f98:	11400136 	bltu	r2,r5,b003fa0 <__umodsi3+0x40>
 b003f9c:	1145c83a 	sub	r2,r2,r5
 b003fa0:	280ad07a 	srli	r5,r5,1
 b003fa4:	183ffb1e 	bne	r3,zero,b003f94 <__alt_mem_flash+0xff002f94>
 b003fa8:	f800283a 	ret
 b003fac:	f800283a 	ret
 b003fb0:	00c00044 	movi	r3,1
 b003fb4:	003ff706 	br	b003f94 <__alt_mem_flash+0xff002f94>

0b003fb8 <__mulsi3>:
 b003fb8:	0005883a 	mov	r2,zero
 b003fbc:	20000726 	beq	r4,zero,b003fdc <__mulsi3+0x24>
 b003fc0:	20c0004c 	andi	r3,r4,1
 b003fc4:	2008d07a 	srli	r4,r4,1
 b003fc8:	18000126 	beq	r3,zero,b003fd0 <__mulsi3+0x18>
 b003fcc:	1145883a 	add	r2,r2,r5
 b003fd0:	294b883a 	add	r5,r5,r5
 b003fd4:	203ffa1e 	bne	r4,zero,b003fc0 <__alt_mem_flash+0xff002fc0>
 b003fd8:	f800283a 	ret
 b003fdc:	f800283a 	ret

0b003fe0 <__errno>:
 b003fe0:	0082c074 	movhi	r2,2817
 b003fe4:	10a6cb04 	addi	r2,r2,-25812
 b003fe8:	10800017 	ldw	r2,0(r2)
 b003fec:	f800283a 	ret

0b003ff0 <alt_load_section>:
 */

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
 b003ff0:	defffc04 	addi	sp,sp,-16
 b003ff4:	df000315 	stw	fp,12(sp)
 b003ff8:	df000304 	addi	fp,sp,12
 b003ffc:	e13ffd15 	stw	r4,-12(fp)
 b004000:	e17ffe15 	stw	r5,-8(fp)
 b004004:	e1bfff15 	stw	r6,-4(fp)
  if (to != from)
 b004008:	e0fffe17 	ldw	r3,-8(fp)
 b00400c:	e0bffd17 	ldw	r2,-12(fp)
 b004010:	18800c26 	beq	r3,r2,b004044 <alt_load_section+0x54>
  {
    while( to != end )
 b004014:	00000806 	br	b004038 <alt_load_section+0x48>
    {
      *to++ = *from++;
 b004018:	e0bffe17 	ldw	r2,-8(fp)
 b00401c:	10c00104 	addi	r3,r2,4
 b004020:	e0fffe15 	stw	r3,-8(fp)
 b004024:	e0fffd17 	ldw	r3,-12(fp)
 b004028:	19000104 	addi	r4,r3,4
 b00402c:	e13ffd15 	stw	r4,-12(fp)
 b004030:	18c00017 	ldw	r3,0(r3)
 b004034:	10c00015 	stw	r3,0(r2)
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
 b004038:	e0fffe17 	ldw	r3,-8(fp)
 b00403c:	e0bfff17 	ldw	r2,-4(fp)
 b004040:	18bff51e 	bne	r3,r2,b004018 <__alt_mem_flash+0xff003018>
    {
      *to++ = *from++;
    }
  }
}
 b004044:	0001883a 	nop
 b004048:	e037883a 	mov	sp,fp
 b00404c:	df000017 	ldw	fp,0(sp)
 b004050:	dec00104 	addi	sp,sp,4
 b004054:	f800283a 	ret

0b004058 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
 b004058:	defffe04 	addi	sp,sp,-8
 b00405c:	dfc00115 	stw	ra,4(sp)
 b004060:	df000015 	stw	fp,0(sp)
 b004064:	d839883a 	mov	fp,sp
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
 b004068:	0182c074 	movhi	r6,2817
 b00406c:	31a6d704 	addi	r6,r6,-25764
 b004070:	0142c074 	movhi	r5,2817
 b004074:	2960cf04 	addi	r5,r5,-31940
 b004078:	0102c074 	movhi	r4,2817
 b00407c:	2126d704 	addi	r4,r4,-25764
 b004080:	b003ff00 	call	b003ff0 <alt_load_section>

  /*
   * Copy the exception handler.
   */

  alt_load_section (&__flash_exceptions_start, 
 b004084:	0182c034 	movhi	r6,2816
 b004088:	31808404 	addi	r6,r6,528
 b00408c:	0142c034 	movhi	r5,2816
 b004090:	29400004 	addi	r5,r5,0
 b004094:	0102c034 	movhi	r4,2816
 b004098:	21000004 	addi	r4,r4,0
 b00409c:	b003ff00 	call	b003ff0 <alt_load_section>

  /*
   * Copy the .rodata section.
   */

  alt_load_section (&__flash_rodata_start, 
 b0040a0:	0182c074 	movhi	r6,2817
 b0040a4:	31a0cf04 	addi	r6,r6,-31940
 b0040a8:	0142c074 	movhi	r5,2817
 b0040ac:	29607004 	addi	r5,r5,-32320
 b0040b0:	0102c074 	movhi	r4,2817
 b0040b4:	21207004 	addi	r4,r4,-32320
 b0040b8:	b003ff00 	call	b003ff0 <alt_load_section>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
 b0040bc:	b006bc00 	call	b006bc0 <alt_dcache_flush_all>
  alt_icache_flush_all();
 b0040c0:	b006ef80 	call	b006ef8 <alt_icache_flush_all>
}
 b0040c4:	0001883a 	nop
 b0040c8:	e037883a 	mov	sp,fp
 b0040cc:	dfc00117 	ldw	ra,4(sp)
 b0040d0:	df000017 	ldw	fp,0(sp)
 b0040d4:	dec00204 	addi	sp,sp,8
 b0040d8:	f800283a 	ret

0b0040dc <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
 b0040dc:	defffd04 	addi	sp,sp,-12
 b0040e0:	dfc00215 	stw	ra,8(sp)
 b0040e4:	df000115 	stw	fp,4(sp)
 b0040e8:	df000104 	addi	fp,sp,4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
 b0040ec:	0009883a 	mov	r4,zero
 b0040f0:	b0041bc0 	call	b0041bc <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
 b0040f4:	0001883a 	nop
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
 b0040f8:	b0041f40 	call	b0041f4 <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
 b0040fc:	0182c074 	movhi	r6,2817
 b004100:	31a0b604 	addi	r6,r6,-32040
 b004104:	0142c074 	movhi	r5,2817
 b004108:	2960b604 	addi	r5,r5,-32040
 b00410c:	0102c074 	movhi	r4,2817
 b004110:	2120bb04 	addi	r4,r4,-32020
 b004114:	b00729c0 	call	b00729c <alt_io_redirect>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
 b004118:	b006cec0 	call	b006cec <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
 b00411c:	0102c034 	movhi	r4,2816
 b004120:	211b5304 	addi	r4,r4,27980
 b004124:	b007c4c0 	call	b007c4c <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
 b004128:	d0a61617 	ldw	r2,-26536(gp)
 b00412c:	d0e61717 	ldw	r3,-26532(gp)
 b004130:	d1261817 	ldw	r4,-26528(gp)
 b004134:	200d883a 	mov	r6,r4
 b004138:	180b883a 	mov	r5,r3
 b00413c:	1009883a 	mov	r4,r2
 b004140:	b00024c0 	call	b00024c <main>
 b004144:	e0bfff15 	stw	r2,-4(fp)
  close(STDOUT_FILENO);
 b004148:	01000044 	movi	r4,1
 b00414c:	b006ae80 	call	b006ae8 <close>
  exit (result);
 b004150:	e13fff17 	ldw	r4,-4(fp)
 b004154:	b007c600 	call	b007c60 <exit>

0b004158 <usleep>:
#if defined (__GNUC__) && __GNUC__ >= 4
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
 b004158:	defffd04 	addi	sp,sp,-12
 b00415c:	dfc00215 	stw	ra,8(sp)
 b004160:	df000115 	stw	fp,4(sp)
 b004164:	df000104 	addi	fp,sp,4
 b004168:	e13fff15 	stw	r4,-4(fp)
  return alt_busy_sleep(us);
 b00416c:	e13fff17 	ldw	r4,-4(fp)
 b004170:	b0069540 	call	b006954 <alt_busy_sleep>
}
 b004174:	e037883a 	mov	sp,fp
 b004178:	dfc00117 	ldw	ra,4(sp)
 b00417c:	df000017 	ldw	fp,0(sp)
 b004180:	dec00204 	addi	sp,sp,8
 b004184:	f800283a 	ret

0b004188 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
 b004188:	defffd04 	addi	sp,sp,-12
 b00418c:	dfc00215 	stw	ra,8(sp)
 b004190:	df000115 	stw	fp,4(sp)
 b004194:	df000104 	addi	fp,sp,4
 b004198:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
 b00419c:	d1600504 	addi	r5,gp,-32748
 b0041a0:	e13fff17 	ldw	r4,-4(fp)
 b0041a4:	b006c480 	call	b006c48 <alt_dev_llist_insert>
}
 b0041a8:	e037883a 	mov	sp,fp
 b0041ac:	dfc00117 	ldw	ra,4(sp)
 b0041b0:	df000017 	ldw	fp,0(sp)
 b0041b4:	dec00204 	addi	sp,sp,8
 b0041b8:	f800283a 	ret

0b0041bc <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
 b0041bc:	defffd04 	addi	sp,sp,-12
 b0041c0:	dfc00215 	stw	ra,8(sp)
 b0041c4:	df000115 	stw	fp,4(sp)
 b0041c8:	df000104 	addi	fp,sp,4
 b0041cc:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS_2, nios_2);
 b0041d0:	b0077c40 	call	b0077c4 <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
 b0041d4:	00800044 	movi	r2,1
 b0041d8:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
 b0041dc:	0001883a 	nop
 b0041e0:	e037883a 	mov	sp,fp
 b0041e4:	dfc00117 	ldw	ra,4(sp)
 b0041e8:	df000017 	ldw	fp,0(sp)
 b0041ec:	dec00204 	addi	sp,sp,8
 b0041f0:	f800283a 	ret

0b0041f4 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
 b0041f4:	defffe04 	addi	sp,sp,-8
 b0041f8:	dfc00115 	stw	ra,4(sp)
 b0041fc:	df000015 	stw	fp,0(sp)
 b004200:	d839883a 	mov	fp,sp
    ALTERA_AVALON_EPCS_FLASH_CONTROLLER_INIT ( FLASH, flash);
 b004204:	0102c074 	movhi	r4,2817
 b004208:	2121d804 	addi	r4,r4,-30880
 b00420c:	b0042900 	call	b004290 <alt_epcs_flash_init>
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
 b004210:	000d883a 	mov	r6,zero
 b004214:	000b883a 	mov	r5,zero
 b004218:	0102c074 	movhi	r4,2817
 b00421c:	21221504 	addi	r4,r4,-30636
 b004220:	b004ebc0 	call	b004ebc <altera_avalon_jtag_uart_init>
 b004224:	0102c074 	movhi	r4,2817
 b004228:	21220b04 	addi	r4,r4,-30676
 b00422c:	b0041880 	call	b004188 <alt_dev_reg>
    ALTERA_AVALON_SPI_INIT ( SPI_0, spi_0);
 b004230:	0001883a 	nop
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID_QSYS_1, sysid_qsys_1);
 b004234:	0001883a 	nop
//  ALTERA_AVALON_UART_INIT ( UART, uart);
    ALTERA_UP_AVALON_ADC_INIT ( ADC, adc);
 b004238:	0102c074 	movhi	r4,2817
 b00423c:	21265404 	addi	r4,r4,-26288
 b004240:	b0041880 	call	b004188 <alt_dev_reg>
}
 b004244:	0001883a 	nop
 b004248:	e037883a 	mov	sp,fp
 b00424c:	dfc00117 	ldw	ra,4(sp)
 b004250:	df000017 	ldw	fp,0(sp)
 b004254:	dec00204 	addi	sp,sp,8
 b004258:	f800283a 	ret

0b00425c <alt_flash_device_register>:

typedef struct alt_flash_dev alt_flash_dev; 
typedef alt_flash_dev alt_flash_fd;

static ALT_INLINE int alt_flash_device_register( alt_flash_fd* fd)
{
 b00425c:	defffd04 	addi	sp,sp,-12
 b004260:	dfc00215 	stw	ra,8(sp)
 b004264:	df000115 	stw	fp,4(sp)
 b004268:	df000104 	addi	fp,sp,4
 b00426c:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_flash_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) fd, &alt_flash_dev_list);
 b004270:	d1600904 	addi	r5,gp,-32732
 b004274:	e13fff17 	ldw	r4,-4(fp)
 b004278:	b006c480 	call	b006c48 <alt_dev_llist_insert>
}
 b00427c:	e037883a 	mov	sp,fp
 b004280:	dfc00117 	ldw	ra,4(sp)
 b004284:	df000017 	ldw	fp,0(sp)
 b004288:	dec00204 	addi	sp,sp,8
 b00428c:	f800283a 	ret

0b004290 <alt_epcs_flash_init>:
/*
 * alt_epcs_flash_init
 *
 */
int alt_epcs_flash_init(alt_flash_epcs_dev* flash)
{
 b004290:	defffc04 	addi	sp,sp,-16
 b004294:	dfc00315 	stw	ra,12(sp)
 b004298:	df000215 	stw	fp,8(sp)
 b00429c:	df000204 	addi	fp,sp,8
 b0042a0:	e13fff15 	stw	r4,-4(fp)
  int ret_code = 0;
 b0042a4:	e03ffe15 	stw	zero,-8(fp)

  /* Set up function pointers and/or data structures as needed. */
  ret_code = alt_epcs_flash_query(flash);
 b0042a8:	e13fff17 	ldw	r4,-4(fp)
 b0042ac:	b0042e40 	call	b0042e4 <alt_epcs_flash_query>
 b0042b0:	e0bffe15 	stw	r2,-8(fp)
  */

  /*
  *  Register this device as a valid flash device type
  */
  if (!ret_code)
 b0042b4:	e0bffe17 	ldw	r2,-8(fp)
 b0042b8:	1000041e 	bne	r2,zero,b0042cc <alt_epcs_flash_init+0x3c>
    ret_code = alt_flash_device_register(&(flash->dev));
 b0042bc:	e0bfff17 	ldw	r2,-4(fp)
 b0042c0:	1009883a 	mov	r4,r2
 b0042c4:	b00425c0 	call	b00425c <alt_flash_device_register>
 b0042c8:	e0bffe15 	stw	r2,-8(fp)

  return ret_code;
 b0042cc:	e0bffe17 	ldw	r2,-8(fp)
}
 b0042d0:	e037883a 	mov	sp,fp
 b0042d4:	dfc00117 	ldw	ra,4(sp)
 b0042d8:	df000017 	ldw	fp,0(sp)
 b0042dc:	dec00204 	addi	sp,sp,8
 b0042e0:	f800283a 	ret

0b0042e4 <alt_epcs_flash_query>:


static int alt_epcs_flash_query(alt_flash_epcs_dev* flash)
{
 b0042e4:	defffc04 	addi	sp,sp,-16
 b0042e8:	dfc00315 	stw	ra,12(sp)
 b0042ec:	df000215 	stw	fp,8(sp)
 b0042f0:	df000204 	addi	fp,sp,8
 b0042f4:	e13fff15 	stw	r4,-4(fp)
  int ret_code = 0;
 b0042f8:	e03ffe15 	stw	zero,-8(fp)
   * reset the device, or whatever, to ensure that
   * it's in a known working state.
  */
  
  /* Disable 4-bytes address mode. */
  flash->four_bytes_mode = 0;
 b0042fc:	e0bfff17 	ldw	r2,-4(fp)
 b004300:	10003215 	stw	zero,200(r2)
  
  /* Send the RES command sequence */
  flash->silicon_id =
    epcs_read_electronic_signature(flash->register_base);
 b004304:	e0bfff17 	ldw	r2,-4(fp)
 b004308:	10802e17 	ldw	r2,184(r2)
 b00430c:	1009883a 	mov	r4,r2
 b004310:	b0066880 	call	b006688 <epcs_read_electronic_signature>
  
  /* Disable 4-bytes address mode. */
  flash->four_bytes_mode = 0;
  
  /* Send the RES command sequence */
  flash->silicon_id =
 b004314:	10c03fcc 	andi	r3,r2,255
 b004318:	e0bfff17 	ldw	r2,-4(fp)
 b00431c:	10c03015 	stw	r3,192(r2)
    epcs_read_electronic_signature(flash->register_base);

  /* Fill in all device-specific parameters. */
  if (flash->silicon_id == 0x16) /* EPCS64 */
 b004320:	e0bfff17 	ldw	r2,-4(fp)
 b004324:	10803017 	ldw	r2,192(r2)
 b004328:	10800598 	cmpnei	r2,r2,22
 b00432c:	10000a1e 	bne	r2,zero,b004358 <alt_epcs_flash_query+0x74>
  {
    flash->dev.region_info[0].region_size = 64 * 1024 * 1024 / 8;
 b004330:	e0bfff17 	ldw	r2,-4(fp)
 b004334:	00c02034 	movhi	r3,128
 b004338:	10c00e15 	stw	r3,56(r2)
    flash->dev.region_info[0].number_of_blocks = 128;
 b00433c:	e0bfff17 	ldw	r2,-4(fp)
 b004340:	00c02004 	movi	r3,128
 b004344:	10c00f15 	stw	r3,60(r2)
    flash->dev.region_info[0].block_size = 65536;
 b004348:	e0bfff17 	ldw	r2,-4(fp)
 b00434c:	00c00074 	movhi	r3,1
 b004350:	10c01015 	stw	r3,64(r2)
 b004354:	0000ce06 	br	b004690 <alt_epcs_flash_query+0x3ac>
  }
  else if (flash->silicon_id == 0x14) /* EPCS16 */
 b004358:	e0bfff17 	ldw	r2,-4(fp)
 b00435c:	10803017 	ldw	r2,192(r2)
 b004360:	10800518 	cmpnei	r2,r2,20
 b004364:	10000a1e 	bne	r2,zero,b004390 <alt_epcs_flash_query+0xac>
  {
    flash->dev.region_info[0].region_size = 16 * 1024 * 1024 / 8;
 b004368:	e0bfff17 	ldw	r2,-4(fp)
 b00436c:	00c00834 	movhi	r3,32
 b004370:	10c00e15 	stw	r3,56(r2)
    flash->dev.region_info[0].number_of_blocks = 32;
 b004374:	e0bfff17 	ldw	r2,-4(fp)
 b004378:	00c00804 	movi	r3,32
 b00437c:	10c00f15 	stw	r3,60(r2)
    flash->dev.region_info[0].block_size = 65536;
 b004380:	e0bfff17 	ldw	r2,-4(fp)
 b004384:	00c00074 	movhi	r3,1
 b004388:	10c01015 	stw	r3,64(r2)
 b00438c:	0000c006 	br	b004690 <alt_epcs_flash_query+0x3ac>
  }
  else if (flash->silicon_id == 0x13) /* EPCS8 */
 b004390:	e0bfff17 	ldw	r2,-4(fp)
 b004394:	10803017 	ldw	r2,192(r2)
 b004398:	108004d8 	cmpnei	r2,r2,19
 b00439c:	10000a1e 	bne	r2,zero,b0043c8 <alt_epcs_flash_query+0xe4>
  {
    flash->dev.region_info[0].region_size = 8 * 1024 * 1024 / 8;
 b0043a0:	e0bfff17 	ldw	r2,-4(fp)
 b0043a4:	00c00434 	movhi	r3,16
 b0043a8:	10c00e15 	stw	r3,56(r2)
    flash->dev.region_info[0].number_of_blocks = 16;
 b0043ac:	e0bfff17 	ldw	r2,-4(fp)
 b0043b0:	00c00404 	movi	r3,16
 b0043b4:	10c00f15 	stw	r3,60(r2)
    flash->dev.region_info[0].block_size = 65536;
 b0043b8:	e0bfff17 	ldw	r2,-4(fp)
 b0043bc:	00c00074 	movhi	r3,1
 b0043c0:	10c01015 	stw	r3,64(r2)
 b0043c4:	0000b206 	br	b004690 <alt_epcs_flash_query+0x3ac>
  }
  else if (flash->silicon_id == 0x12) /* EPCS4 */
 b0043c8:	e0bfff17 	ldw	r2,-4(fp)
 b0043cc:	10803017 	ldw	r2,192(r2)
 b0043d0:	10800498 	cmpnei	r2,r2,18
 b0043d4:	10000a1e 	bne	r2,zero,b004400 <alt_epcs_flash_query+0x11c>
  {
    flash->dev.region_info[0].region_size = 4 * 1024 * 1024 / 8;
 b0043d8:	e0bfff17 	ldw	r2,-4(fp)
 b0043dc:	00c00234 	movhi	r3,8
 b0043e0:	10c00e15 	stw	r3,56(r2)
    flash->dev.region_info[0].number_of_blocks = 8;
 b0043e4:	e0bfff17 	ldw	r2,-4(fp)
 b0043e8:	00c00204 	movi	r3,8
 b0043ec:	10c00f15 	stw	r3,60(r2)
    flash->dev.region_info[0].block_size = 65536;
 b0043f0:	e0bfff17 	ldw	r2,-4(fp)
 b0043f4:	00c00074 	movhi	r3,1
 b0043f8:	10c01015 	stw	r3,64(r2)
 b0043fc:	0000a406 	br	b004690 <alt_epcs_flash_query+0x3ac>
  }
  else if (flash->silicon_id == 0x10) /* EPCS1 */
 b004400:	e0bfff17 	ldw	r2,-4(fp)
 b004404:	10803017 	ldw	r2,192(r2)
 b004408:	10800418 	cmpnei	r2,r2,16
 b00440c:	10000a1e 	bne	r2,zero,b004438 <alt_epcs_flash_query+0x154>
  {
    flash->dev.region_info[0].region_size = 1 * 1024 * 1024 / 8;
 b004410:	e0bfff17 	ldw	r2,-4(fp)
 b004414:	00c000b4 	movhi	r3,2
 b004418:	10c00e15 	stw	r3,56(r2)
    flash->dev.region_info[0].number_of_blocks = 4;
 b00441c:	e0bfff17 	ldw	r2,-4(fp)
 b004420:	00c00104 	movi	r3,4
 b004424:	10c00f15 	stw	r3,60(r2)
    flash->dev.region_info[0].block_size = 32768;
 b004428:	e0bfff17 	ldw	r2,-4(fp)
 b00442c:	00e00014 	movui	r3,32768
 b004430:	10c01015 	stw	r3,64(r2)
 b004434:	00009606 	br	b004690 <alt_epcs_flash_query+0x3ac>
  {
    /* 
     * Read electronic signature doesn't work for newer devices; try 
     * the "Read Device ID" command" before giving up.
     */
    flash->silicon_id = epcs_read_device_id(flash->register_base);
 b004438:	e0bfff17 	ldw	r2,-4(fp)
 b00443c:	10802e17 	ldw	r2,184(r2)
 b004440:	1009883a 	mov	r4,r2
 b004444:	b0066f00 	call	b0066f0 <epcs_read_device_id>
 b004448:	1007883a 	mov	r3,r2
 b00444c:	e0bfff17 	ldw	r2,-4(fp)
 b004450:	10c03015 	stw	r3,192(r2)
    /*
     * Last byte is the density ID. Note the difference between
     * EPCS128 and EPCQ128 -- arranged differently, though the 
     * least significant byte of each is '0x18'.
     */
    if((flash->silicon_id & 0xFFFFFF) == 0x20BA15) /* EPCQ16 */
 b004454:	e0bfff17 	ldw	r2,-4(fp)
 b004458:	10c03017 	ldw	r3,192(r2)
 b00445c:	00804034 	movhi	r2,256
 b004460:	10bfffc4 	addi	r2,r2,-1
 b004464:	1886703a 	and	r3,r3,r2
 b004468:	00800874 	movhi	r2,33
 b00446c:	10ae8544 	addi	r2,r2,-17899
 b004470:	18800a1e 	bne	r3,r2,b00449c <alt_epcs_flash_query+0x1b8>
    {
      flash->dev.region_info[0].region_size = 16 * 1024 * 1024 / 8;
 b004474:	e0bfff17 	ldw	r2,-4(fp)
 b004478:	00c00834 	movhi	r3,32
 b00447c:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 32; /* number of sectors */
 b004480:	e0bfff17 	ldw	r2,-4(fp)
 b004484:	00c00804 	movi	r3,32
 b004488:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
 b00448c:	e0bfff17 	ldw	r2,-4(fp)
 b004490:	00c00074 	movhi	r3,1
 b004494:	10c01015 	stw	r3,64(r2)
 b004498:	00007d06 	br	b004690 <alt_epcs_flash_query+0x3ac>
    }
    else if((flash->silicon_id & 0xFFFFFF) == 0x20BA16) /* EPCQ32 */
 b00449c:	e0bfff17 	ldw	r2,-4(fp)
 b0044a0:	10c03017 	ldw	r3,192(r2)
 b0044a4:	00804034 	movhi	r2,256
 b0044a8:	10bfffc4 	addi	r2,r2,-1
 b0044ac:	1886703a 	and	r3,r3,r2
 b0044b0:	00800874 	movhi	r2,33
 b0044b4:	10ae8584 	addi	r2,r2,-17898
 b0044b8:	18800a1e 	bne	r3,r2,b0044e4 <alt_epcs_flash_query+0x200>
    {
      flash->dev.region_info[0].region_size = 32 * 1024 * 1024 / 8;
 b0044bc:	e0bfff17 	ldw	r2,-4(fp)
 b0044c0:	00c01034 	movhi	r3,64
 b0044c4:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 64; /* number of sectors */
 b0044c8:	e0bfff17 	ldw	r2,-4(fp)
 b0044cc:	00c01004 	movi	r3,64
 b0044d0:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
 b0044d4:	e0bfff17 	ldw	r2,-4(fp)
 b0044d8:	00c00074 	movhi	r3,1
 b0044dc:	10c01015 	stw	r3,64(r2)
 b0044e0:	00006b06 	br	b004690 <alt_epcs_flash_query+0x3ac>
    }
    else if((flash->silicon_id & 0xFFFFFF) == 0x20BA17) /* EPCQ64 */
 b0044e4:	e0bfff17 	ldw	r2,-4(fp)
 b0044e8:	10c03017 	ldw	r3,192(r2)
 b0044ec:	00804034 	movhi	r2,256
 b0044f0:	10bfffc4 	addi	r2,r2,-1
 b0044f4:	1886703a 	and	r3,r3,r2
 b0044f8:	00800874 	movhi	r2,33
 b0044fc:	10ae85c4 	addi	r2,r2,-17897
 b004500:	18800a1e 	bne	r3,r2,b00452c <alt_epcs_flash_query+0x248>
    {
      flash->dev.region_info[0].region_size = 64 * 1024 * 1024 / 8;
 b004504:	e0bfff17 	ldw	r2,-4(fp)
 b004508:	00c02034 	movhi	r3,128
 b00450c:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 128; /* number of sectors */
 b004510:	e0bfff17 	ldw	r2,-4(fp)
 b004514:	00c02004 	movi	r3,128
 b004518:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
 b00451c:	e0bfff17 	ldw	r2,-4(fp)
 b004520:	00c00074 	movhi	r3,1
 b004524:	10c01015 	stw	r3,64(r2)
 b004528:	00005906 	br	b004690 <alt_epcs_flash_query+0x3ac>
    }
    else if((flash->silicon_id & 0xFFFFFF) == 0x20BA18) /* EPCQ128 */
 b00452c:	e0bfff17 	ldw	r2,-4(fp)
 b004530:	10c03017 	ldw	r3,192(r2)
 b004534:	00804034 	movhi	r2,256
 b004538:	10bfffc4 	addi	r2,r2,-1
 b00453c:	1886703a 	and	r3,r3,r2
 b004540:	00800874 	movhi	r2,33
 b004544:	10ae8604 	addi	r2,r2,-17896
 b004548:	18800a1e 	bne	r3,r2,b004574 <alt_epcs_flash_query+0x290>
    {
      flash->dev.region_info[0].region_size = 128 * 1024 * 1024 / 8;
 b00454c:	e0bfff17 	ldw	r2,-4(fp)
 b004550:	00c04034 	movhi	r3,256
 b004554:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 256; /* number of sectors */
 b004558:	e0bfff17 	ldw	r2,-4(fp)
 b00455c:	00c04004 	movi	r3,256
 b004560:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
 b004564:	e0bfff17 	ldw	r2,-4(fp)
 b004568:	00c00074 	movhi	r3,1
 b00456c:	10c01015 	stw	r3,64(r2)
 b004570:	00004706 	br	b004690 <alt_epcs_flash_query+0x3ac>
    }
    else if((flash->silicon_id & 0xFF) == 0x18) /* EPCS128 */
 b004574:	e0bfff17 	ldw	r2,-4(fp)
 b004578:	10803017 	ldw	r2,192(r2)
 b00457c:	10803fcc 	andi	r2,r2,255
 b004580:	10800618 	cmpnei	r2,r2,24
 b004584:	10000a1e 	bne	r2,zero,b0045b0 <alt_epcs_flash_query+0x2cc>
    {
      flash->dev.region_info[0].region_size = 128 * 1024 * 1024 / 8;
 b004588:	e0bfff17 	ldw	r2,-4(fp)
 b00458c:	00c04034 	movhi	r3,256
 b004590:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 64;
 b004594:	e0bfff17 	ldw	r2,-4(fp)
 b004598:	00c01004 	movi	r3,64
 b00459c:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 262144;
 b0045a0:	e0bfff17 	ldw	r2,-4(fp)
 b0045a4:	00c00134 	movhi	r3,4
 b0045a8:	10c01015 	stw	r3,64(r2)
 b0045ac:	00003806 	br	b004690 <alt_epcs_flash_query+0x3ac>
    }
    else if((flash->silicon_id & 0xFF ) == 0x19) /* EPCQ256 */
 b0045b0:	e0bfff17 	ldw	r2,-4(fp)
 b0045b4:	10803017 	ldw	r2,192(r2)
 b0045b8:	10803fcc 	andi	r2,r2,255
 b0045bc:	10800658 	cmpnei	r2,r2,25
 b0045c0:	10000d1e 	bne	r2,zero,b0045f8 <alt_epcs_flash_query+0x314>
    {
      flash->dev.region_info[0].region_size = 256 * 1024 * 1024 / 8;
 b0045c4:	e0bfff17 	ldw	r2,-4(fp)
 b0045c8:	00c08034 	movhi	r3,512
 b0045cc:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 512; /* number of sectors */
 b0045d0:	e0bfff17 	ldw	r2,-4(fp)
 b0045d4:	00c08004 	movi	r3,512
 b0045d8:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
 b0045dc:	e0bfff17 	ldw	r2,-4(fp)
 b0045e0:	00c00074 	movhi	r3,1
 b0045e4:	10c01015 	stw	r3,64(r2)
       * must first be programmed into the device, though. To complicate things, 
       * other Altera IP expects the chip to be in 3 byte address mode when they 
       * start using it. To be nice, we'll place the device into 4-byte address mode
       * when we need to, and take it back out when we're done.
       */
      flash->four_bytes_mode = 1;
 b0045e8:	e0bfff17 	ldw	r2,-4(fp)
 b0045ec:	00c00044 	movi	r3,1
 b0045f0:	10c03215 	stw	r3,200(r2)
 b0045f4:	00002606 	br	b004690 <alt_epcs_flash_query+0x3ac>
    }
    else if((flash->silicon_id & 0xFF ) == 0x20) /* EPCQ512 */
 b0045f8:	e0bfff17 	ldw	r2,-4(fp)
 b0045fc:	10803017 	ldw	r2,192(r2)
 b004600:	10803fcc 	andi	r2,r2,255
 b004604:	10800818 	cmpnei	r2,r2,32
 b004608:	10000d1e 	bne	r2,zero,b004640 <alt_epcs_flash_query+0x35c>
    {
      flash->dev.region_info[0].region_size = 512 * 1024 * 1024 / 8;
 b00460c:	e0bfff17 	ldw	r2,-4(fp)
 b004610:	00c10034 	movhi	r3,1024
 b004614:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 1024; /* number of sectors */
 b004618:	e0bfff17 	ldw	r2,-4(fp)
 b00461c:	00c10004 	movi	r3,1024
 b004620:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
 b004624:	e0bfff17 	ldw	r2,-4(fp)
 b004628:	00c00074 	movhi	r3,1
 b00462c:	10c01015 	stw	r3,64(r2)

      /* Enable 4-bytes address mode if the device density is greater than 256Mbit. */
      flash->four_bytes_mode = 1;
 b004630:	e0bfff17 	ldw	r2,-4(fp)
 b004634:	00c00044 	movi	r3,1
 b004638:	10c03215 	stw	r3,200(r2)
 b00463c:	00001406 	br	b004690 <alt_epcs_flash_query+0x3ac>
    }
    else if((flash->silicon_id & 0xFF ) == 0x21) /* EPCQ1024 */
 b004640:	e0bfff17 	ldw	r2,-4(fp)
 b004644:	10803017 	ldw	r2,192(r2)
 b004648:	10803fcc 	andi	r2,r2,255
 b00464c:	10800858 	cmpnei	r2,r2,33
 b004650:	10000d1e 	bne	r2,zero,b004688 <alt_epcs_flash_query+0x3a4>
    {
      flash->dev.region_info[0].region_size = 1024 * 1024 * 1024 / 8;
 b004654:	e0bfff17 	ldw	r2,-4(fp)
 b004658:	00c20034 	movhi	r3,2048
 b00465c:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 2048; /* number of sectors */
 b004660:	e0bfff17 	ldw	r2,-4(fp)
 b004664:	00c20004 	movi	r3,2048
 b004668:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
 b00466c:	e0bfff17 	ldw	r2,-4(fp)
 b004670:	00c00074 	movhi	r3,1
 b004674:	10c01015 	stw	r3,64(r2)

      /* Enable 4-bytes address mode if the device density is greater than 256Mbit. */
      flash->four_bytes_mode = 1;
 b004678:	e0bfff17 	ldw	r2,-4(fp)
 b00467c:	00c00044 	movi	r3,1
 b004680:	10c03215 	stw	r3,200(r2)
 b004684:	00000206 	br	b004690 <alt_epcs_flash_query+0x3ac>
    }
    else 
    {
      ret_code = -ENODEV; /* No known device found! */
 b004688:	00bffb44 	movi	r2,-19
 b00468c:	e0bffe15 	stw	r2,-8(fp)
    }
  }
  
  flash->size_in_bytes = flash->dev.region_info[0].region_size;
 b004690:	e0bfff17 	ldw	r2,-4(fp)
 b004694:	10800e17 	ldw	r2,56(r2)
 b004698:	1007883a 	mov	r3,r2
 b00469c:	e0bfff17 	ldw	r2,-4(fp)
 b0046a0:	10c02f15 	stw	r3,188(r2)
  flash->dev.number_of_regions = 1;
 b0046a4:	e0bfff17 	ldw	r2,-4(fp)
 b0046a8:	00c00044 	movi	r3,1
 b0046ac:	10c00c15 	stw	r3,48(r2)
  flash->dev.region_info[0].offset = 0;
 b0046b0:	e0bfff17 	ldw	r2,-4(fp)
 b0046b4:	10000d15 	stw	zero,52(r2)
  flash->page_size = 256;
 b0046b8:	e0bfff17 	ldw	r2,-4(fp)
 b0046bc:	00c04004 	movi	r3,256
 b0046c0:	10c03115 	stw	r3,196(r2)

  /* Consider clearing all BP bits here. */
  return ret_code;
 b0046c4:	e0bffe17 	ldw	r2,-8(fp)
}
 b0046c8:	e037883a 	mov	sp,fp
 b0046cc:	dfc00117 	ldw	ra,4(sp)
 b0046d0:	df000017 	ldw	fp,0(sp)
 b0046d4:	dec00204 	addi	sp,sp,8
 b0046d8:	f800283a 	ret

0b0046dc <alt_epcs_flash_memcmp>:
  alt_flash_dev* flash_info,
  const void* src_buffer,
  int offset,
  size_t n
)
{
 b0046dc:	deffee04 	addi	sp,sp,-72
 b0046e0:	dfc01115 	stw	ra,68(sp)
 b0046e4:	df001015 	stw	fp,64(sp)
 b0046e8:	df001004 	addi	fp,sp,64
 b0046ec:	e13ffc15 	stw	r4,-16(fp)
 b0046f0:	e17ffd15 	stw	r5,-12(fp)
 b0046f4:	e1bffe15 	stw	r6,-8(fp)
 b0046f8:	e1ffff15 	stw	r7,-4(fp)
  /*
   * Compare chunks of memory at a time, for better serial-flash
   * read efficiency.
   */
  alt_u8 chunk_buffer[32];
  const int chunk_size = sizeof(chunk_buffer) / sizeof(*chunk_buffer);
 b0046fc:	00800804 	movi	r2,32
 b004700:	e0bff115 	stw	r2,-60(fp)
  int current_offset = 0;
 b004704:	e03ff015 	stw	zero,-64(fp)

  while (n > 0)
 b004708:	00002706 	br	b0047a8 <alt_epcs_flash_memcmp+0xcc>
  {
    int this_chunk_size = n > chunk_size ? chunk_size : n;
 b00470c:	e0fff117 	ldw	r3,-60(fp)
 b004710:	e0bfff17 	ldw	r2,-4(fp)
 b004714:	1880012e 	bgeu	r3,r2,b00471c <alt_epcs_flash_memcmp+0x40>
 b004718:	1805883a 	mov	r2,r3
 b00471c:	e0bff215 	stw	r2,-56(fp)
    int this_chunk_cmp;

    if (
      alt_epcs_flash_read(
 b004720:	e0fffe17 	ldw	r3,-8(fp)
 b004724:	e0bff017 	ldw	r2,-64(fp)
 b004728:	1885883a 	add	r2,r3,r2
 b00472c:	e0fff404 	addi	r3,fp,-48
 b004730:	e1fff217 	ldw	r7,-56(fp)
 b004734:	180d883a 	mov	r6,r3
 b004738:	100b883a 	mov	r5,r2
 b00473c:	e13ffc17 	ldw	r4,-16(fp)
 b004740:	b004cc00 	call	b004cc0 <alt_epcs_flash_read>
  while (n > 0)
  {
    int this_chunk_size = n > chunk_size ? chunk_size : n;
    int this_chunk_cmp;

    if (
 b004744:	1000020e 	bge	r2,zero,b004750 <alt_epcs_flash_memcmp+0x74>
    {
      /*
      * If the read fails, I'm not sure what the appropriate action is.
      * Compare success seems wrong, so make it compare fail.
      */
      return -1;
 b004748:	00bfffc4 	movi	r2,-1
 b00474c:	00001906 	br	b0047b4 <alt_epcs_flash_memcmp+0xd8>
    }

    /* Compare this chunk against the source memory buffer. */
    this_chunk_cmp = memcmp(&((unsigned char*)(src_buffer))[current_offset], chunk_buffer, this_chunk_size);
 b004750:	e0bff017 	ldw	r2,-64(fp)
 b004754:	e0fffd17 	ldw	r3,-12(fp)
 b004758:	1885883a 	add	r2,r3,r2
 b00475c:	e13ff217 	ldw	r4,-56(fp)
 b004760:	e0fff404 	addi	r3,fp,-48
 b004764:	200d883a 	mov	r6,r4
 b004768:	180b883a 	mov	r5,r3
 b00476c:	1009883a 	mov	r4,r2
 b004770:	b007c980 	call	b007c98 <memcmp>
 b004774:	e0bff315 	stw	r2,-52(fp)
    if (this_chunk_cmp)
 b004778:	e0bff317 	ldw	r2,-52(fp)
 b00477c:	10000226 	beq	r2,zero,b004788 <alt_epcs_flash_memcmp+0xac>
    {
      return this_chunk_cmp;
 b004780:	e0bff317 	ldw	r2,-52(fp)
 b004784:	00000b06 	br	b0047b4 <alt_epcs_flash_memcmp+0xd8>
    }

    n -= this_chunk_size;
 b004788:	e0bff217 	ldw	r2,-56(fp)
 b00478c:	e0ffff17 	ldw	r3,-4(fp)
 b004790:	1885c83a 	sub	r2,r3,r2
 b004794:	e0bfff15 	stw	r2,-4(fp)
    current_offset += this_chunk_size;
 b004798:	e0fff017 	ldw	r3,-64(fp)
 b00479c:	e0bff217 	ldw	r2,-56(fp)
 b0047a0:	1885883a 	add	r2,r3,r2
 b0047a4:	e0bff015 	stw	r2,-64(fp)
   */
  alt_u8 chunk_buffer[32];
  const int chunk_size = sizeof(chunk_buffer) / sizeof(*chunk_buffer);
  int current_offset = 0;

  while (n > 0)
 b0047a8:	e0bfff17 	ldw	r2,-4(fp)
 b0047ac:	103fd71e 	bne	r2,zero,b00470c <__alt_mem_flash+0xff00370c>
  }

  /*
   * If execution made it to this point, compare is successful.
   */
  return 0;
 b0047b0:	0005883a 	mov	r2,zero
}
 b0047b4:	e037883a 	mov	sp,fp
 b0047b8:	dfc00117 	ldw	ra,4(sp)
 b0047bc:	df000017 	ldw	fp,0(sp)
 b0047c0:	dec00204 	addi	sp,sp,8
 b0047c4:	f800283a 	ret

0b0047c8 <alt_epcs_flash_write>:
 * large buffer to tie up in our programming library, when not all users will
 * want that functionality.
 */
int alt_epcs_flash_write(alt_flash_dev* flash_info, int offset,
                          const void* src_addr, int length)
{
 b0047c8:	defff404 	addi	sp,sp,-48
 b0047cc:	dfc00b15 	stw	ra,44(sp)
 b0047d0:	df000a15 	stw	fp,40(sp)
 b0047d4:	df000a04 	addi	fp,sp,40
 b0047d8:	e13ffc15 	stw	r4,-16(fp)
 b0047dc:	e17ffd15 	stw	r5,-12(fp)
 b0047e0:	e1bffe15 	stw	r6,-8(fp)
 b0047e4:	e1ffff15 	stw	r7,-4(fp)
  int         ret_code = 0;
 b0047e8:	e03ff715 	stw	zero,-36(fp)
  int         current_offset;

  /*
   * First and foremost which sectors are affected?
   */
  for(i = 0; i < flash_info->number_of_regions; i++)
 b0047ec:	e03ff815 	stw	zero,-32(fp)
 b0047f0:	00008306 	br	b004a00 <alt_epcs_flash_write+0x238>
  {
    /* Is it in this erase block region?*/
    if((offset >= flash_info->region_info[i].offset) &&
 b0047f4:	e0fffc17 	ldw	r3,-16(fp)
 b0047f8:	e0bff817 	ldw	r2,-32(fp)
 b0047fc:	1004913a 	slli	r2,r2,4
 b004800:	1885883a 	add	r2,r3,r2
 b004804:	10800d04 	addi	r2,r2,52
 b004808:	10800017 	ldw	r2,0(r2)
 b00480c:	e0fffd17 	ldw	r3,-12(fp)
 b004810:	18807816 	blt	r3,r2,b0049f4 <alt_epcs_flash_write+0x22c>
      (offset < (flash_info->region_info[i].offset +
 b004814:	e0fffc17 	ldw	r3,-16(fp)
 b004818:	e0bff817 	ldw	r2,-32(fp)
 b00481c:	1004913a 	slli	r2,r2,4
 b004820:	1885883a 	add	r2,r3,r2
 b004824:	10800d04 	addi	r2,r2,52
 b004828:	10c00017 	ldw	r3,0(r2)
      flash_info->region_info[i].region_size)))
 b00482c:	e13ffc17 	ldw	r4,-16(fp)
 b004830:	e0bff817 	ldw	r2,-32(fp)
 b004834:	1004913a 	slli	r2,r2,4
 b004838:	2085883a 	add	r2,r4,r2
 b00483c:	10800e04 	addi	r2,r2,56
 b004840:	10800017 	ldw	r2,0(r2)
   */
  for(i = 0; i < flash_info->number_of_regions; i++)
  {
    /* Is it in this erase block region?*/
    if((offset >= flash_info->region_info[i].offset) &&
      (offset < (flash_info->region_info[i].offset +
 b004844:	1885883a 	add	r2,r3,r2
   * First and foremost which sectors are affected?
   */
  for(i = 0; i < flash_info->number_of_regions; i++)
  {
    /* Is it in this erase block region?*/
    if((offset >= flash_info->region_info[i].offset) &&
 b004848:	e0fffd17 	ldw	r3,-12(fp)
 b00484c:	1880690e 	bge	r3,r2,b0049f4 <alt_epcs_flash_write+0x22c>
      (offset < (flash_info->region_info[i].offset +
      flash_info->region_info[i].region_size)))
    {
      current_offset = flash_info->region_info[i].offset;
 b004850:	e0fffc17 	ldw	r3,-16(fp)
 b004854:	e0bff817 	ldw	r2,-32(fp)
 b004858:	1004913a 	slli	r2,r2,4
 b00485c:	1885883a 	add	r2,r3,r2
 b004860:	10800d04 	addi	r2,r2,52
 b004864:	10800017 	ldw	r2,0(r2)
 b004868:	e0bffa15 	stw	r2,-24(fp)

      for(j=0;j<flash_info->region_info[i].number_of_blocks;j++)
 b00486c:	e03ff915 	stw	zero,-28(fp)
 b004870:	00005806 	br	b0049d4 <alt_epcs_flash_write+0x20c>
      {
        if ((offset >= current_offset ) &&
 b004874:	e0fffd17 	ldw	r3,-12(fp)
 b004878:	e0bffa17 	ldw	r2,-24(fp)
 b00487c:	18804916 	blt	r3,r2,b0049a4 <alt_epcs_flash_write+0x1dc>
            (offset < (current_offset +
            flash_info->region_info[i].block_size)))
 b004880:	e0fffc17 	ldw	r3,-16(fp)
 b004884:	e0bff817 	ldw	r2,-32(fp)
 b004888:	10800104 	addi	r2,r2,4
 b00488c:	1004913a 	slli	r2,r2,4
 b004890:	1885883a 	add	r2,r3,r2
 b004894:	10c00017 	ldw	r3,0(r2)
      current_offset = flash_info->region_info[i].offset;

      for(j=0;j<flash_info->region_info[i].number_of_blocks;j++)
      {
        if ((offset >= current_offset ) &&
            (offset < (current_offset +
 b004898:	e0bffa17 	ldw	r2,-24(fp)
 b00489c:	1885883a 	add	r2,r3,r2
    {
      current_offset = flash_info->region_info[i].offset;

      for(j=0;j<flash_info->region_info[i].number_of_blocks;j++)
      {
        if ((offset >= current_offset ) &&
 b0048a0:	e0fffd17 	ldw	r3,-12(fp)
 b0048a4:	18803f0e 	bge	r3,r2,b0049a4 <alt_epcs_flash_write+0x1dc>
        {
          /*
           * Check if the contents of the block are different
           * from the data we wish to put there
           */
          data_to_write = ( current_offset + flash_info->region_info[i].block_size
 b0048a8:	e0fffc17 	ldw	r3,-16(fp)
 b0048ac:	e0bff817 	ldw	r2,-32(fp)
 b0048b0:	10800104 	addi	r2,r2,4
 b0048b4:	1004913a 	slli	r2,r2,4
 b0048b8:	1885883a 	add	r2,r3,r2
 b0048bc:	10c00017 	ldw	r3,0(r2)
 b0048c0:	e0bffa17 	ldw	r2,-24(fp)
 b0048c4:	1887883a 	add	r3,r3,r2
 b0048c8:	e0bffd17 	ldw	r2,-12(fp)
 b0048cc:	1885c83a 	sub	r2,r3,r2
 b0048d0:	e0bffb15 	stw	r2,-20(fp)
                            - offset);
          data_to_write = MIN(data_to_write, length);
 b0048d4:	e0fffb17 	ldw	r3,-20(fp)
 b0048d8:	e0bfff17 	ldw	r2,-4(fp)
 b0048dc:	1880010e 	bge	r3,r2,b0048e4 <alt_epcs_flash_write+0x11c>
 b0048e0:	1805883a 	mov	r2,r3
 b0048e4:	e0bffb15 	stw	r2,-20(fp)

          if(alt_epcs_flash_memcmp(flash_info, src_addr, offset, data_to_write))
 b0048e8:	e0bffb17 	ldw	r2,-20(fp)
 b0048ec:	100f883a 	mov	r7,r2
 b0048f0:	e1bffd17 	ldw	r6,-12(fp)
 b0048f4:	e17ffe17 	ldw	r5,-8(fp)
 b0048f8:	e13ffc17 	ldw	r4,-16(fp)
 b0048fc:	b0046dc0 	call	b0046dc <alt_epcs_flash_memcmp>
 b004900:	10001226 	beq	r2,zero,b00494c <alt_epcs_flash_write+0x184>
          {
            ret_code = (*flash_info->erase_block)(flash_info, current_offset);
 b004904:	e0bffc17 	ldw	r2,-16(fp)
 b004908:	10800817 	ldw	r2,32(r2)
 b00490c:	e17ffa17 	ldw	r5,-24(fp)
 b004910:	e13ffc17 	ldw	r4,-16(fp)
 b004914:	103ee83a 	callr	r2
 b004918:	e0bff715 	stw	r2,-36(fp)

            if (!ret_code)
 b00491c:	e0bff717 	ldw	r2,-36(fp)
 b004920:	10000a1e 	bne	r2,zero,b00494c <alt_epcs_flash_write+0x184>
            {
              ret_code = (*flash_info->write_block)(
 b004924:	e0bffc17 	ldw	r2,-16(fp)
 b004928:	10800917 	ldw	r2,36(r2)
 b00492c:	e0fffb17 	ldw	r3,-20(fp)
 b004930:	d8c00015 	stw	r3,0(sp)
 b004934:	e1fffe17 	ldw	r7,-8(fp)
 b004938:	e1bffd17 	ldw	r6,-12(fp)
 b00493c:	e17ffa17 	ldw	r5,-24(fp)
 b004940:	e13ffc17 	ldw	r4,-16(fp)
 b004944:	103ee83a 	callr	r2
 b004948:	e0bff715 	stw	r2,-36(fp)
                                                  data_to_write);
            }
          }

          /* Was this the last block? */
          if ((length == data_to_write) || ret_code)
 b00494c:	e0ffff17 	ldw	r3,-4(fp)
 b004950:	e0bffb17 	ldw	r2,-20(fp)
 b004954:	18802e26 	beq	r3,r2,b004a10 <alt_epcs_flash_write+0x248>
 b004958:	e0bff717 	ldw	r2,-36(fp)
 b00495c:	10002c1e 	bne	r2,zero,b004a10 <alt_epcs_flash_write+0x248>
          {
            goto finished;
          }

          length -= data_to_write;
 b004960:	e0ffff17 	ldw	r3,-4(fp)
 b004964:	e0bffb17 	ldw	r2,-20(fp)
 b004968:	1885c83a 	sub	r2,r3,r2
 b00496c:	e0bfff15 	stw	r2,-4(fp)
          offset = current_offset + flash_info->region_info[i].block_size;
 b004970:	e0fffc17 	ldw	r3,-16(fp)
 b004974:	e0bff817 	ldw	r2,-32(fp)
 b004978:	10800104 	addi	r2,r2,4
 b00497c:	1004913a 	slli	r2,r2,4
 b004980:	1885883a 	add	r2,r3,r2
 b004984:	10c00017 	ldw	r3,0(r2)
 b004988:	e0bffa17 	ldw	r2,-24(fp)
 b00498c:	1885883a 	add	r2,r3,r2
 b004990:	e0bffd15 	stw	r2,-12(fp)
          src_addr = (alt_u8*)src_addr + data_to_write;
 b004994:	e0bffb17 	ldw	r2,-20(fp)
 b004998:	e0fffe17 	ldw	r3,-8(fp)
 b00499c:	1885883a 	add	r2,r3,r2
 b0049a0:	e0bffe15 	stw	r2,-8(fp)
        }
        current_offset += flash_info->region_info[i].block_size;
 b0049a4:	e0fffc17 	ldw	r3,-16(fp)
 b0049a8:	e0bff817 	ldw	r2,-32(fp)
 b0049ac:	10800104 	addi	r2,r2,4
 b0049b0:	1004913a 	slli	r2,r2,4
 b0049b4:	1885883a 	add	r2,r3,r2
 b0049b8:	10800017 	ldw	r2,0(r2)
 b0049bc:	e0fffa17 	ldw	r3,-24(fp)
 b0049c0:	1885883a 	add	r2,r3,r2
 b0049c4:	e0bffa15 	stw	r2,-24(fp)
      (offset < (flash_info->region_info[i].offset +
      flash_info->region_info[i].region_size)))
    {
      current_offset = flash_info->region_info[i].offset;

      for(j=0;j<flash_info->region_info[i].number_of_blocks;j++)
 b0049c8:	e0bff917 	ldw	r2,-28(fp)
 b0049cc:	10800044 	addi	r2,r2,1
 b0049d0:	e0bff915 	stw	r2,-28(fp)
 b0049d4:	e0fffc17 	ldw	r3,-16(fp)
 b0049d8:	e0bff817 	ldw	r2,-32(fp)
 b0049dc:	1004913a 	slli	r2,r2,4
 b0049e0:	1885883a 	add	r2,r3,r2
 b0049e4:	10800f04 	addi	r2,r2,60
 b0049e8:	10800017 	ldw	r2,0(r2)
 b0049ec:	e0fff917 	ldw	r3,-28(fp)
 b0049f0:	18bfa016 	blt	r3,r2,b004874 <__alt_mem_flash+0xff003874>
  int         current_offset;

  /*
   * First and foremost which sectors are affected?
   */
  for(i = 0; i < flash_info->number_of_regions; i++)
 b0049f4:	e0bff817 	ldw	r2,-32(fp)
 b0049f8:	10800044 	addi	r2,r2,1
 b0049fc:	e0bff815 	stw	r2,-32(fp)
 b004a00:	e0bffc17 	ldw	r2,-16(fp)
 b004a04:	10800c17 	ldw	r2,48(r2)
 b004a08:	e0fff817 	ldw	r3,-32(fp)
 b004a0c:	18bf7916 	blt	r3,r2,b0047f4 <__alt_mem_flash+0xff0037f4>
      }
    }
  }

finished:
  return ret_code;
 b004a10:	e0bff717 	ldw	r2,-36(fp)
}
 b004a14:	e037883a 	mov	sp,fp
 b004a18:	dfc00117 	ldw	ra,4(sp)
 b004a1c:	df000017 	ldw	fp,0(sp)
 b004a20:	dec00204 	addi	sp,sp,8
 b004a24:	f800283a 	ret

0b004a28 <alt_epcs_flash_get_info>:
 *
 *  Pass the table of erase blocks to the user
 */
int alt_epcs_flash_get_info(alt_flash_fd* fd, flash_region** info,
                            int* number_of_regions)
{
 b004a28:	defffa04 	addi	sp,sp,-24
 b004a2c:	df000515 	stw	fp,20(sp)
 b004a30:	df000504 	addi	fp,sp,20
 b004a34:	e13ffd15 	stw	r4,-12(fp)
 b004a38:	e17ffe15 	stw	r5,-8(fp)
 b004a3c:	e1bfff15 	stw	r6,-4(fp)
  int ret_code = 0;
 b004a40:	e03ffb15 	stw	zero,-20(fp)

  alt_flash_dev* flash = (alt_flash_dev*)fd;
 b004a44:	e0bffd17 	ldw	r2,-12(fp)
 b004a48:	e0bffc15 	stw	r2,-16(fp)

  *number_of_regions = flash->number_of_regions;
 b004a4c:	e0bffc17 	ldw	r2,-16(fp)
 b004a50:	10c00c17 	ldw	r3,48(r2)
 b004a54:	e0bfff17 	ldw	r2,-4(fp)
 b004a58:	10c00015 	stw	r3,0(r2)

  if (!flash->number_of_regions)
 b004a5c:	e0bffc17 	ldw	r2,-16(fp)
 b004a60:	10800c17 	ldw	r2,48(r2)
 b004a64:	1000031e 	bne	r2,zero,b004a74 <alt_epcs_flash_get_info+0x4c>
  {
    ret_code = -EIO;
 b004a68:	00bffec4 	movi	r2,-5
 b004a6c:	e0bffb15 	stw	r2,-20(fp)
 b004a70:	00000b06 	br	b004aa0 <alt_epcs_flash_get_info+0x78>
  }
  else if (flash->number_of_regions > ALT_MAX_NUMBER_OF_FLASH_REGIONS)
 b004a74:	e0bffc17 	ldw	r2,-16(fp)
 b004a78:	10800c17 	ldw	r2,48(r2)
 b004a7c:	10800250 	cmplti	r2,r2,9
 b004a80:	1000031e 	bne	r2,zero,b004a90 <alt_epcs_flash_get_info+0x68>
  {
    ret_code = -ENOMEM;
 b004a84:	00bffd04 	movi	r2,-12
 b004a88:	e0bffb15 	stw	r2,-20(fp)
 b004a8c:	00000406 	br	b004aa0 <alt_epcs_flash_get_info+0x78>
  }
  else
  {
    *info = &flash->region_info[0];
 b004a90:	e0bffc17 	ldw	r2,-16(fp)
 b004a94:	10c00d04 	addi	r3,r2,52
 b004a98:	e0bffe17 	ldw	r2,-8(fp)
 b004a9c:	10c00015 	stw	r3,0(r2)
  }

  return ret_code;
 b004aa0:	e0bffb17 	ldw	r2,-20(fp)
}
 b004aa4:	e037883a 	mov	sp,fp
 b004aa8:	df000017 	ldw	fp,0(sp)
 b004aac:	dec00104 	addi	sp,sp,4
 b004ab0:	f800283a 	ret

0b004ab4 <alt_epcs_test_address>:


/* This might be a candidate for optimization.  Precompute the last-address? */
static ALT_INLINE int alt_epcs_test_address(alt_flash_dev* flash_info, int offset)
{
 b004ab4:	defff904 	addi	sp,sp,-28
 b004ab8:	df000615 	stw	fp,24(sp)
 b004abc:	df000604 	addi	fp,sp,24
 b004ac0:	e13ffe15 	stw	r4,-8(fp)
 b004ac4:	e17fff15 	stw	r5,-4(fp)
  int ret_code = 0;
 b004ac8:	e03ffa15 	stw	zero,-24(fp)
  /* Error checking:
   * if the block offset is outside of the memory, return -EIO.
   */
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;
 b004acc:	e0bffe17 	ldw	r2,-8(fp)
 b004ad0:	e0bffb15 	stw	r2,-20(fp)

  const alt_u32 last_region_index = f->dev.number_of_regions - 1;
 b004ad4:	e0bffb17 	ldw	r2,-20(fp)
 b004ad8:	10800c17 	ldw	r2,48(r2)
 b004adc:	10bfffc4 	addi	r2,r2,-1
 b004ae0:	e0bffc15 	stw	r2,-16(fp)
  alt_u32 last_device_address =
    -1 +
    f->dev.region_info[last_region_index].offset +
 b004ae4:	e0fffb17 	ldw	r3,-20(fp)
 b004ae8:	e0bffc17 	ldw	r2,-16(fp)
 b004aec:	1004913a 	slli	r2,r2,4
 b004af0:	1885883a 	add	r2,r3,r2
 b004af4:	10800d04 	addi	r2,r2,52
 b004af8:	10800017 	ldw	r2,0(r2)
   */
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;

  const alt_u32 last_region_index = f->dev.number_of_regions - 1;
  alt_u32 last_device_address =
    -1 +
 b004afc:	10ffffc4 	addi	r3,r2,-1
    f->dev.region_info[last_region_index].offset +
    f->dev.region_info[last_region_index].region_size;
 b004b00:	e13ffb17 	ldw	r4,-20(fp)
 b004b04:	e0bffc17 	ldw	r2,-16(fp)
 b004b08:	1004913a 	slli	r2,r2,4
 b004b0c:	2085883a 	add	r2,r4,r2
 b004b10:	10800e04 	addi	r2,r2,56
 b004b14:	10800017 	ldw	r2,0(r2)
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;

  const alt_u32 last_region_index = f->dev.number_of_regions - 1;
  alt_u32 last_device_address =
    -1 +
    f->dev.region_info[last_region_index].offset +
 b004b18:	1885883a 	add	r2,r3,r2
   * if the block offset is outside of the memory, return -EIO.
   */
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;

  const alt_u32 last_region_index = f->dev.number_of_regions - 1;
  alt_u32 last_device_address =
 b004b1c:	e0bffd15 	stw	r2,-12(fp)
    -1 +
    f->dev.region_info[last_region_index].offset +
    f->dev.region_info[last_region_index].region_size;

  if (offset > last_device_address)
 b004b20:	e0bfff17 	ldw	r2,-4(fp)
 b004b24:	e0fffd17 	ldw	r3,-12(fp)
 b004b28:	1880022e 	bgeu	r3,r2,b004b34 <alt_epcs_test_address+0x80>
  {
    /* Someone tried to erase a block outside of this device's range. */
    ret_code = -EIO;
 b004b2c:	00bffec4 	movi	r2,-5
 b004b30:	e0bffa15 	stw	r2,-24(fp)
  }
  return ret_code;
 b004b34:	e0bffa17 	ldw	r2,-24(fp)
}
 b004b38:	e037883a 	mov	sp,fp
 b004b3c:	df000017 	ldw	fp,0(sp)
 b004b40:	dec00104 	addi	sp,sp,4
 b004b44:	f800283a 	ret

0b004b48 <alt_epcs_flash_erase_block>:
 *
 * Erase the selected erase block ("sector erase", from the POV
 * of the EPCS data sheet).
 */
int alt_epcs_flash_erase_block(alt_flash_dev* flash_info, int block_offset)
{
 b004b48:	defffa04 	addi	sp,sp,-24
 b004b4c:	dfc00515 	stw	ra,20(sp)
 b004b50:	df000415 	stw	fp,16(sp)
 b004b54:	df000404 	addi	fp,sp,16
 b004b58:	e13ffe15 	stw	r4,-8(fp)
 b004b5c:	e17fff15 	stw	r5,-4(fp)
  int ret_code = 0;
 b004b60:	e03ffc15 	stw	zero,-16(fp)
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;
 b004b64:	e0bffe17 	ldw	r2,-8(fp)
 b004b68:	e0bffd15 	stw	r2,-12(fp)

  ret_code = alt_epcs_test_address(flash_info, block_offset);
 b004b6c:	e17fff17 	ldw	r5,-4(fp)
 b004b70:	e13ffe17 	ldw	r4,-8(fp)
 b004b74:	b004ab40 	call	b004ab4 <alt_epcs_test_address>
 b004b78:	e0bffc15 	stw	r2,-16(fp)

  if (ret_code >= 0)
 b004b7c:	e0bffc17 	ldw	r2,-16(fp)
 b004b80:	10000916 	blt	r2,zero,b004ba8 <alt_epcs_flash_erase_block+0x60>
  {
    /* Send the Sector Erase command, whose 3 address bytes are anywhere
     * within the chosen sector.
     */
    epcs_sector_erase(f->register_base, block_offset, f->four_bytes_mode);
 b004b84:	e0bffd17 	ldw	r2,-12(fp)
 b004b88:	10c02e17 	ldw	r3,184(r2)
 b004b8c:	e13fff17 	ldw	r4,-4(fp)
 b004b90:	e0bffd17 	ldw	r2,-12(fp)
 b004b94:	10803217 	ldw	r2,200(r2)
 b004b98:	100d883a 	mov	r6,r2
 b004b9c:	200b883a 	mov	r5,r4
 b004ba0:	1809883a 	mov	r4,r3
 b004ba4:	b0062bc0 	call	b0062bc <epcs_sector_erase>
  }
  return ret_code;
 b004ba8:	e0bffc17 	ldw	r2,-16(fp)
}
 b004bac:	e037883a 	mov	sp,fp
 b004bb0:	dfc00117 	ldw	ra,4(sp)
 b004bb4:	df000017 	ldw	fp,0(sp)
 b004bb8:	dec00204 	addi	sp,sp,8
 b004bbc:	f800283a 	ret

0b004bc0 <alt_epcs_flash_write_block>:
 * function type compatibility.
 */
int alt_epcs_flash_write_block(alt_flash_dev* flash_info, int block_offset,
                                      int data_offset, const void* data,
                                      int length)
{
 b004bc0:	defff404 	addi	sp,sp,-48
 b004bc4:	dfc00b15 	stw	ra,44(sp)
 b004bc8:	df000a15 	stw	fp,40(sp)
 b004bcc:	df000a04 	addi	fp,sp,40
 b004bd0:	e13ffc15 	stw	r4,-16(fp)
 b004bd4:	e17ffd15 	stw	r5,-12(fp)
 b004bd8:	e1bffe15 	stw	r6,-8(fp)
 b004bdc:	e1ffff15 	stw	r7,-4(fp)
  int ret_code;
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;
 b004be0:	e0bffc17 	ldw	r2,-16(fp)
 b004be4:	e0bff815 	stw	r2,-32(fp)

  int buffer_offset = 0;
 b004be8:	e03ff715 	stw	zero,-36(fp)
  int length_of_current_write;
  ret_code = alt_epcs_test_address(flash_info, data_offset);
 b004bec:	e17ffe17 	ldw	r5,-8(fp)
 b004bf0:	e13ffc17 	ldw	r4,-16(fp)
 b004bf4:	b004ab40 	call	b004ab4 <alt_epcs_test_address>
 b004bf8:	e0bff915 	stw	r2,-28(fp)

  if (ret_code >= 0)
 b004bfc:	e0bff917 	ldw	r2,-28(fp)
 b004c00:	10002916 	blt	r2,zero,b004ca8 <alt_epcs_flash_write_block+0xe8>
  {

    /* "Block" writes must be broken up into the page writes that
     * the device understands.  Partial page writes are allowed.
     */
    while (length)
 b004c04:	00002606 	br	b004ca0 <alt_epcs_flash_write_block+0xe0>
    {
      int next_page_start = (data_offset + f->page_size) & ~(f->page_size - 1);
 b004c08:	e0bff817 	ldw	r2,-32(fp)
 b004c0c:	10c03117 	ldw	r3,196(r2)
 b004c10:	e0bffe17 	ldw	r2,-8(fp)
 b004c14:	1887883a 	add	r3,r3,r2
 b004c18:	e0bff817 	ldw	r2,-32(fp)
 b004c1c:	10803117 	ldw	r2,196(r2)
 b004c20:	0085c83a 	sub	r2,zero,r2
 b004c24:	1884703a 	and	r2,r3,r2
 b004c28:	e0bffa15 	stw	r2,-24(fp)
      length_of_current_write = MIN(length, next_page_start - data_offset);
 b004c2c:	e0fffa17 	ldw	r3,-24(fp)
 b004c30:	e0bffe17 	ldw	r2,-8(fp)
 b004c34:	1885c83a 	sub	r2,r3,r2
 b004c38:	e0c00217 	ldw	r3,8(fp)
 b004c3c:	1880010e 	bge	r3,r2,b004c44 <alt_epcs_flash_write_block+0x84>
 b004c40:	1805883a 	mov	r2,r3
 b004c44:	e0bffb15 	stw	r2,-20(fp)

      epcs_write_buffer(f->register_base, data_offset, &((const alt_u8*)data)[buffer_offset], length_of_current_write,
 b004c48:	e0bff817 	ldw	r2,-32(fp)
 b004c4c:	11002e17 	ldw	r4,184(r2)
 b004c50:	e0bff717 	ldw	r2,-36(fp)
 b004c54:	e0ffff17 	ldw	r3,-4(fp)
 b004c58:	1887883a 	add	r3,r3,r2
 b004c5c:	e0bff817 	ldw	r2,-32(fp)
 b004c60:	10803217 	ldw	r2,200(r2)
 b004c64:	d8800015 	stw	r2,0(sp)
 b004c68:	e1fffb17 	ldw	r7,-20(fp)
 b004c6c:	180d883a 	mov	r6,r3
 b004c70:	e17ffe17 	ldw	r5,-8(fp)
 b004c74:	b00656c0 	call	b00656c <epcs_write_buffer>
          f->four_bytes_mode);

      length -= length_of_current_write;
 b004c78:	e0c00217 	ldw	r3,8(fp)
 b004c7c:	e0bffb17 	ldw	r2,-20(fp)
 b004c80:	1885c83a 	sub	r2,r3,r2
 b004c84:	e0800215 	stw	r2,8(fp)
      buffer_offset += length_of_current_write;
 b004c88:	e0fff717 	ldw	r3,-36(fp)
 b004c8c:	e0bffb17 	ldw	r2,-20(fp)
 b004c90:	1885883a 	add	r2,r3,r2
 b004c94:	e0bff715 	stw	r2,-36(fp)
      data_offset = next_page_start;
 b004c98:	e0bffa17 	ldw	r2,-24(fp)
 b004c9c:	e0bffe15 	stw	r2,-8(fp)
  {

    /* "Block" writes must be broken up into the page writes that
     * the device understands.  Partial page writes are allowed.
     */
    while (length)
 b004ca0:	e0800217 	ldw	r2,8(fp)
 b004ca4:	103fd81e 	bne	r2,zero,b004c08 <__alt_mem_flash+0xff003c08>
      length -= length_of_current_write;
      buffer_offset += length_of_current_write;
      data_offset = next_page_start;
    }
  }
  return ret_code;
 b004ca8:	e0bff917 	ldw	r2,-28(fp)
}
 b004cac:	e037883a 	mov	sp,fp
 b004cb0:	dfc00117 	ldw	ra,4(sp)
 b004cb4:	df000017 	ldw	fp,0(sp)
 b004cb8:	dec00204 	addi	sp,sp,8
 b004cbc:	f800283a 	ret

0b004cc0 <alt_epcs_flash_read>:
 *  to the beginning.  Reads that start beyond the end of the memory are
 *  flagged as errors with EIO (is there a better error code?).
 */
int alt_epcs_flash_read(alt_flash_dev* flash_info, int offset,
                        void* dest_addr, int length)
{
 b004cc0:	defff704 	addi	sp,sp,-36
 b004cc4:	dfc00815 	stw	ra,32(sp)
 b004cc8:	df000715 	stw	fp,28(sp)
 b004ccc:	df000704 	addi	fp,sp,28
 b004cd0:	e13ffc15 	stw	r4,-16(fp)
 b004cd4:	e17ffd15 	stw	r5,-12(fp)
 b004cd8:	e1bffe15 	stw	r6,-8(fp)
 b004cdc:	e1ffff15 	stw	r7,-4(fp)
  int ret_code = 0;
 b004ce0:	e03ffa15 	stw	zero,-24(fp)

  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;
 b004ce4:	e0bffc17 	ldw	r2,-16(fp)
 b004ce8:	e0bffb15 	stw	r2,-20(fp)

  ret_code = alt_epcs_test_address(flash_info, offset);
 b004cec:	e17ffd17 	ldw	r5,-12(fp)
 b004cf0:	e13ffc17 	ldw	r4,-16(fp)
 b004cf4:	b004ab40 	call	b004ab4 <alt_epcs_test_address>
 b004cf8:	e0bffa15 	stw	r2,-24(fp)

  if (ret_code >= 0)
 b004cfc:	e0bffa17 	ldw	r2,-24(fp)
 b004d00:	10000f16 	blt	r2,zero,b004d40 <alt_epcs_flash_read+0x80>
  {
    ret_code = epcs_read_buffer(f->register_base, offset, dest_addr, length,
 b004d04:	e0bffb17 	ldw	r2,-20(fp)
 b004d08:	10c02e17 	ldw	r3,184(r2)
 b004d0c:	e0bffb17 	ldw	r2,-20(fp)
 b004d10:	10803217 	ldw	r2,200(r2)
 b004d14:	d8800015 	stw	r2,0(sp)
 b004d18:	e1ffff17 	ldw	r7,-4(fp)
 b004d1c:	e1bffe17 	ldw	r6,-8(fp)
 b004d20:	e17ffd17 	ldw	r5,-12(fp)
 b004d24:	1809883a 	mov	r4,r3
 b004d28:	b0063b80 	call	b0063b8 <epcs_read_buffer>
 b004d2c:	e0bffa15 	stw	r2,-24(fp)
                                f->four_bytes_mode);

    /* epcs_read_buffer returns the number of buffers read, but
     * alt_epcs_flash_read returns 0 on success, <0 on failure.
     */
    if (ret_code == length)
 b004d30:	e0fffa17 	ldw	r3,-24(fp)
 b004d34:	e0bfff17 	ldw	r2,-4(fp)
 b004d38:	1880011e 	bne	r3,r2,b004d40 <alt_epcs_flash_read+0x80>
    {
      ret_code = 0;
 b004d3c:	e03ffa15 	stw	zero,-24(fp)
    }
  }
  return ret_code;
 b004d40:	e0bffa17 	ldw	r2,-24(fp)
}
 b004d44:	e037883a 	mov	sp,fp
 b004d48:	dfc00117 	ldw	ra,4(sp)
 b004d4c:	df000017 	ldw	fp,0(sp)
 b004d50:	dec00204 	addi	sp,sp,8
 b004d54:	f800283a 	ret

0b004d58 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
 b004d58:	defffa04 	addi	sp,sp,-24
 b004d5c:	dfc00515 	stw	ra,20(sp)
 b004d60:	df000415 	stw	fp,16(sp)
 b004d64:	df000404 	addi	fp,sp,16
 b004d68:	e13ffd15 	stw	r4,-12(fp)
 b004d6c:	e17ffe15 	stw	r5,-8(fp)
 b004d70:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 b004d74:	e0bffd17 	ldw	r2,-12(fp)
 b004d78:	10800017 	ldw	r2,0(r2)
 b004d7c:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
 b004d80:	e0bffc17 	ldw	r2,-16(fp)
 b004d84:	10c00a04 	addi	r3,r2,40
 b004d88:	e0bffd17 	ldw	r2,-12(fp)
 b004d8c:	10800217 	ldw	r2,8(r2)
 b004d90:	100f883a 	mov	r7,r2
 b004d94:	e1bfff17 	ldw	r6,-4(fp)
 b004d98:	e17ffe17 	ldw	r5,-8(fp)
 b004d9c:	1809883a 	mov	r4,r3
 b004da0:	b0053800 	call	b005380 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
 b004da4:	e037883a 	mov	sp,fp
 b004da8:	dfc00117 	ldw	ra,4(sp)
 b004dac:	df000017 	ldw	fp,0(sp)
 b004db0:	dec00204 	addi	sp,sp,8
 b004db4:	f800283a 	ret

0b004db8 <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
 b004db8:	defffa04 	addi	sp,sp,-24
 b004dbc:	dfc00515 	stw	ra,20(sp)
 b004dc0:	df000415 	stw	fp,16(sp)
 b004dc4:	df000404 	addi	fp,sp,16
 b004dc8:	e13ffd15 	stw	r4,-12(fp)
 b004dcc:	e17ffe15 	stw	r5,-8(fp)
 b004dd0:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 b004dd4:	e0bffd17 	ldw	r2,-12(fp)
 b004dd8:	10800017 	ldw	r2,0(r2)
 b004ddc:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
 b004de0:	e0bffc17 	ldw	r2,-16(fp)
 b004de4:	10c00a04 	addi	r3,r2,40
 b004de8:	e0bffd17 	ldw	r2,-12(fp)
 b004dec:	10800217 	ldw	r2,8(r2)
 b004df0:	100f883a 	mov	r7,r2
 b004df4:	e1bfff17 	ldw	r6,-4(fp)
 b004df8:	e17ffe17 	ldw	r5,-8(fp)
 b004dfc:	1809883a 	mov	r4,r3
 b004e00:	b00559c0 	call	b00559c <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
 b004e04:	e037883a 	mov	sp,fp
 b004e08:	dfc00117 	ldw	ra,4(sp)
 b004e0c:	df000017 	ldw	fp,0(sp)
 b004e10:	dec00204 	addi	sp,sp,8
 b004e14:	f800283a 	ret

0b004e18 <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
 b004e18:	defffc04 	addi	sp,sp,-16
 b004e1c:	dfc00315 	stw	ra,12(sp)
 b004e20:	df000215 	stw	fp,8(sp)
 b004e24:	df000204 	addi	fp,sp,8
 b004e28:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 b004e2c:	e0bfff17 	ldw	r2,-4(fp)
 b004e30:	10800017 	ldw	r2,0(r2)
 b004e34:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
 b004e38:	e0bffe17 	ldw	r2,-8(fp)
 b004e3c:	10c00a04 	addi	r3,r2,40
 b004e40:	e0bfff17 	ldw	r2,-4(fp)
 b004e44:	10800217 	ldw	r2,8(r2)
 b004e48:	100b883a 	mov	r5,r2
 b004e4c:	1809883a 	mov	r4,r3
 b004e50:	b0052280 	call	b005228 <altera_avalon_jtag_uart_close>
}
 b004e54:	e037883a 	mov	sp,fp
 b004e58:	dfc00117 	ldw	ra,4(sp)
 b004e5c:	df000017 	ldw	fp,0(sp)
 b004e60:	dec00204 	addi	sp,sp,8
 b004e64:	f800283a 	ret

0b004e68 <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
 b004e68:	defffa04 	addi	sp,sp,-24
 b004e6c:	dfc00515 	stw	ra,20(sp)
 b004e70:	df000415 	stw	fp,16(sp)
 b004e74:	df000404 	addi	fp,sp,16
 b004e78:	e13ffd15 	stw	r4,-12(fp)
 b004e7c:	e17ffe15 	stw	r5,-8(fp)
 b004e80:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
 b004e84:	e0bffd17 	ldw	r2,-12(fp)
 b004e88:	10800017 	ldw	r2,0(r2)
 b004e8c:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
 b004e90:	e0bffc17 	ldw	r2,-16(fp)
 b004e94:	10800a04 	addi	r2,r2,40
 b004e98:	e1bfff17 	ldw	r6,-4(fp)
 b004e9c:	e17ffe17 	ldw	r5,-8(fp)
 b004ea0:	1009883a 	mov	r4,r2
 b004ea4:	b0052900 	call	b005290 <altera_avalon_jtag_uart_ioctl>
}
 b004ea8:	e037883a 	mov	sp,fp
 b004eac:	dfc00117 	ldw	ra,4(sp)
 b004eb0:	df000017 	ldw	fp,0(sp)
 b004eb4:	dec00204 	addi	sp,sp,8
 b004eb8:	f800283a 	ret

0b004ebc <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
 b004ebc:	defffa04 	addi	sp,sp,-24
 b004ec0:	dfc00515 	stw	ra,20(sp)
 b004ec4:	df000415 	stw	fp,16(sp)
 b004ec8:	df000404 	addi	fp,sp,16
 b004ecc:	e13ffd15 	stw	r4,-12(fp)
 b004ed0:	e17ffe15 	stw	r5,-8(fp)
 b004ed4:	e1bfff15 	stw	r6,-4(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
  ALT_SEM_CREATE(&sp->read_lock, 1);
  ALT_SEM_CREATE(&sp->write_lock, 1);

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 b004ed8:	e0bffd17 	ldw	r2,-12(fp)
 b004edc:	00c00044 	movi	r3,1
 b004ee0:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
 b004ee4:	e0bffd17 	ldw	r2,-12(fp)
 b004ee8:	10800017 	ldw	r2,0(r2)
 b004eec:	10800104 	addi	r2,r2,4
 b004ef0:	1007883a 	mov	r3,r2
 b004ef4:	e0bffd17 	ldw	r2,-12(fp)
 b004ef8:	10800817 	ldw	r2,32(r2)
 b004efc:	18800035 	stwio	r2,0(r3)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
 b004f00:	e0bffe17 	ldw	r2,-8(fp)
 b004f04:	e0ffff17 	ldw	r3,-4(fp)
 b004f08:	d8000015 	stw	zero,0(sp)
 b004f0c:	e1fffd17 	ldw	r7,-12(fp)
 b004f10:	0182c034 	movhi	r6,2816
 b004f14:	3193df04 	addi	r6,r6,20348
 b004f18:	180b883a 	mov	r5,r3
 b004f1c:	1009883a 	mov	r4,r2
 b004f20:	b006f180 	call	b006f18 <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
 b004f24:	e0bffd17 	ldw	r2,-12(fp)
 b004f28:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
 b004f2c:	e0bffd17 	ldw	r2,-12(fp)
 b004f30:	10800204 	addi	r2,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 b004f34:	d0e61a17 	ldw	r3,-26520(gp)
 b004f38:	e1fffd17 	ldw	r7,-12(fp)
 b004f3c:	0182c034 	movhi	r6,2816
 b004f40:	31946204 	addi	r6,r6,20872
 b004f44:	180b883a 	mov	r5,r3
 b004f48:	1009883a 	mov	r4,r2
 b004f4c:	b0068280 	call	b006828 <alt_alarm_start>
 b004f50:	1000040e 	bge	r2,zero,b004f64 <altera_avalon_jtag_uart_init+0xa8>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
 b004f54:	e0fffd17 	ldw	r3,-12(fp)
 b004f58:	00a00034 	movhi	r2,32768
 b004f5c:	10bfffc4 	addi	r2,r2,-1
 b004f60:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
 b004f64:	0001883a 	nop
 b004f68:	e037883a 	mov	sp,fp
 b004f6c:	dfc00117 	ldw	ra,4(sp)
 b004f70:	df000017 	ldw	fp,0(sp)
 b004f74:	dec00204 	addi	sp,sp,8
 b004f78:	f800283a 	ret

0b004f7c <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
 b004f7c:	defff804 	addi	sp,sp,-32
 b004f80:	df000715 	stw	fp,28(sp)
 b004f84:	df000704 	addi	fp,sp,28
 b004f88:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
 b004f8c:	e0bfff17 	ldw	r2,-4(fp)
 b004f90:	e0bffb15 	stw	r2,-20(fp)
  unsigned int base = sp->base;
 b004f94:	e0bffb17 	ldw	r2,-20(fp)
 b004f98:	10800017 	ldw	r2,0(r2)
 b004f9c:	e0bffc15 	stw	r2,-16(fp)
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 b004fa0:	e0bffc17 	ldw	r2,-16(fp)
 b004fa4:	10800104 	addi	r2,r2,4
 b004fa8:	10800037 	ldwio	r2,0(r2)
 b004fac:	e0bffd15 	stw	r2,-12(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
 b004fb0:	e0bffd17 	ldw	r2,-12(fp)
 b004fb4:	1080c00c 	andi	r2,r2,768
 b004fb8:	10006d26 	beq	r2,zero,b005170 <altera_avalon_jtag_uart_irq+0x1f4>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
 b004fbc:	e0bffd17 	ldw	r2,-12(fp)
 b004fc0:	1080400c 	andi	r2,r2,256
 b004fc4:	10003526 	beq	r2,zero,b00509c <altera_avalon_jtag_uart_irq+0x120>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
 b004fc8:	00800074 	movhi	r2,1
 b004fcc:	e0bff915 	stw	r2,-28(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 b004fd0:	e0bffb17 	ldw	r2,-20(fp)
 b004fd4:	10800a17 	ldw	r2,40(r2)
 b004fd8:	10800044 	addi	r2,r2,1
 b004fdc:	1081ffcc 	andi	r2,r2,2047
 b004fe0:	e0bffe15 	stw	r2,-8(fp)
        if (next == sp->rx_out)
 b004fe4:	e0bffb17 	ldw	r2,-20(fp)
 b004fe8:	10c00b17 	ldw	r3,44(r2)
 b004fec:	e0bffe17 	ldw	r2,-8(fp)
 b004ff0:	18801526 	beq	r3,r2,b005048 <altera_avalon_jtag_uart_irq+0xcc>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
 b004ff4:	e0bffc17 	ldw	r2,-16(fp)
 b004ff8:	10800037 	ldwio	r2,0(r2)
 b004ffc:	e0bff915 	stw	r2,-28(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
 b005000:	e0bff917 	ldw	r2,-28(fp)
 b005004:	10a0000c 	andi	r2,r2,32768
 b005008:	10001126 	beq	r2,zero,b005050 <altera_avalon_jtag_uart_irq+0xd4>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
 b00500c:	e0bffb17 	ldw	r2,-20(fp)
 b005010:	10800a17 	ldw	r2,40(r2)
 b005014:	e0fff917 	ldw	r3,-28(fp)
 b005018:	1809883a 	mov	r4,r3
 b00501c:	e0fffb17 	ldw	r3,-20(fp)
 b005020:	1885883a 	add	r2,r3,r2
 b005024:	10800e04 	addi	r2,r2,56
 b005028:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 b00502c:	e0bffb17 	ldw	r2,-20(fp)
 b005030:	10800a17 	ldw	r2,40(r2)
 b005034:	10800044 	addi	r2,r2,1
 b005038:	10c1ffcc 	andi	r3,r2,2047
 b00503c:	e0bffb17 	ldw	r2,-20(fp)
 b005040:	10c00a15 	stw	r3,40(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }
 b005044:	003fe206 	br	b004fd0 <__alt_mem_flash+0xff003fd0>
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
        if (next == sp->rx_out)
          break;
 b005048:	0001883a 	nop
 b00504c:	00000106 	br	b005054 <altera_avalon_jtag_uart_irq+0xd8>
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;
 b005050:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
 b005054:	e0bff917 	ldw	r2,-28(fp)
 b005058:	10bfffec 	andhi	r2,r2,65535
 b00505c:	10000f26 	beq	r2,zero,b00509c <altera_avalon_jtag_uart_irq+0x120>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 b005060:	e0bffb17 	ldw	r2,-20(fp)
 b005064:	10c00817 	ldw	r3,32(r2)
 b005068:	00bfff84 	movi	r2,-2
 b00506c:	1886703a 	and	r3,r3,r2
 b005070:	e0bffb17 	ldw	r2,-20(fp)
 b005074:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
 b005078:	e0bffc17 	ldw	r2,-16(fp)
 b00507c:	10800104 	addi	r2,r2,4
 b005080:	1007883a 	mov	r3,r2
 b005084:	e0bffb17 	ldw	r2,-20(fp)
 b005088:	10800817 	ldw	r2,32(r2)
 b00508c:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 b005090:	e0bffc17 	ldw	r2,-16(fp)
 b005094:	10800104 	addi	r2,r2,4
 b005098:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
 b00509c:	e0bffd17 	ldw	r2,-12(fp)
 b0050a0:	1080800c 	andi	r2,r2,512
 b0050a4:	103fbe26 	beq	r2,zero,b004fa0 <__alt_mem_flash+0xff003fa0>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
 b0050a8:	e0bffd17 	ldw	r2,-12(fp)
 b0050ac:	1004d43a 	srli	r2,r2,16
 b0050b0:	e0bffa15 	stw	r2,-24(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
 b0050b4:	00001406 	br	b005108 <altera_avalon_jtag_uart_irq+0x18c>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
 b0050b8:	e0bffc17 	ldw	r2,-16(fp)
 b0050bc:	e0fffb17 	ldw	r3,-20(fp)
 b0050c0:	18c00d17 	ldw	r3,52(r3)
 b0050c4:	e13ffb17 	ldw	r4,-20(fp)
 b0050c8:	20c7883a 	add	r3,r4,r3
 b0050cc:	18c20e04 	addi	r3,r3,2104
 b0050d0:	18c00003 	ldbu	r3,0(r3)
 b0050d4:	18c03fcc 	andi	r3,r3,255
 b0050d8:	18c0201c 	xori	r3,r3,128
 b0050dc:	18ffe004 	addi	r3,r3,-128
 b0050e0:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 b0050e4:	e0bffb17 	ldw	r2,-20(fp)
 b0050e8:	10800d17 	ldw	r2,52(r2)
 b0050ec:	10800044 	addi	r2,r2,1
 b0050f0:	10c1ffcc 	andi	r3,r2,2047
 b0050f4:	e0bffb17 	ldw	r2,-20(fp)
 b0050f8:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
 b0050fc:	e0bffa17 	ldw	r2,-24(fp)
 b005100:	10bfffc4 	addi	r2,r2,-1
 b005104:	e0bffa15 	stw	r2,-24(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
 b005108:	e0bffa17 	ldw	r2,-24(fp)
 b00510c:	10000526 	beq	r2,zero,b005124 <altera_avalon_jtag_uart_irq+0x1a8>
 b005110:	e0bffb17 	ldw	r2,-20(fp)
 b005114:	10c00d17 	ldw	r3,52(r2)
 b005118:	e0bffb17 	ldw	r2,-20(fp)
 b00511c:	10800c17 	ldw	r2,48(r2)
 b005120:	18bfe51e 	bne	r3,r2,b0050b8 <__alt_mem_flash+0xff0040b8>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
 b005124:	e0bffa17 	ldw	r2,-24(fp)
 b005128:	103f9d26 	beq	r2,zero,b004fa0 <__alt_mem_flash+0xff003fa0>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 b00512c:	e0bffb17 	ldw	r2,-20(fp)
 b005130:	10c00817 	ldw	r3,32(r2)
 b005134:	00bfff44 	movi	r2,-3
 b005138:	1886703a 	and	r3,r3,r2
 b00513c:	e0bffb17 	ldw	r2,-20(fp)
 b005140:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 b005144:	e0bffb17 	ldw	r2,-20(fp)
 b005148:	10800017 	ldw	r2,0(r2)
 b00514c:	10800104 	addi	r2,r2,4
 b005150:	1007883a 	mov	r3,r2
 b005154:	e0bffb17 	ldw	r2,-20(fp)
 b005158:	10800817 	ldw	r2,32(r2)
 b00515c:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 b005160:	e0bffc17 	ldw	r2,-16(fp)
 b005164:	10800104 	addi	r2,r2,4
 b005168:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
 b00516c:	003f8c06 	br	b004fa0 <__alt_mem_flash+0xff003fa0>
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
      break;
 b005170:	0001883a 	nop
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
}
 b005174:	0001883a 	nop
 b005178:	e037883a 	mov	sp,fp
 b00517c:	df000017 	ldw	fp,0(sp)
 b005180:	dec00104 	addi	sp,sp,4
 b005184:	f800283a 	ret

0b005188 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
 b005188:	defff804 	addi	sp,sp,-32
 b00518c:	df000715 	stw	fp,28(sp)
 b005190:	df000704 	addi	fp,sp,28
 b005194:	e13ffb15 	stw	r4,-20(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
 b005198:	e0bffb17 	ldw	r2,-20(fp)
 b00519c:	e0bff915 	stw	r2,-28(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
 b0051a0:	e0bff917 	ldw	r2,-28(fp)
 b0051a4:	10800017 	ldw	r2,0(r2)
 b0051a8:	10800104 	addi	r2,r2,4
 b0051ac:	10800037 	ldwio	r2,0(r2)
 b0051b0:	e0bffa15 	stw	r2,-24(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
 b0051b4:	e0bffa17 	ldw	r2,-24(fp)
 b0051b8:	1081000c 	andi	r2,r2,1024
 b0051bc:	10000b26 	beq	r2,zero,b0051ec <altera_avalon_jtag_uart_timeout+0x64>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
 b0051c0:	e0bff917 	ldw	r2,-28(fp)
 b0051c4:	10800017 	ldw	r2,0(r2)
 b0051c8:	10800104 	addi	r2,r2,4
 b0051cc:	1007883a 	mov	r3,r2
 b0051d0:	e0bff917 	ldw	r2,-28(fp)
 b0051d4:	10800817 	ldw	r2,32(r2)
 b0051d8:	10810014 	ori	r2,r2,1024
 b0051dc:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
 b0051e0:	e0bff917 	ldw	r2,-28(fp)
 b0051e4:	10000915 	stw	zero,36(r2)
 b0051e8:	00000a06 	br	b005214 <altera_avalon_jtag_uart_timeout+0x8c>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
 b0051ec:	e0bff917 	ldw	r2,-28(fp)
 b0051f0:	10c00917 	ldw	r3,36(r2)
 b0051f4:	00a00034 	movhi	r2,32768
 b0051f8:	10bfff04 	addi	r2,r2,-4
 b0051fc:	10c00536 	bltu	r2,r3,b005214 <altera_avalon_jtag_uart_timeout+0x8c>
    sp->host_inactive++;
 b005200:	e0bff917 	ldw	r2,-28(fp)
 b005204:	10800917 	ldw	r2,36(r2)
 b005208:	10c00044 	addi	r3,r2,1
 b00520c:	e0bff917 	ldw	r2,-28(fp)
 b005210:	10c00915 	stw	r3,36(r2)
 b005214:	d0a61a17 	ldw	r2,-26520(gp)
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
    }
  }

  return alt_ticks_per_second();
}
 b005218:	e037883a 	mov	sp,fp
 b00521c:	df000017 	ldw	fp,0(sp)
 b005220:	dec00104 	addi	sp,sp,4
 b005224:	f800283a 	ret

0b005228 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
 b005228:	defffd04 	addi	sp,sp,-12
 b00522c:	df000215 	stw	fp,8(sp)
 b005230:	df000204 	addi	fp,sp,8
 b005234:	e13ffe15 	stw	r4,-8(fp)
 b005238:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 b00523c:	00000506 	br	b005254 <altera_avalon_jtag_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
 b005240:	e0bfff17 	ldw	r2,-4(fp)
 b005244:	1090000c 	andi	r2,r2,16384
 b005248:	10000226 	beq	r2,zero,b005254 <altera_avalon_jtag_uart_close+0x2c>
      return -EWOULDBLOCK; 
 b00524c:	00bffd44 	movi	r2,-11
 b005250:	00000b06 	br	b005280 <altera_avalon_jtag_uart_close+0x58>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 b005254:	e0bffe17 	ldw	r2,-8(fp)
 b005258:	10c00d17 	ldw	r3,52(r2)
 b00525c:	e0bffe17 	ldw	r2,-8(fp)
 b005260:	10800c17 	ldw	r2,48(r2)
 b005264:	18800526 	beq	r3,r2,b00527c <altera_avalon_jtag_uart_close+0x54>
 b005268:	e0bffe17 	ldw	r2,-8(fp)
 b00526c:	10c00917 	ldw	r3,36(r2)
 b005270:	e0bffe17 	ldw	r2,-8(fp)
 b005274:	10800117 	ldw	r2,4(r2)
 b005278:	18bff136 	bltu	r3,r2,b005240 <__alt_mem_flash+0xff004240>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
 b00527c:	0005883a 	mov	r2,zero
}
 b005280:	e037883a 	mov	sp,fp
 b005284:	df000017 	ldw	fp,0(sp)
 b005288:	dec00104 	addi	sp,sp,4
 b00528c:	f800283a 	ret

0b005290 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
 b005290:	defffa04 	addi	sp,sp,-24
 b005294:	df000515 	stw	fp,20(sp)
 b005298:	df000504 	addi	fp,sp,20
 b00529c:	e13ffd15 	stw	r4,-12(fp)
 b0052a0:	e17ffe15 	stw	r5,-8(fp)
 b0052a4:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
 b0052a8:	00bff9c4 	movi	r2,-25
 b0052ac:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
 b0052b0:	e0bffe17 	ldw	r2,-8(fp)
 b0052b4:	10da8060 	cmpeqi	r3,r2,27137
 b0052b8:	1800031e 	bne	r3,zero,b0052c8 <altera_avalon_jtag_uart_ioctl+0x38>
 b0052bc:	109a80a0 	cmpeqi	r2,r2,27138
 b0052c0:	1000181e 	bne	r2,zero,b005324 <altera_avalon_jtag_uart_ioctl+0x94>
      rc = 0;
    }
    break;

  default:
    break;
 b0052c4:	00002906 	br	b00536c <altera_avalon_jtag_uart_ioctl+0xdc>

  switch (req)
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
 b0052c8:	e0bffd17 	ldw	r2,-12(fp)
 b0052cc:	10c00117 	ldw	r3,4(r2)
 b0052d0:	00a00034 	movhi	r2,32768
 b0052d4:	10bfffc4 	addi	r2,r2,-1
 b0052d8:	18802126 	beq	r3,r2,b005360 <altera_avalon_jtag_uart_ioctl+0xd0>
    {
      int timeout = *((int *)arg);
 b0052dc:	e0bfff17 	ldw	r2,-4(fp)
 b0052e0:	10800017 	ldw	r2,0(r2)
 b0052e4:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
 b0052e8:	e0bffc17 	ldw	r2,-16(fp)
 b0052ec:	10800090 	cmplti	r2,r2,2
 b0052f0:	1000061e 	bne	r2,zero,b00530c <altera_avalon_jtag_uart_ioctl+0x7c>
 b0052f4:	e0fffc17 	ldw	r3,-16(fp)
 b0052f8:	00a00034 	movhi	r2,32768
 b0052fc:	10bfffc4 	addi	r2,r2,-1
 b005300:	18800226 	beq	r3,r2,b00530c <altera_avalon_jtag_uart_ioctl+0x7c>
 b005304:	e0bffc17 	ldw	r2,-16(fp)
 b005308:	00000206 	br	b005314 <altera_avalon_jtag_uart_ioctl+0x84>
 b00530c:	00a00034 	movhi	r2,32768
 b005310:	10bfff84 	addi	r2,r2,-2
 b005314:	e0fffd17 	ldw	r3,-12(fp)
 b005318:	18800115 	stw	r2,4(r3)
      rc = 0;
 b00531c:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
 b005320:	00000f06 	br	b005360 <altera_avalon_jtag_uart_ioctl+0xd0>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
 b005324:	e0bffd17 	ldw	r2,-12(fp)
 b005328:	10c00117 	ldw	r3,4(r2)
 b00532c:	00a00034 	movhi	r2,32768
 b005330:	10bfffc4 	addi	r2,r2,-1
 b005334:	18800c26 	beq	r3,r2,b005368 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
 b005338:	e0bffd17 	ldw	r2,-12(fp)
 b00533c:	10c00917 	ldw	r3,36(r2)
 b005340:	e0bffd17 	ldw	r2,-12(fp)
 b005344:	10800117 	ldw	r2,4(r2)
 b005348:	1885803a 	cmpltu	r2,r3,r2
 b00534c:	10c03fcc 	andi	r3,r2,255
 b005350:	e0bfff17 	ldw	r2,-4(fp)
 b005354:	10c00015 	stw	r3,0(r2)
      rc = 0;
 b005358:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
 b00535c:	00000206 	br	b005368 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
      rc = 0;
    }
    break;
 b005360:	0001883a 	nop
 b005364:	00000106 	br	b00536c <altera_avalon_jtag_uart_ioctl+0xdc>
    if (sp->timeout != INT_MAX)
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
      rc = 0;
    }
    break;
 b005368:	0001883a 	nop

  default:
    break;
  }

  return rc;
 b00536c:	e0bffb17 	ldw	r2,-20(fp)
}
 b005370:	e037883a 	mov	sp,fp
 b005374:	df000017 	ldw	fp,0(sp)
 b005378:	dec00104 	addi	sp,sp,4
 b00537c:	f800283a 	ret

0b005380 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
 b005380:	defff304 	addi	sp,sp,-52
 b005384:	dfc00c15 	stw	ra,48(sp)
 b005388:	df000b15 	stw	fp,44(sp)
 b00538c:	df000b04 	addi	fp,sp,44
 b005390:	e13ffc15 	stw	r4,-16(fp)
 b005394:	e17ffd15 	stw	r5,-12(fp)
 b005398:	e1bffe15 	stw	r6,-8(fp)
 b00539c:	e1ffff15 	stw	r7,-4(fp)
  char * ptr = buffer;
 b0053a0:	e0bffd17 	ldw	r2,-12(fp)
 b0053a4:	e0bff515 	stw	r2,-44(fp)
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
 b0053a8:	00004706 	br	b0054c8 <altera_avalon_jtag_uart_read+0x148>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
 b0053ac:	e0bffc17 	ldw	r2,-16(fp)
 b0053b0:	10800a17 	ldw	r2,40(r2)
 b0053b4:	e0bff715 	stw	r2,-36(fp)
      out = sp->rx_out;
 b0053b8:	e0bffc17 	ldw	r2,-16(fp)
 b0053bc:	10800b17 	ldw	r2,44(r2)
 b0053c0:	e0bff815 	stw	r2,-32(fp)

      if (in >= out)
 b0053c4:	e0fff717 	ldw	r3,-36(fp)
 b0053c8:	e0bff817 	ldw	r2,-32(fp)
 b0053cc:	18800536 	bltu	r3,r2,b0053e4 <altera_avalon_jtag_uart_read+0x64>
        n = in - out;
 b0053d0:	e0fff717 	ldw	r3,-36(fp)
 b0053d4:	e0bff817 	ldw	r2,-32(fp)
 b0053d8:	1885c83a 	sub	r2,r3,r2
 b0053dc:	e0bff615 	stw	r2,-40(fp)
 b0053e0:	00000406 	br	b0053f4 <altera_avalon_jtag_uart_read+0x74>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
 b0053e4:	00c20004 	movi	r3,2048
 b0053e8:	e0bff817 	ldw	r2,-32(fp)
 b0053ec:	1885c83a 	sub	r2,r3,r2
 b0053f0:	e0bff615 	stw	r2,-40(fp)

      if (n == 0)
 b0053f4:	e0bff617 	ldw	r2,-40(fp)
 b0053f8:	10001e26 	beq	r2,zero,b005474 <altera_avalon_jtag_uart_read+0xf4>
        break; /* No more data available */

      if (n > space)
 b0053fc:	e0fffe17 	ldw	r3,-8(fp)
 b005400:	e0bff617 	ldw	r2,-40(fp)
 b005404:	1880022e 	bgeu	r3,r2,b005410 <altera_avalon_jtag_uart_read+0x90>
        n = space;
 b005408:	e0bffe17 	ldw	r2,-8(fp)
 b00540c:	e0bff615 	stw	r2,-40(fp)

      memcpy(ptr, sp->rx_buf + out, n);
 b005410:	e0bffc17 	ldw	r2,-16(fp)
 b005414:	10c00e04 	addi	r3,r2,56
 b005418:	e0bff817 	ldw	r2,-32(fp)
 b00541c:	1885883a 	add	r2,r3,r2
 b005420:	e1bff617 	ldw	r6,-40(fp)
 b005424:	100b883a 	mov	r5,r2
 b005428:	e13ff517 	ldw	r4,-44(fp)
 b00542c:	b007d140 	call	b007d14 <memcpy>
      ptr   += n;
 b005430:	e0fff517 	ldw	r3,-44(fp)
 b005434:	e0bff617 	ldw	r2,-40(fp)
 b005438:	1885883a 	add	r2,r3,r2
 b00543c:	e0bff515 	stw	r2,-44(fp)
      space -= n;
 b005440:	e0fffe17 	ldw	r3,-8(fp)
 b005444:	e0bff617 	ldw	r2,-40(fp)
 b005448:	1885c83a 	sub	r2,r3,r2
 b00544c:	e0bffe15 	stw	r2,-8(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 b005450:	e0fff817 	ldw	r3,-32(fp)
 b005454:	e0bff617 	ldw	r2,-40(fp)
 b005458:	1885883a 	add	r2,r3,r2
 b00545c:	10c1ffcc 	andi	r3,r2,2047
 b005460:	e0bffc17 	ldw	r2,-16(fp)
 b005464:	10c00b15 	stw	r3,44(r2)
    }
    while (space > 0);
 b005468:	e0bffe17 	ldw	r2,-8(fp)
 b00546c:	00bfcf16 	blt	zero,r2,b0053ac <__alt_mem_flash+0xff0043ac>
 b005470:	00000106 	br	b005478 <altera_avalon_jtag_uart_read+0xf8>
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;

      if (n == 0)
        break; /* No more data available */
 b005474:	0001883a 	nop
      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
 b005478:	e0fff517 	ldw	r3,-44(fp)
 b00547c:	e0bffd17 	ldw	r2,-12(fp)
 b005480:	1880141e 	bne	r3,r2,b0054d4 <altera_avalon_jtag_uart_read+0x154>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
 b005484:	e0bfff17 	ldw	r2,-4(fp)
 b005488:	1090000c 	andi	r2,r2,16384
 b00548c:	1000131e 	bne	r2,zero,b0054dc <altera_avalon_jtag_uart_read+0x15c>
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
        ;
    }
#else
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
 b005490:	0001883a 	nop
 b005494:	e0bffc17 	ldw	r2,-16(fp)
 b005498:	10c00a17 	ldw	r3,40(r2)
 b00549c:	e0bff717 	ldw	r2,-36(fp)
 b0054a0:	1880051e 	bne	r3,r2,b0054b8 <altera_avalon_jtag_uart_read+0x138>
 b0054a4:	e0bffc17 	ldw	r2,-16(fp)
 b0054a8:	10c00917 	ldw	r3,36(r2)
 b0054ac:	e0bffc17 	ldw	r2,-16(fp)
 b0054b0:	10800117 	ldw	r2,4(r2)
 b0054b4:	18bff736 	bltu	r3,r2,b005494 <__alt_mem_flash+0xff004494>
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
 b0054b8:	e0bffc17 	ldw	r2,-16(fp)
 b0054bc:	10c00a17 	ldw	r3,40(r2)
 b0054c0:	e0bff717 	ldw	r2,-36(fp)
 b0054c4:	18800726 	beq	r3,r2,b0054e4 <altera_avalon_jtag_uart_read+0x164>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
 b0054c8:	e0bffe17 	ldw	r2,-8(fp)
 b0054cc:	00bfb716 	blt	zero,r2,b0053ac <__alt_mem_flash+0xff0043ac>
 b0054d0:	00000506 	br	b0054e8 <altera_avalon_jtag_uart_read+0x168>
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
      break;
 b0054d4:	0001883a 	nop
 b0054d8:	00000306 	br	b0054e8 <altera_avalon_jtag_uart_read+0x168>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
      break;
 b0054dc:	0001883a 	nop
 b0054e0:	00000106 	br	b0054e8 <altera_avalon_jtag_uart_read+0x168>
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
      break;
 b0054e4:	0001883a 	nop
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);

  if (ptr != buffer)
 b0054e8:	e0fff517 	ldw	r3,-44(fp)
 b0054ec:	e0bffd17 	ldw	r2,-12(fp)
 b0054f0:	18801826 	beq	r3,r2,b005554 <altera_avalon_jtag_uart_read+0x1d4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 b0054f4:	0005303a 	rdctl	r2,status
 b0054f8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 b0054fc:	e0fffb17 	ldw	r3,-20(fp)
 b005500:	00bfff84 	movi	r2,-2
 b005504:	1884703a 	and	r2,r3,r2
 b005508:	1001703a 	wrctl	status,r2
  
  return context;
 b00550c:	e0bffb17 	ldw	r2,-20(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
 b005510:	e0bffa15 	stw	r2,-24(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 b005514:	e0bffc17 	ldw	r2,-16(fp)
 b005518:	10800817 	ldw	r2,32(r2)
 b00551c:	10c00054 	ori	r3,r2,1
 b005520:	e0bffc17 	ldw	r2,-16(fp)
 b005524:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 b005528:	e0bffc17 	ldw	r2,-16(fp)
 b00552c:	10800017 	ldw	r2,0(r2)
 b005530:	10800104 	addi	r2,r2,4
 b005534:	1007883a 	mov	r3,r2
 b005538:	e0bffc17 	ldw	r2,-16(fp)
 b00553c:	10800817 	ldw	r2,32(r2)
 b005540:	18800035 	stwio	r2,0(r3)
 b005544:	e0bffa17 	ldw	r2,-24(fp)
 b005548:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 b00554c:	e0bff917 	ldw	r2,-28(fp)
 b005550:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
 b005554:	e0fff517 	ldw	r3,-44(fp)
 b005558:	e0bffd17 	ldw	r2,-12(fp)
 b00555c:	18800426 	beq	r3,r2,b005570 <altera_avalon_jtag_uart_read+0x1f0>
    return ptr - buffer;
 b005560:	e0fff517 	ldw	r3,-44(fp)
 b005564:	e0bffd17 	ldw	r2,-12(fp)
 b005568:	1885c83a 	sub	r2,r3,r2
 b00556c:	00000606 	br	b005588 <altera_avalon_jtag_uart_read+0x208>
  else if (flags & O_NONBLOCK)
 b005570:	e0bfff17 	ldw	r2,-4(fp)
 b005574:	1090000c 	andi	r2,r2,16384
 b005578:	10000226 	beq	r2,zero,b005584 <altera_avalon_jtag_uart_read+0x204>
    return -EWOULDBLOCK;
 b00557c:	00bffd44 	movi	r2,-11
 b005580:	00000106 	br	b005588 <altera_avalon_jtag_uart_read+0x208>
  else
    return -EIO;
 b005584:	00bffec4 	movi	r2,-5
}
 b005588:	e037883a 	mov	sp,fp
 b00558c:	dfc00117 	ldw	ra,4(sp)
 b005590:	df000017 	ldw	fp,0(sp)
 b005594:	dec00204 	addi	sp,sp,8
 b005598:	f800283a 	ret

0b00559c <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
 b00559c:	defff304 	addi	sp,sp,-52
 b0055a0:	dfc00c15 	stw	ra,48(sp)
 b0055a4:	df000b15 	stw	fp,44(sp)
 b0055a8:	df000b04 	addi	fp,sp,44
 b0055ac:	e13ffc15 	stw	r4,-16(fp)
 b0055b0:	e17ffd15 	stw	r5,-12(fp)
 b0055b4:	e1bffe15 	stw	r6,-8(fp)
 b0055b8:	e1ffff15 	stw	r7,-4(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
 b0055bc:	e03ff515 	stw	zero,-44(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
 b0055c0:	e0bffd17 	ldw	r2,-12(fp)
 b0055c4:	e0bff715 	stw	r2,-36(fp)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 b0055c8:	00003706 	br	b0056a8 <altera_avalon_jtag_uart_write+0x10c>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
 b0055cc:	e0bffc17 	ldw	r2,-16(fp)
 b0055d0:	10800c17 	ldw	r2,48(r2)
 b0055d4:	e0bff915 	stw	r2,-28(fp)
      out = sp->tx_out;
 b0055d8:	e0bffc17 	ldw	r2,-16(fp)
 b0055dc:	10800d17 	ldw	r2,52(r2)
 b0055e0:	e0bff515 	stw	r2,-44(fp)

      if (in < out)
 b0055e4:	e0fff917 	ldw	r3,-28(fp)
 b0055e8:	e0bff517 	ldw	r2,-44(fp)
 b0055ec:	1880062e 	bgeu	r3,r2,b005608 <altera_avalon_jtag_uart_write+0x6c>
        n = out - 1 - in;
 b0055f0:	e0fff517 	ldw	r3,-44(fp)
 b0055f4:	e0bff917 	ldw	r2,-28(fp)
 b0055f8:	1885c83a 	sub	r2,r3,r2
 b0055fc:	10bfffc4 	addi	r2,r2,-1
 b005600:	e0bff615 	stw	r2,-40(fp)
 b005604:	00000b06 	br	b005634 <altera_avalon_jtag_uart_write+0x98>
      else if (out > 0)
 b005608:	e0bff517 	ldw	r2,-44(fp)
 b00560c:	10000526 	beq	r2,zero,b005624 <altera_avalon_jtag_uart_write+0x88>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
 b005610:	00c20004 	movi	r3,2048
 b005614:	e0bff917 	ldw	r2,-28(fp)
 b005618:	1885c83a 	sub	r2,r3,r2
 b00561c:	e0bff615 	stw	r2,-40(fp)
 b005620:	00000406 	br	b005634 <altera_avalon_jtag_uart_write+0x98>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
 b005624:	00c1ffc4 	movi	r3,2047
 b005628:	e0bff917 	ldw	r2,-28(fp)
 b00562c:	1885c83a 	sub	r2,r3,r2
 b005630:	e0bff615 	stw	r2,-40(fp)

      if (n == 0)
 b005634:	e0bff617 	ldw	r2,-40(fp)
 b005638:	10001e26 	beq	r2,zero,b0056b4 <altera_avalon_jtag_uart_write+0x118>
        break;

      if (n > count)
 b00563c:	e0fffe17 	ldw	r3,-8(fp)
 b005640:	e0bff617 	ldw	r2,-40(fp)
 b005644:	1880022e 	bgeu	r3,r2,b005650 <altera_avalon_jtag_uart_write+0xb4>
        n = count;
 b005648:	e0bffe17 	ldw	r2,-8(fp)
 b00564c:	e0bff615 	stw	r2,-40(fp)

      memcpy(sp->tx_buf + in, ptr, n);
 b005650:	e0bffc17 	ldw	r2,-16(fp)
 b005654:	10c20e04 	addi	r3,r2,2104
 b005658:	e0bff917 	ldw	r2,-28(fp)
 b00565c:	1885883a 	add	r2,r3,r2
 b005660:	e1bff617 	ldw	r6,-40(fp)
 b005664:	e17ffd17 	ldw	r5,-12(fp)
 b005668:	1009883a 	mov	r4,r2
 b00566c:	b007d140 	call	b007d14 <memcpy>
      ptr   += n;
 b005670:	e0fffd17 	ldw	r3,-12(fp)
 b005674:	e0bff617 	ldw	r2,-40(fp)
 b005678:	1885883a 	add	r2,r3,r2
 b00567c:	e0bffd15 	stw	r2,-12(fp)
      count -= n;
 b005680:	e0fffe17 	ldw	r3,-8(fp)
 b005684:	e0bff617 	ldw	r2,-40(fp)
 b005688:	1885c83a 	sub	r2,r3,r2
 b00568c:	e0bffe15 	stw	r2,-8(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 b005690:	e0fff917 	ldw	r3,-28(fp)
 b005694:	e0bff617 	ldw	r2,-40(fp)
 b005698:	1885883a 	add	r2,r3,r2
 b00569c:	10c1ffcc 	andi	r3,r2,2047
 b0056a0:	e0bffc17 	ldw	r2,-16(fp)
 b0056a4:	10c00c15 	stw	r3,48(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 b0056a8:	e0bffe17 	ldw	r2,-8(fp)
 b0056ac:	00bfc716 	blt	zero,r2,b0055cc <__alt_mem_flash+0xff0045cc>
 b0056b0:	00000106 	br	b0056b8 <altera_avalon_jtag_uart_write+0x11c>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;

      if (n == 0)
        break;
 b0056b4:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 b0056b8:	0005303a 	rdctl	r2,status
 b0056bc:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 b0056c0:	e0fffb17 	ldw	r3,-20(fp)
 b0056c4:	00bfff84 	movi	r2,-2
 b0056c8:	1884703a 	and	r2,r3,r2
 b0056cc:	1001703a 	wrctl	status,r2
  
  return context;
 b0056d0:	e0bffb17 	ldw	r2,-20(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
 b0056d4:	e0bffa15 	stw	r2,-24(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 b0056d8:	e0bffc17 	ldw	r2,-16(fp)
 b0056dc:	10800817 	ldw	r2,32(r2)
 b0056e0:	10c00094 	ori	r3,r2,2
 b0056e4:	e0bffc17 	ldw	r2,-16(fp)
 b0056e8:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 b0056ec:	e0bffc17 	ldw	r2,-16(fp)
 b0056f0:	10800017 	ldw	r2,0(r2)
 b0056f4:	10800104 	addi	r2,r2,4
 b0056f8:	1007883a 	mov	r3,r2
 b0056fc:	e0bffc17 	ldw	r2,-16(fp)
 b005700:	10800817 	ldw	r2,32(r2)
 b005704:	18800035 	stwio	r2,0(r3)
 b005708:	e0bffa17 	ldw	r2,-24(fp)
 b00570c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 b005710:	e0bff817 	ldw	r2,-32(fp)
 b005714:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
 b005718:	e0bffe17 	ldw	r2,-8(fp)
 b00571c:	0080100e 	bge	zero,r2,b005760 <altera_avalon_jtag_uart_write+0x1c4>
    {
      if (flags & O_NONBLOCK)
 b005720:	e0bfff17 	ldw	r2,-4(fp)
 b005724:	1090000c 	andi	r2,r2,16384
 b005728:	1000101e 	bne	r2,zero,b00576c <altera_avalon_jtag_uart_write+0x1d0>
      /*
       * No OS present: Always wait for data to be removed from buffer.  Once
       * the interrupt routine has removed some data then we will be able to
       * insert some more.
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
 b00572c:	0001883a 	nop
 b005730:	e0bffc17 	ldw	r2,-16(fp)
 b005734:	10c00d17 	ldw	r3,52(r2)
 b005738:	e0bff517 	ldw	r2,-44(fp)
 b00573c:	1880051e 	bne	r3,r2,b005754 <altera_avalon_jtag_uart_write+0x1b8>
 b005740:	e0bffc17 	ldw	r2,-16(fp)
 b005744:	10c00917 	ldw	r3,36(r2)
 b005748:	e0bffc17 	ldw	r2,-16(fp)
 b00574c:	10800117 	ldw	r2,4(r2)
 b005750:	18bff736 	bltu	r3,r2,b005730 <__alt_mem_flash+0xff004730>
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
 b005754:	e0bffc17 	ldw	r2,-16(fp)
 b005758:	10800917 	ldw	r2,36(r2)
 b00575c:	1000051e 	bne	r2,zero,b005774 <altera_avalon_jtag_uart_write+0x1d8>
         break;
    }
  }
  while (count > 0);
 b005760:	e0bffe17 	ldw	r2,-8(fp)
 b005764:	00bfd016 	blt	zero,r2,b0056a8 <__alt_mem_flash+0xff0046a8>
 b005768:	00000306 	br	b005778 <altera_avalon_jtag_uart_write+0x1dc>
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
        break;
 b00576c:	0001883a 	nop
 b005770:	00000106 	br	b005778 <altera_avalon_jtag_uart_write+0x1dc>
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
         break;
 b005774:	0001883a 	nop
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);

  if (ptr != start)
 b005778:	e0fffd17 	ldw	r3,-12(fp)
 b00577c:	e0bff717 	ldw	r2,-36(fp)
 b005780:	18800426 	beq	r3,r2,b005794 <altera_avalon_jtag_uart_write+0x1f8>
    return ptr - start;
 b005784:	e0fffd17 	ldw	r3,-12(fp)
 b005788:	e0bff717 	ldw	r2,-36(fp)
 b00578c:	1885c83a 	sub	r2,r3,r2
 b005790:	00000606 	br	b0057ac <altera_avalon_jtag_uart_write+0x210>
  else if (flags & O_NONBLOCK)
 b005794:	e0bfff17 	ldw	r2,-4(fp)
 b005798:	1090000c 	andi	r2,r2,16384
 b00579c:	10000226 	beq	r2,zero,b0057a8 <altera_avalon_jtag_uart_write+0x20c>
    return -EWOULDBLOCK;
 b0057a0:	00bffd44 	movi	r2,-11
 b0057a4:	00000106 	br	b0057ac <altera_avalon_jtag_uart_write+0x210>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
 b0057a8:	00bffec4 	movi	r2,-5
}
 b0057ac:	e037883a 	mov	sp,fp
 b0057b0:	dfc00117 	ldw	ra,4(sp)
 b0057b4:	df000017 	ldw	fp,0(sp)
 b0057b8:	dec00204 	addi	sp,sp,8
 b0057bc:	f800283a 	ret

0b0057c0 <altera_avalon_uart_read_fd>:
 *
 */

int 
altera_avalon_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
 b0057c0:	defffa04 	addi	sp,sp,-24
 b0057c4:	dfc00515 	stw	ra,20(sp)
 b0057c8:	df000415 	stw	fp,16(sp)
 b0057cc:	df000404 	addi	fp,sp,16
 b0057d0:	e13ffd15 	stw	r4,-12(fp)
 b0057d4:	e17ffe15 	stw	r5,-8(fp)
 b0057d8:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
 b0057dc:	e0bffd17 	ldw	r2,-12(fp)
 b0057e0:	10800017 	ldw	r2,0(r2)
 b0057e4:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_read(&dev->state, buffer, space,
 b0057e8:	e0bffc17 	ldw	r2,-16(fp)
 b0057ec:	10c00a04 	addi	r3,r2,40
 b0057f0:	e0bffd17 	ldw	r2,-12(fp)
 b0057f4:	10800217 	ldw	r2,8(r2)
 b0057f8:	100f883a 	mov	r7,r2
 b0057fc:	e1bfff17 	ldw	r6,-4(fp)
 b005800:	e17ffe17 	ldw	r5,-8(fp)
 b005804:	1809883a 	mov	r4,r3
 b005808:	b005cd40 	call	b005cd4 <altera_avalon_uart_read>
      fd->fd_flags);
}
 b00580c:	e037883a 	mov	sp,fp
 b005810:	dfc00117 	ldw	ra,4(sp)
 b005814:	df000017 	ldw	fp,0(sp)
 b005818:	dec00204 	addi	sp,sp,8
 b00581c:	f800283a 	ret

0b005820 <altera_avalon_uart_write_fd>:

int 
altera_avalon_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
 b005820:	defffa04 	addi	sp,sp,-24
 b005824:	dfc00515 	stw	ra,20(sp)
 b005828:	df000415 	stw	fp,16(sp)
 b00582c:	df000404 	addi	fp,sp,16
 b005830:	e13ffd15 	stw	r4,-12(fp)
 b005834:	e17ffe15 	stw	r5,-8(fp)
 b005838:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
 b00583c:	e0bffd17 	ldw	r2,-12(fp)
 b005840:	10800017 	ldw	r2,0(r2)
 b005844:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_write(&dev->state, buffer, space,
 b005848:	e0bffc17 	ldw	r2,-16(fp)
 b00584c:	10c00a04 	addi	r3,r2,40
 b005850:	e0bffd17 	ldw	r2,-12(fp)
 b005854:	10800217 	ldw	r2,8(r2)
 b005858:	100f883a 	mov	r7,r2
 b00585c:	e1bfff17 	ldw	r6,-4(fp)
 b005860:	e17ffe17 	ldw	r5,-8(fp)
 b005864:	1809883a 	mov	r4,r3
 b005868:	b005eec0 	call	b005eec <altera_avalon_uart_write>
      fd->fd_flags);
}
 b00586c:	e037883a 	mov	sp,fp
 b005870:	dfc00117 	ldw	ra,4(sp)
 b005874:	df000017 	ldw	fp,0(sp)
 b005878:	dec00204 	addi	sp,sp,8
 b00587c:	f800283a 	ret

0b005880 <altera_avalon_uart_close_fd>:

#endif /* ALTERA_AVALON_UART_USE_IOCTL */

int 
altera_avalon_uart_close_fd(alt_fd* fd)
{
 b005880:	defffc04 	addi	sp,sp,-16
 b005884:	dfc00315 	stw	ra,12(sp)
 b005888:	df000215 	stw	fp,8(sp)
 b00588c:	df000204 	addi	fp,sp,8
 b005890:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
 b005894:	e0bfff17 	ldw	r2,-4(fp)
 b005898:	10800017 	ldw	r2,0(r2)
 b00589c:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_uart_close(&dev->state, fd->fd_flags);
 b0058a0:	e0bffe17 	ldw	r2,-8(fp)
 b0058a4:	10c00a04 	addi	r3,r2,40
 b0058a8:	e0bfff17 	ldw	r2,-4(fp)
 b0058ac:	10800217 	ldw	r2,8(r2)
 b0058b0:	100b883a 	mov	r5,r2
 b0058b4:	1809883a 	mov	r4,r3
 b0058b8:	b005c440 	call	b005c44 <altera_avalon_uart_close>
}
 b0058bc:	e037883a 	mov	sp,fp
 b0058c0:	dfc00117 	ldw	ra,4(sp)
 b0058c4:	df000017 	ldw	fp,0(sp)
 b0058c8:	dec00204 	addi	sp,sp,8
 b0058cc:	f800283a 	ret

0b0058d0 <altera_avalon_uart_init>:
  alt_u32 status);

void 
altera_avalon_uart_init(altera_avalon_uart_state* sp, 
  alt_u32 irq_controller_id,  alt_u32 irq)
{
 b0058d0:	defff804 	addi	sp,sp,-32
 b0058d4:	dfc00715 	stw	ra,28(sp)
 b0058d8:	df000615 	stw	fp,24(sp)
 b0058dc:	df000604 	addi	fp,sp,24
 b0058e0:	e13ffd15 	stw	r4,-12(fp)
 b0058e4:	e17ffe15 	stw	r5,-8(fp)
 b0058e8:	e1bfff15 	stw	r6,-4(fp)
  void* base = sp->base;
 b0058ec:	e0bffd17 	ldw	r2,-12(fp)
 b0058f0:	10800017 	ldw	r2,0(r2)
 b0058f4:	e0bffb15 	stw	r2,-20(fp)
 * HAL.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_no_error (void)
{
  return 0;
 b0058f8:	0005883a 	mov	r2,zero
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
 b0058fc:	1000041e 	bne	r2,zero,b005910 <altera_avalon_uart_init+0x40>
 b005900:	0005883a 	mov	r2,zero
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
 b005904:	1000021e 	bne	r2,zero,b005910 <altera_avalon_uart_init+0x40>
 b005908:	0005883a 	mov	r2,zero
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
 b00590c:	10000226 	beq	r2,zero,b005918 <altera_avalon_uart_init+0x48>
 b005910:	00800044 	movi	r2,1
 b005914:	00000106 	br	b00591c <altera_avalon_uart_init+0x4c>
 b005918:	0005883a 	mov	r2,zero
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
 b00591c:	e0bffc15 	stw	r2,-16(fp)
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);

  if (!error)
 b005920:	e0bffc17 	ldw	r2,-16(fp)
 b005924:	10000f1e 	bne	r2,zero,b005964 <altera_avalon_uart_init+0x94>
  {
    /* enable interrupts at the device */
    sp->ctrl = ALTERA_AVALON_UART_CONTROL_RTS_MSK  |
 b005928:	e0bffd17 	ldw	r2,-12(fp)
 b00592c:	00c32004 	movi	r3,3200
 b005930:	10c00115 	stw	r3,4(r2)
                ALTERA_AVALON_UART_CONTROL_RRDY_MSK |
                ALTERA_AVALON_UART_CONTROL_DCTS_MSK;

    IOWR_ALTERA_AVALON_UART_CONTROL(base, sp->ctrl); 
 b005934:	e0bffb17 	ldw	r2,-20(fp)
 b005938:	10800304 	addi	r2,r2,12
 b00593c:	e0fffd17 	ldw	r3,-12(fp)
 b005940:	18c00117 	ldw	r3,4(r3)
 b005944:	10c00035 	stwio	r3,0(r2)
  
    /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
    alt_ic_isr_register(irq_controller_id, irq, altera_avalon_uart_irq, sp, 
 b005948:	d8000015 	stw	zero,0(sp)
 b00594c:	e1fffd17 	ldw	r7,-12(fp)
 b005950:	0182c034 	movhi	r6,2816
 b005954:	31965f04 	addi	r6,r6,22908
 b005958:	e17fff17 	ldw	r5,-4(fp)
 b00595c:	e13ffe17 	ldw	r4,-8(fp)
 b005960:	b006f180 	call	b006f18 <alt_ic_isr_register>
      0x0);
#else
    alt_irq_register (irq, sp, altera_avalon_uart_irq);
#endif  
  }
}
 b005964:	0001883a 	nop
 b005968:	e037883a 	mov	sp,fp
 b00596c:	dfc00117 	ldw	ra,4(sp)
 b005970:	df000017 	ldw	fp,0(sp)
 b005974:	dec00204 	addi	sp,sp,8
 b005978:	f800283a 	ret

0b00597c <altera_avalon_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_uart_irq(void* context)
#else
static void altera_avalon_uart_irq(void* context, alt_u32 id)
#endif
{
 b00597c:	defffa04 	addi	sp,sp,-24
 b005980:	dfc00515 	stw	ra,20(sp)
 b005984:	df000415 	stw	fp,16(sp)
 b005988:	df000404 	addi	fp,sp,16
 b00598c:	e13fff15 	stw	r4,-4(fp)
  alt_u32 status;

  altera_avalon_uart_state* sp = (altera_avalon_uart_state*) context;
 b005990:	e0bfff17 	ldw	r2,-4(fp)
 b005994:	e0bffc15 	stw	r2,-16(fp)
  void* base               = sp->base;
 b005998:	e0bffc17 	ldw	r2,-16(fp)
 b00599c:	10800017 	ldw	r2,0(r2)
 b0059a0:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Read the status register in order to determine the cause of the
   * interrupt.
   */

  status = IORD_ALTERA_AVALON_UART_STATUS(base);
 b0059a4:	e0bffd17 	ldw	r2,-12(fp)
 b0059a8:	10800204 	addi	r2,r2,8
 b0059ac:	10800037 	ldwio	r2,0(r2)
 b0059b0:	e0bffe15 	stw	r2,-8(fp)

  /* Clear any error flags set at the device */
  IOWR_ALTERA_AVALON_UART_STATUS(base, 0);
 b0059b4:	e0bffd17 	ldw	r2,-12(fp)
 b0059b8:	10800204 	addi	r2,r2,8
 b0059bc:	0007883a 	mov	r3,zero
 b0059c0:	10c00035 	stwio	r3,0(r2)

  /* Dummy read to ensure IRQ is negated before ISR returns */
  IORD_ALTERA_AVALON_UART_STATUS(base);
 b0059c4:	e0bffd17 	ldw	r2,-12(fp)
 b0059c8:	10800204 	addi	r2,r2,8
 b0059cc:	10800037 	ldwio	r2,0(r2)
  
  /* process a read irq */
  if (status & ALTERA_AVALON_UART_STATUS_RRDY_MSK)
 b0059d0:	e0bffe17 	ldw	r2,-8(fp)
 b0059d4:	1080200c 	andi	r2,r2,128
 b0059d8:	10000326 	beq	r2,zero,b0059e8 <altera_avalon_uart_irq+0x6c>
  {
    altera_avalon_uart_rxirq(sp, status);
 b0059dc:	e17ffe17 	ldw	r5,-8(fp)
 b0059e0:	e13ffc17 	ldw	r4,-16(fp)
 b0059e4:	b005a180 	call	b005a18 <altera_avalon_uart_rxirq>
  }

  /* process a write irq */
  if (status & (ALTERA_AVALON_UART_STATUS_TRDY_MSK | 
 b0059e8:	e0bffe17 	ldw	r2,-8(fp)
 b0059ec:	1081100c 	andi	r2,r2,1088
 b0059f0:	10000326 	beq	r2,zero,b005a00 <altera_avalon_uart_irq+0x84>
                  ALTERA_AVALON_UART_STATUS_DCTS_MSK))
  {
    altera_avalon_uart_txirq(sp, status);
 b0059f4:	e17ffe17 	ldw	r5,-8(fp)
 b0059f8:	e13ffc17 	ldw	r4,-16(fp)
 b0059fc:	b005afc0 	call	b005afc <altera_avalon_uart_txirq>
  }
  

}
 b005a00:	0001883a 	nop
 b005a04:	e037883a 	mov	sp,fp
 b005a08:	dfc00117 	ldw	ra,4(sp)
 b005a0c:	df000017 	ldw	fp,0(sp)
 b005a10:	dec00204 	addi	sp,sp,8
 b005a14:	f800283a 	ret

0b005a18 <altera_avalon_uart_rxirq>:
 * the receive circular buffer, and sets the apropriate flags to indicate 
 * that there is data ready to be processed.
 */
static void 
altera_avalon_uart_rxirq(altera_avalon_uart_state* sp, alt_u32 status)
{
 b005a18:	defffc04 	addi	sp,sp,-16
 b005a1c:	df000315 	stw	fp,12(sp)
 b005a20:	df000304 	addi	fp,sp,12
 b005a24:	e13ffe15 	stw	r4,-8(fp)
 b005a28:	e17fff15 	stw	r5,-4(fp)
  alt_u32 next;
  
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
 b005a2c:	e0bfff17 	ldw	r2,-4(fp)
 b005a30:	108000cc 	andi	r2,r2,3
 b005a34:	10002c1e 	bne	r2,zero,b005ae8 <altera_avalon_uart_rxirq+0xd0>
   * In a multi-threaded environment, set the read event flag to indicate
   * that there is data ready. This is only done if the circular buffer was
   * previously empty.
   */

  if (sp->rx_end == sp->rx_start)
 b005a38:	e0bffe17 	ldw	r2,-8(fp)
 b005a3c:	10800317 	ldw	r2,12(r2)
 b005a40:	e0bffe17 	ldw	r2,-8(fp)
 b005a44:	10800217 	ldw	r2,8(r2)
    ALT_FLAG_POST (sp->events, ALT_UART_READ_RDY, OS_FLAG_SET);
  }

  /* Determine which slot to use next in the circular buffer */

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
 b005a48:	e0bffe17 	ldw	r2,-8(fp)
 b005a4c:	10800317 	ldw	r2,12(r2)
 b005a50:	10800044 	addi	r2,r2,1
 b005a54:	10800fcc 	andi	r2,r2,63
 b005a58:	e0bffd15 	stw	r2,-12(fp)

  /* Transfer data from the device to the circular buffer */

  sp->rx_buf[sp->rx_end] = IORD_ALTERA_AVALON_UART_RXDATA(sp->base);
 b005a5c:	e0bffe17 	ldw	r2,-8(fp)
 b005a60:	10800317 	ldw	r2,12(r2)
 b005a64:	e0fffe17 	ldw	r3,-8(fp)
 b005a68:	18c00017 	ldw	r3,0(r3)
 b005a6c:	18c00037 	ldwio	r3,0(r3)
 b005a70:	1809883a 	mov	r4,r3
 b005a74:	e0fffe17 	ldw	r3,-8(fp)
 b005a78:	1885883a 	add	r2,r3,r2
 b005a7c:	10800704 	addi	r2,r2,28
 b005a80:	11000005 	stb	r4,0(r2)

  sp->rx_end = next;
 b005a84:	e0bffe17 	ldw	r2,-8(fp)
 b005a88:	e0fffd17 	ldw	r3,-12(fp)
 b005a8c:	10c00315 	stw	r3,12(r2)

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
 b005a90:	e0bffe17 	ldw	r2,-8(fp)
 b005a94:	10800317 	ldw	r2,12(r2)
 b005a98:	10800044 	addi	r2,r2,1
 b005a9c:	10800fcc 	andi	r2,r2,63
 b005aa0:	e0bffd15 	stw	r2,-12(fp)
  /*
   * If the cicular buffer was full, disable interrupts. Interrupts will be
   * re-enabled when data is removed from the buffer.
   */

  if (next == sp->rx_start)
 b005aa4:	e0bffe17 	ldw	r2,-8(fp)
 b005aa8:	10c00217 	ldw	r3,8(r2)
 b005aac:	e0bffd17 	ldw	r2,-12(fp)
 b005ab0:	18800e1e 	bne	r3,r2,b005aec <altera_avalon_uart_rxirq+0xd4>
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
 b005ab4:	e0bffe17 	ldw	r2,-8(fp)
 b005ab8:	10c00117 	ldw	r3,4(r2)
 b005abc:	00bfdfc4 	movi	r2,-129
 b005ac0:	1886703a 	and	r3,r3,r2
 b005ac4:	e0bffe17 	ldw	r2,-8(fp)
 b005ac8:	10c00115 	stw	r3,4(r2)
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
 b005acc:	e0bffe17 	ldw	r2,-8(fp)
 b005ad0:	10800017 	ldw	r2,0(r2)
 b005ad4:	10800304 	addi	r2,r2,12
 b005ad8:	e0fffe17 	ldw	r3,-8(fp)
 b005adc:	18c00117 	ldw	r3,4(r3)
 b005ae0:	10c00035 	stwio	r3,0(r2)
 b005ae4:	00000106 	br	b005aec <altera_avalon_uart_rxirq+0xd4>
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
                  ALTERA_AVALON_UART_STATUS_FE_MSK))
  {
    return;
 b005ae8:	0001883a 	nop
  if (next == sp->rx_start)
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
  }   
}
 b005aec:	e037883a 	mov	sp,fp
 b005af0:	df000017 	ldw	fp,0(sp)
 b005af4:	dec00104 	addi	sp,sp,4
 b005af8:	f800283a 	ret

0b005afc <altera_avalon_uart_txirq>:
 * buffer to the device, and sets the apropriate flags to indicate that 
 * there is data ready to be processed.
 */
static void 
altera_avalon_uart_txirq(altera_avalon_uart_state* sp, alt_u32 status)
{
 b005afc:	defffb04 	addi	sp,sp,-20
 b005b00:	df000415 	stw	fp,16(sp)
 b005b04:	df000404 	addi	fp,sp,16
 b005b08:	e13ffc15 	stw	r4,-16(fp)
 b005b0c:	e17ffd15 	stw	r5,-12(fp)
  /* Transfer data if there is some ready to be transfered */

  if (sp->tx_start != sp->tx_end)
 b005b10:	e0bffc17 	ldw	r2,-16(fp)
 b005b14:	10c00417 	ldw	r3,16(r2)
 b005b18:	e0bffc17 	ldw	r2,-16(fp)
 b005b1c:	10800517 	ldw	r2,20(r2)
 b005b20:	18803226 	beq	r3,r2,b005bec <altera_avalon_uart_txirq+0xf0>
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
 b005b24:	e0bffc17 	ldw	r2,-16(fp)
 b005b28:	10800617 	ldw	r2,24(r2)
 b005b2c:	1080008c 	andi	r2,r2,2
 b005b30:	10000326 	beq	r2,zero,b005b40 <altera_avalon_uart_txirq+0x44>
      (status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
 b005b34:	e0bffd17 	ldw	r2,-12(fp)
 b005b38:	1082000c 	andi	r2,r2,2048
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
 b005b3c:	10001d26 	beq	r2,zero,b005bb4 <altera_avalon_uart_txirq+0xb8>
       * In a multi-threaded environment, set the write event flag to indicate
       * that there is space in the circular buffer. This is only done if the
       * buffer was previously empty.
       */

      if (sp->tx_start == ((sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK))
 b005b40:	e0bffc17 	ldw	r2,-16(fp)
 b005b44:	10800417 	ldw	r2,16(r2)
 b005b48:	e0bffc17 	ldw	r2,-16(fp)
 b005b4c:	10800517 	ldw	r2,20(r2)
                       OS_FLAG_SET);
      }

      /* Write the data to the device */

      IOWR_ALTERA_AVALON_UART_TXDATA(sp->base, sp->tx_buf[sp->tx_start]);
 b005b50:	e0bffc17 	ldw	r2,-16(fp)
 b005b54:	10800017 	ldw	r2,0(r2)
 b005b58:	10800104 	addi	r2,r2,4
 b005b5c:	e0fffc17 	ldw	r3,-16(fp)
 b005b60:	18c00417 	ldw	r3,16(r3)
 b005b64:	e13ffc17 	ldw	r4,-16(fp)
 b005b68:	20c7883a 	add	r3,r4,r3
 b005b6c:	18c01704 	addi	r3,r3,92
 b005b70:	18c00003 	ldbu	r3,0(r3)
 b005b74:	18c03fcc 	andi	r3,r3,255
 b005b78:	10c00035 	stwio	r3,0(r2)

      sp->tx_start = (++sp->tx_start) & ALT_AVALON_UART_BUF_MSK;
 b005b7c:	e0bffc17 	ldw	r2,-16(fp)
 b005b80:	10800417 	ldw	r2,16(r2)
 b005b84:	10800044 	addi	r2,r2,1
 b005b88:	e0fffc17 	ldw	r3,-16(fp)
 b005b8c:	18800415 	stw	r2,16(r3)
 b005b90:	10c00fcc 	andi	r3,r2,63
 b005b94:	e0bffc17 	ldw	r2,-16(fp)
 b005b98:	10c00415 	stw	r3,16(r2)
      /*
       * In case the tranmit interrupt had previously been disabled by 
       * detecting a low value on CTS, it is reenabled here.
       */ 

      sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
 b005b9c:	e0bffc17 	ldw	r2,-16(fp)
 b005ba0:	10800117 	ldw	r2,4(r2)
 b005ba4:	10c01014 	ori	r3,r2,64
 b005ba8:	e0bffc17 	ldw	r2,-16(fp)
 b005bac:	10c00115 	stw	r3,4(r2)
 b005bb0:	00000e06 	br	b005bec <altera_avalon_uart_txirq+0xf0>
       * the last write to the status register. To avoid this resulting in
       * deadlock, it's necessary to re-check the status register here
       * before throttling.
       */
 
      status = IORD_ALTERA_AVALON_UART_STATUS(sp->base); 
 b005bb4:	e0bffc17 	ldw	r2,-16(fp)
 b005bb8:	10800017 	ldw	r2,0(r2)
 b005bbc:	10800204 	addi	r2,r2,8
 b005bc0:	10800037 	ldwio	r2,0(r2)
 b005bc4:	e0bffd15 	stw	r2,-12(fp)

      if (!(status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
 b005bc8:	e0bffd17 	ldw	r2,-12(fp)
 b005bcc:	1082000c 	andi	r2,r2,2048
 b005bd0:	1000061e 	bne	r2,zero,b005bec <altera_avalon_uart_txirq+0xf0>
      {
        sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
 b005bd4:	e0bffc17 	ldw	r2,-16(fp)
 b005bd8:	10c00117 	ldw	r3,4(r2)
 b005bdc:	00bfefc4 	movi	r2,-65
 b005be0:	1886703a 	and	r3,r3,r2
 b005be4:	e0bffc17 	ldw	r2,-16(fp)
 b005be8:	10c00115 	stw	r3,4(r2)
  /*
   * If the circular buffer is empty, disable the interrupt. This will be
   * re-enabled when new data is placed in the buffer.
   */

  if (sp->tx_start == sp->tx_end)
 b005bec:	e0bffc17 	ldw	r2,-16(fp)
 b005bf0:	10c00417 	ldw	r3,16(r2)
 b005bf4:	e0bffc17 	ldw	r2,-16(fp)
 b005bf8:	10800517 	ldw	r2,20(r2)
 b005bfc:	1880061e 	bne	r3,r2,b005c18 <altera_avalon_uart_txirq+0x11c>
  {
    sp->ctrl &= ~(ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
 b005c00:	e0bffc17 	ldw	r2,-16(fp)
 b005c04:	10c00117 	ldw	r3,4(r2)
 b005c08:	00beefc4 	movi	r2,-1089
 b005c0c:	1886703a 	and	r3,r3,r2
 b005c10:	e0bffc17 	ldw	r2,-16(fp)
 b005c14:	10c00115 	stw	r3,4(r2)
                    ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
  }

  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
 b005c18:	e0bffc17 	ldw	r2,-16(fp)
 b005c1c:	10800017 	ldw	r2,0(r2)
 b005c20:	10800304 	addi	r2,r2,12
 b005c24:	e0fffc17 	ldw	r3,-16(fp)
 b005c28:	18c00117 	ldw	r3,4(r3)
 b005c2c:	10c00035 	stwio	r3,0(r2)
}
 b005c30:	0001883a 	nop
 b005c34:	e037883a 	mov	sp,fp
 b005c38:	df000017 	ldw	fp,0(sp)
 b005c3c:	dec00104 	addi	sp,sp,4
 b005c40:	f800283a 	ret

0b005c44 <altera_avalon_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
 b005c44:	defffd04 	addi	sp,sp,-12
 b005c48:	df000215 	stw	fp,8(sp)
 b005c4c:	df000204 	addi	fp,sp,8
 b005c50:	e13ffe15 	stw	r4,-8(fp)
 b005c54:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
 b005c58:	00000506 	br	b005c70 <altera_avalon_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
 b005c5c:	e0bfff17 	ldw	r2,-4(fp)
 b005c60:	1090000c 	andi	r2,r2,16384
 b005c64:	10000226 	beq	r2,zero,b005c70 <altera_avalon_uart_close+0x2c>
      return -EWOULDBLOCK; 
 b005c68:	00bffd44 	movi	r2,-11
 b005c6c:	00000606 	br	b005c88 <altera_avalon_uart_close+0x44>
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
 b005c70:	e0bffe17 	ldw	r2,-8(fp)
 b005c74:	10c00417 	ldw	r3,16(r2)
 b005c78:	e0bffe17 	ldw	r2,-8(fp)
 b005c7c:	10800517 	ldw	r2,20(r2)
 b005c80:	18bff61e 	bne	r3,r2,b005c5c <__alt_mem_flash+0xff004c5c>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
 b005c84:	0005883a 	mov	r2,zero
}
 b005c88:	e037883a 	mov	sp,fp
 b005c8c:	df000017 	ldw	fp,0(sp)
 b005c90:	dec00104 	addi	sp,sp,4
 b005c94:	f800283a 	ret

0b005c98 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 b005c98:	defffe04 	addi	sp,sp,-8
 b005c9c:	dfc00115 	stw	ra,4(sp)
 b005ca0:	df000015 	stw	fp,0(sp)
 b005ca4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 b005ca8:	d0a00817 	ldw	r2,-32736(gp)
 b005cac:	10000326 	beq	r2,zero,b005cbc <alt_get_errno+0x24>
 b005cb0:	d0a00817 	ldw	r2,-32736(gp)
 b005cb4:	103ee83a 	callr	r2
 b005cb8:	00000106 	br	b005cc0 <alt_get_errno+0x28>
 b005cbc:	d0a61d04 	addi	r2,gp,-26508
}
 b005cc0:	e037883a 	mov	sp,fp
 b005cc4:	dfc00117 	ldw	ra,4(sp)
 b005cc8:	df000017 	ldw	fp,0(sp)
 b005ccc:	dec00204 	addi	sp,sp,8
 b005cd0:	f800283a 	ret

0b005cd4 <altera_avalon_uart_read>:
 */

int 
altera_avalon_uart_read(altera_avalon_uart_state* sp, char* ptr, int len,
  int flags)
{
 b005cd4:	defff204 	addi	sp,sp,-56
 b005cd8:	dfc00d15 	stw	ra,52(sp)
 b005cdc:	df000c15 	stw	fp,48(sp)
 b005ce0:	df000c04 	addi	fp,sp,48
 b005ce4:	e13ffc15 	stw	r4,-16(fp)
 b005ce8:	e17ffd15 	stw	r5,-12(fp)
 b005cec:	e1bffe15 	stw	r6,-8(fp)
 b005cf0:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             block;
  alt_u8          read_would_block = 0;
 b005cf4:	e03ff405 	stb	zero,-48(fp)
  int             count = 0;
 b005cf8:	e03ff515 	stw	zero,-44(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  block = !(flags & O_NONBLOCK);
 b005cfc:	e0bfff17 	ldw	r2,-4(fp)
 b005d00:	1090000c 	andi	r2,r2,16384
 b005d04:	1005003a 	cmpeq	r2,r2,zero
 b005d08:	10803fcc 	andi	r2,r2,255
 b005d0c:	e0bff615 	stw	r2,-40(fp)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
 b005d10:	00001306 	br	b005d60 <altera_avalon_uart_read+0x8c>
    {
      count++;
 b005d14:	e0bff517 	ldw	r2,-44(fp)
 b005d18:	10800044 	addi	r2,r2,1
 b005d1c:	e0bff515 	stw	r2,-44(fp)
      *ptr++ = sp->rx_buf[sp->rx_start];
 b005d20:	e0bffd17 	ldw	r2,-12(fp)
 b005d24:	10c00044 	addi	r3,r2,1
 b005d28:	e0fffd15 	stw	r3,-12(fp)
 b005d2c:	e0fffc17 	ldw	r3,-16(fp)
 b005d30:	18c00217 	ldw	r3,8(r3)
 b005d34:	e13ffc17 	ldw	r4,-16(fp)
 b005d38:	20c7883a 	add	r3,r4,r3
 b005d3c:	18c00704 	addi	r3,r3,28
 b005d40:	18c00003 	ldbu	r3,0(r3)
 b005d44:	10c00005 	stb	r3,0(r2)
      
      sp->rx_start = (sp->rx_start+1) & ALT_AVALON_UART_BUF_MSK;
 b005d48:	e0bffc17 	ldw	r2,-16(fp)
 b005d4c:	10800217 	ldw	r2,8(r2)
 b005d50:	10800044 	addi	r2,r2,1
 b005d54:	10c00fcc 	andi	r3,r2,63
 b005d58:	e0bffc17 	ldw	r2,-16(fp)
 b005d5c:	10c00215 	stw	r3,8(r2)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
 b005d60:	e0fff517 	ldw	r3,-44(fp)
 b005d64:	e0bffe17 	ldw	r2,-8(fp)
 b005d68:	1880050e 	bge	r3,r2,b005d80 <altera_avalon_uart_read+0xac>
 b005d6c:	e0bffc17 	ldw	r2,-16(fp)
 b005d70:	10c00217 	ldw	r3,8(r2)
 b005d74:	e0bffc17 	ldw	r2,-16(fp)
 b005d78:	10800317 	ldw	r2,12(r2)
 b005d7c:	18bfe51e 	bne	r3,r2,b005d14 <__alt_mem_flash+0xff004d14>
    /*
     * If no data has been transferred, the circular buffer is empty, and
     * this is not a non-blocking access, block waiting for data to arrive.
     */

    if (!count && (sp->rx_start == sp->rx_end))
 b005d80:	e0bff517 	ldw	r2,-44(fp)
 b005d84:	1000251e 	bne	r2,zero,b005e1c <altera_avalon_uart_read+0x148>
 b005d88:	e0bffc17 	ldw	r2,-16(fp)
 b005d8c:	10c00217 	ldw	r3,8(r2)
 b005d90:	e0bffc17 	ldw	r2,-16(fp)
 b005d94:	10800317 	ldw	r2,12(r2)
 b005d98:	1880201e 	bne	r3,r2,b005e1c <altera_avalon_uart_read+0x148>
    {
      if (!block)
 b005d9c:	e0bff617 	ldw	r2,-40(fp)
 b005da0:	1000071e 	bne	r2,zero,b005dc0 <altera_avalon_uart_read+0xec>
      {
        /* Set errno to indicate the reason we're not returning any data */

        ALT_ERRNO = EWOULDBLOCK;
 b005da4:	b005c980 	call	b005c98 <alt_get_errno>
 b005da8:	1007883a 	mov	r3,r2
 b005dac:	008002c4 	movi	r2,11
 b005db0:	18800015 	stw	r2,0(r3)
        read_would_block = 1;
 b005db4:	00800044 	movi	r2,1
 b005db8:	e0bff405 	stb	r2,-48(fp)
        break;
 b005dbc:	00001b06 	br	b005e2c <altera_avalon_uart_read+0x158>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 b005dc0:	0005303a 	rdctl	r2,status
 b005dc4:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 b005dc8:	e0fff917 	ldw	r3,-28(fp)
 b005dcc:	00bfff84 	movi	r2,-2
 b005dd0:	1884703a 	and	r2,r3,r2
 b005dd4:	1001703a 	wrctl	status,r2
  
  return context;
 b005dd8:	e0bff917 	ldw	r2,-28(fp)
      {
       /* Block waiting for some data to arrive */

       /* First, ensure read interrupts are enabled to avoid deadlock */

       context = alt_irq_disable_all ();
 b005ddc:	e0bff815 	stw	r2,-32(fp)
       sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
 b005de0:	e0bffc17 	ldw	r2,-16(fp)
 b005de4:	10800117 	ldw	r2,4(r2)
 b005de8:	10c02014 	ori	r3,r2,128
 b005dec:	e0bffc17 	ldw	r2,-16(fp)
 b005df0:	10c00115 	stw	r3,4(r2)
       IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
 b005df4:	e0bffc17 	ldw	r2,-16(fp)
 b005df8:	10800017 	ldw	r2,0(r2)
 b005dfc:	10800304 	addi	r2,r2,12
 b005e00:	e0fffc17 	ldw	r3,-16(fp)
 b005e04:	18c00117 	ldw	r3,4(r3)
 b005e08:	10c00035 	stwio	r3,0(r2)
 b005e0c:	e0bff817 	ldw	r2,-32(fp)
 b005e10:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 b005e14:	e0bffa17 	ldw	r2,-24(fp)
 b005e18:	1001703a 	wrctl	status,r2
                      OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                      0);
      }
    }
  }
  while (!count && len);
 b005e1c:	e0bff517 	ldw	r2,-44(fp)
 b005e20:	1000021e 	bne	r2,zero,b005e2c <altera_avalon_uart_read+0x158>
 b005e24:	e0bffe17 	ldw	r2,-8(fp)
 b005e28:	103fcd1e 	bne	r2,zero,b005d60 <__alt_mem_flash+0xff004d60>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 b005e2c:	0005303a 	rdctl	r2,status
 b005e30:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 b005e34:	e0fffb17 	ldw	r3,-20(fp)
 b005e38:	00bfff84 	movi	r2,-2
 b005e3c:	1884703a 	and	r2,r3,r2
 b005e40:	1001703a 	wrctl	status,r2
  
  return context;
 b005e44:	e0bffb17 	ldw	r2,-20(fp)
  /*
   * Ensure that interrupts are enabled, so that the circular buffer can
   * re-fill.
   */

  context = alt_irq_disable_all ();
 b005e48:	e0bff815 	stw	r2,-32(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
 b005e4c:	e0bffc17 	ldw	r2,-16(fp)
 b005e50:	10800117 	ldw	r2,4(r2)
 b005e54:	10c02014 	ori	r3,r2,128
 b005e58:	e0bffc17 	ldw	r2,-16(fp)
 b005e5c:	10c00115 	stw	r3,4(r2)
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
 b005e60:	e0bffc17 	ldw	r2,-16(fp)
 b005e64:	10800017 	ldw	r2,0(r2)
 b005e68:	10800304 	addi	r2,r2,12
 b005e6c:	e0fffc17 	ldw	r3,-16(fp)
 b005e70:	18c00117 	ldw	r3,4(r3)
 b005e74:	10c00035 	stwio	r3,0(r2)
 b005e78:	e0bff817 	ldw	r2,-32(fp)
 b005e7c:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 b005e80:	e0bff717 	ldw	r2,-36(fp)
 b005e84:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* Return the number of bytes read */
  if(read_would_block) {
 b005e88:	e0bff403 	ldbu	r2,-48(fp)
 b005e8c:	10000226 	beq	r2,zero,b005e98 <altera_avalon_uart_read+0x1c4>
    return -EWOULDBLOCK;
 b005e90:	00bffd44 	movi	r2,-11
 b005e94:	00000106 	br	b005e9c <altera_avalon_uart_read+0x1c8>
  }
  else {
    return count;
 b005e98:	e0bff517 	ldw	r2,-44(fp)
  }
}
 b005e9c:	e037883a 	mov	sp,fp
 b005ea0:	dfc00117 	ldw	ra,4(sp)
 b005ea4:	df000017 	ldw	fp,0(sp)
 b005ea8:	dec00204 	addi	sp,sp,8
 b005eac:	f800283a 	ret

0b005eb0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 b005eb0:	defffe04 	addi	sp,sp,-8
 b005eb4:	dfc00115 	stw	ra,4(sp)
 b005eb8:	df000015 	stw	fp,0(sp)
 b005ebc:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 b005ec0:	d0a00817 	ldw	r2,-32736(gp)
 b005ec4:	10000326 	beq	r2,zero,b005ed4 <alt_get_errno+0x24>
 b005ec8:	d0a00817 	ldw	r2,-32736(gp)
 b005ecc:	103ee83a 	callr	r2
 b005ed0:	00000106 	br	b005ed8 <alt_get_errno+0x28>
 b005ed4:	d0a61d04 	addi	r2,gp,-26508
}
 b005ed8:	e037883a 	mov	sp,fp
 b005edc:	dfc00117 	ldw	ra,4(sp)
 b005ee0:	df000017 	ldw	fp,0(sp)
 b005ee4:	dec00204 	addi	sp,sp,8
 b005ee8:	f800283a 	ret

0b005eec <altera_avalon_uart_write>:
 */

int
altera_avalon_uart_write(altera_avalon_uart_state* sp, const char* ptr, int len,
  int flags)
{
 b005eec:	defff204 	addi	sp,sp,-56
 b005ef0:	dfc00d15 	stw	ra,52(sp)
 b005ef4:	df000c15 	stw	fp,48(sp)
 b005ef8:	df000c04 	addi	fp,sp,48
 b005efc:	e13ffc15 	stw	r4,-16(fp)
 b005f00:	e17ffd15 	stw	r5,-12(fp)
 b005f04:	e1bffe15 	stw	r6,-8(fp)
 b005f08:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             no_block;
  alt_u32         next;
  int             count = len;
 b005f0c:	e0bffe17 	ldw	r2,-8(fp)
 b005f10:	e0bff415 	stw	r2,-48(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  no_block = (flags & O_NONBLOCK);
 b005f14:	e0bfff17 	ldw	r2,-4(fp)
 b005f18:	1090000c 	andi	r2,r2,16384
 b005f1c:	e0bff515 	stw	r2,-44(fp)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
 b005f20:	00003c06 	br	b006014 <altera_avalon_uart_write+0x128>
  {
    /* Determine the next slot in the buffer to access */

    next = (sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK;
 b005f24:	e0bffc17 	ldw	r2,-16(fp)
 b005f28:	10800517 	ldw	r2,20(r2)
 b005f2c:	10800044 	addi	r2,r2,1
 b005f30:	10800fcc 	andi	r2,r2,63
 b005f34:	e0bff715 	stw	r2,-36(fp)

    /* block waiting for space if necessary */

    if (next == sp->tx_start)
 b005f38:	e0bffc17 	ldw	r2,-16(fp)
 b005f3c:	10c00417 	ldw	r3,16(r2)
 b005f40:	e0bff717 	ldw	r2,-36(fp)
 b005f44:	1880221e 	bne	r3,r2,b005fd0 <altera_avalon_uart_write+0xe4>
    {
      if (no_block)
 b005f48:	e0bff517 	ldw	r2,-44(fp)
 b005f4c:	10000526 	beq	r2,zero,b005f64 <altera_avalon_uart_write+0x78>
      {
        /* Set errno to indicate why this function returned early */
 
        ALT_ERRNO = EWOULDBLOCK;
 b005f50:	b005eb00 	call	b005eb0 <alt_get_errno>
 b005f54:	1007883a 	mov	r3,r2
 b005f58:	008002c4 	movi	r2,11
 b005f5c:	18800015 	stw	r2,0(r3)
        break;
 b005f60:	00002e06 	br	b00601c <altera_avalon_uart_write+0x130>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 b005f64:	0005303a 	rdctl	r2,status
 b005f68:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 b005f6c:	e0fff917 	ldw	r3,-28(fp)
 b005f70:	00bfff84 	movi	r2,-2
 b005f74:	1884703a 	and	r2,r3,r2
 b005f78:	1001703a 	wrctl	status,r2
  
  return context;
 b005f7c:	e0bff917 	ldw	r2,-28(fp)
      {
        /* Block waiting for space in the circular buffer */

        /* First, ensure transmit interrupts are enabled to avoid deadlock */

        context = alt_irq_disable_all ();
 b005f80:	e0bff815 	stw	r2,-32(fp)
        sp->ctrl |= (ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
 b005f84:	e0bffc17 	ldw	r2,-16(fp)
 b005f88:	10800117 	ldw	r2,4(r2)
 b005f8c:	10c11014 	ori	r3,r2,1088
 b005f90:	e0bffc17 	ldw	r2,-16(fp)
 b005f94:	10c00115 	stw	r3,4(r2)
                        ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
        IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
 b005f98:	e0bffc17 	ldw	r2,-16(fp)
 b005f9c:	10800017 	ldw	r2,0(r2)
 b005fa0:	10800304 	addi	r2,r2,12
 b005fa4:	e0fffc17 	ldw	r3,-16(fp)
 b005fa8:	18c00117 	ldw	r3,4(r3)
 b005fac:	10c00035 	stwio	r3,0(r2)
 b005fb0:	e0bff817 	ldw	r2,-32(fp)
 b005fb4:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 b005fb8:	e0bff617 	ldw	r2,-40(fp)
 b005fbc:	1001703a 	wrctl	status,r2
          ALT_FLAG_PEND (sp->events, 
                         ALT_UART_WRITE_RDY,
                         OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                         0);
        }
        while ((next == sp->tx_start));
 b005fc0:	e0bffc17 	ldw	r2,-16(fp)
 b005fc4:	10c00417 	ldw	r3,16(r2)
 b005fc8:	e0bff717 	ldw	r2,-36(fp)
 b005fcc:	18bffc26 	beq	r3,r2,b005fc0 <__alt_mem_flash+0xff004fc0>
      }
    }

    count--;
 b005fd0:	e0bff417 	ldw	r2,-48(fp)
 b005fd4:	10bfffc4 	addi	r2,r2,-1
 b005fd8:	e0bff415 	stw	r2,-48(fp)

    /* Add the next character to the transmit buffer */

    sp->tx_buf[sp->tx_end] = *ptr++;
 b005fdc:	e0bffc17 	ldw	r2,-16(fp)
 b005fe0:	10c00517 	ldw	r3,20(r2)
 b005fe4:	e0bffd17 	ldw	r2,-12(fp)
 b005fe8:	11000044 	addi	r4,r2,1
 b005fec:	e13ffd15 	stw	r4,-12(fp)
 b005ff0:	10800003 	ldbu	r2,0(r2)
 b005ff4:	1009883a 	mov	r4,r2
 b005ff8:	e0bffc17 	ldw	r2,-16(fp)
 b005ffc:	10c5883a 	add	r2,r2,r3
 b006000:	10801704 	addi	r2,r2,92
 b006004:	11000005 	stb	r4,0(r2)
    sp->tx_end = next;
 b006008:	e0bffc17 	ldw	r2,-16(fp)
 b00600c:	e0fff717 	ldw	r3,-36(fp)
 b006010:	10c00515 	stw	r3,20(r2)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
 b006014:	e0bff417 	ldw	r2,-48(fp)
 b006018:	103fc21e 	bne	r2,zero,b005f24 <__alt_mem_flash+0xff004f24>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 b00601c:	0005303a 	rdctl	r2,status
 b006020:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 b006024:	e0fffb17 	ldw	r3,-20(fp)
 b006028:	00bfff84 	movi	r2,-2
 b00602c:	1884703a 	and	r2,r3,r2
 b006030:	1001703a 	wrctl	status,r2
  
  return context;
 b006034:	e0bffb17 	ldw	r2,-20(fp)
  /* 
   * Ensure that interrupts are enabled, so that the circular buffer can 
   * drain.
   */

  context = alt_irq_disable_all ();
 b006038:	e0bff815 	stw	r2,-32(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
 b00603c:	e0bffc17 	ldw	r2,-16(fp)
 b006040:	10800117 	ldw	r2,4(r2)
 b006044:	10c11014 	ori	r3,r2,1088
 b006048:	e0bffc17 	ldw	r2,-16(fp)
 b00604c:	10c00115 	stw	r3,4(r2)
                 ALTERA_AVALON_UART_CONTROL_DCTS_MSK;
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
 b006050:	e0bffc17 	ldw	r2,-16(fp)
 b006054:	10800017 	ldw	r2,0(r2)
 b006058:	10800304 	addi	r2,r2,12
 b00605c:	e0fffc17 	ldw	r3,-16(fp)
 b006060:	18c00117 	ldw	r3,4(r3)
 b006064:	10c00035 	stwio	r3,0(r2)
 b006068:	e0bff817 	ldw	r2,-32(fp)
 b00606c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 b006070:	e0bffa17 	ldw	r2,-24(fp)
 b006074:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* return the number of bytes written */

  return (len - count);
 b006078:	e0fffe17 	ldw	r3,-8(fp)
 b00607c:	e0bff417 	ldw	r2,-48(fp)
 b006080:	1885c83a 	sub	r2,r3,r2
}
 b006084:	e037883a 	mov	sp,fp
 b006088:	dfc00117 	ldw	ra,4(sp)
 b00608c:	df000017 	ldw	fp,0(sp)
 b006090:	dec00204 	addi	sp,sp,8
 b006094:	f800283a 	ret

0b006098 <alt_up_adc_open_dev>:
#define read_ch4(adc)  IORD_ALT_UP_ADC_CH_4(((adc)->base))
#define read_ch5(adc)  IORD_ALT_UP_ADC_CH_5(((adc)->base))
#define read_ch6(adc)  IORD_ALT_UP_ADC_CH_6(((adc)->base))
#define read_ch7(adc)  IORD_ALT_UP_ADC_CH_7(((adc)->base))

alt_up_adc_dev* alt_up_adc_open_dev (const char* name){
 b006098:	defffc04 	addi	sp,sp,-16
 b00609c:	dfc00315 	stw	ra,12(sp)
 b0060a0:	df000215 	stw	fp,8(sp)
 b0060a4:	df000204 	addi	fp,sp,8
 b0060a8:	e13fff15 	stw	r4,-4(fp)

	alt_up_adc_dev* dev = (alt_up_adc_dev*) alt_find_dev(name, &alt_dev_list);
 b0060ac:	d1600504 	addi	r5,gp,-32748
 b0060b0:	e13fff17 	ldw	r4,-4(fp)
 b0060b4:	b006dac0 	call	b006dac <alt_find_dev>
 b0060b8:	e0bffe15 	stw	r2,-8(fp)
	
	return dev;
 b0060bc:	e0bffe17 	ldw	r2,-8(fp)
}
 b0060c0:	e037883a 	mov	sp,fp
 b0060c4:	dfc00117 	ldw	ra,4(sp)
 b0060c8:	df000017 	ldw	fp,0(sp)
 b0060cc:	dec00204 	addi	sp,sp,8
 b0060d0:	f800283a 	ret

0b0060d4 <alt_up_adc_read>:

unsigned int alt_up_adc_read (alt_up_adc_dev * adc, unsigned channel){
 b0060d4:	defffc04 	addi	sp,sp,-16
 b0060d8:	df000315 	stw	fp,12(sp)
 b0060dc:	df000304 	addi	fp,sp,12
 b0060e0:	e13ffe15 	stw	r4,-8(fp)
 b0060e4:	e17fff15 	stw	r5,-4(fp)

	unsigned int ch = channel % 8;
 b0060e8:	e0bfff17 	ldw	r2,-4(fp)
 b0060ec:	108001cc 	andi	r2,r2,7
 b0060f0:	e0bffd15 	stw	r2,-12(fp)
	
	switch (ch){
 b0060f4:	e0bffd17 	ldw	r2,-12(fp)
 b0060f8:	10800228 	cmpgeui	r2,r2,8
 b0060fc:	1000361e 	bne	r2,zero,b0061d8 <alt_up_adc_read+0x104>
 b006100:	e0bffd17 	ldw	r2,-12(fp)
 b006104:	100690ba 	slli	r3,r2,2
 b006108:	0082c034 	movhi	r2,2816
 b00610c:	10984704 	addi	r2,r2,24860
 b006110:	1885883a 	add	r2,r3,r2
 b006114:	10800017 	ldw	r2,0(r2)
 b006118:	1000683a 	jmp	r2
 b00611c:	0b00613c 	xorhi	r12,at,388
 b006120:	0b00614c 	andi	r12,at,389
 b006124:	0b006160 	cmpeqi	r12,at,389
 b006128:	0b006174 	orhi	r12,at,389
 b00612c:	0b006188 	cmpgei	r12,at,390
 b006130:	0b00619c 	xori	r12,at,390
 b006134:	0b0061b0 	cmpltui	r12,at,390
 b006138:	0b0061c4 	addi	r12,at,391
		case 0:
			return read_ch0(adc);
 b00613c:	e0bffe17 	ldw	r2,-8(fp)
 b006140:	10800a17 	ldw	r2,40(r2)
 b006144:	10800037 	ldwio	r2,0(r2)
 b006148:	00002406 	br	b0061dc <alt_up_adc_read+0x108>
		case 1:
			return read_ch1(adc);
 b00614c:	e0bffe17 	ldw	r2,-8(fp)
 b006150:	10800a17 	ldw	r2,40(r2)
 b006154:	10800104 	addi	r2,r2,4
 b006158:	10800037 	ldwio	r2,0(r2)
 b00615c:	00001f06 	br	b0061dc <alt_up_adc_read+0x108>
		case 2:
			return read_ch2(adc);
 b006160:	e0bffe17 	ldw	r2,-8(fp)
 b006164:	10800a17 	ldw	r2,40(r2)
 b006168:	10800204 	addi	r2,r2,8
 b00616c:	10800037 	ldwio	r2,0(r2)
 b006170:	00001a06 	br	b0061dc <alt_up_adc_read+0x108>
		case 3:
			return read_ch3(adc);
 b006174:	e0bffe17 	ldw	r2,-8(fp)
 b006178:	10800a17 	ldw	r2,40(r2)
 b00617c:	10800304 	addi	r2,r2,12
 b006180:	10800037 	ldwio	r2,0(r2)
 b006184:	00001506 	br	b0061dc <alt_up_adc_read+0x108>
		case 4:
			return read_ch4(adc);
 b006188:	e0bffe17 	ldw	r2,-8(fp)
 b00618c:	10800a17 	ldw	r2,40(r2)
 b006190:	10800404 	addi	r2,r2,16
 b006194:	10800037 	ldwio	r2,0(r2)
 b006198:	00001006 	br	b0061dc <alt_up_adc_read+0x108>
		case 5:
			return read_ch5(adc);
 b00619c:	e0bffe17 	ldw	r2,-8(fp)
 b0061a0:	10800a17 	ldw	r2,40(r2)
 b0061a4:	10800504 	addi	r2,r2,20
 b0061a8:	10800037 	ldwio	r2,0(r2)
 b0061ac:	00000b06 	br	b0061dc <alt_up_adc_read+0x108>
		case 6:
			return read_ch6(adc);
 b0061b0:	e0bffe17 	ldw	r2,-8(fp)
 b0061b4:	10800a17 	ldw	r2,40(r2)
 b0061b8:	10800604 	addi	r2,r2,24
 b0061bc:	10800037 	ldwio	r2,0(r2)
 b0061c0:	00000606 	br	b0061dc <alt_up_adc_read+0x108>
		case 7:
			return read_ch7(adc);
 b0061c4:	e0bffe17 	ldw	r2,-8(fp)
 b0061c8:	10800a17 	ldw	r2,40(r2)
 b0061cc:	10800704 	addi	r2,r2,28
 b0061d0:	10800037 	ldwio	r2,0(r2)
 b0061d4:	00000106 	br	b0061dc <alt_up_adc_read+0x108>
		default:
			return 0;
 b0061d8:	0005883a 	mov	r2,zero
	}
}
 b0061dc:	e037883a 	mov	sp,fp
 b0061e0:	df000017 	ldw	fp,0(sp)
 b0061e4:	dec00104 	addi	sp,sp,4
 b0061e8:	f800283a 	ret

0b0061ec <epcs_read_status_register>:
#include "alt_types.h"
#include "epcs_commands.h"
#include "altera_avalon_spi.h"

alt_u8 epcs_read_status_register(alt_u32 base)
{
 b0061ec:	defff904 	addi	sp,sp,-28
 b0061f0:	dfc00615 	stw	ra,24(sp)
 b0061f4:	df000515 	stw	fp,20(sp)
 b0061f8:	df000504 	addi	fp,sp,20
 b0061fc:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 rdsr = epcs_rdsr;
 b006200:	00800144 	movi	r2,5
 b006204:	e0bffe05 	stb	r2,-8(fp)
  alt_u8 status;
  alt_avalon_spi_command(
 b006208:	d8000215 	stw	zero,8(sp)
 b00620c:	e0bffe44 	addi	r2,fp,-7
 b006210:	d8800115 	stw	r2,4(sp)
 b006214:	00800044 	movi	r2,1
 b006218:	d8800015 	stw	r2,0(sp)
 b00621c:	e1fffe04 	addi	r7,fp,-8
 b006220:	01800044 	movi	r6,1
 b006224:	000b883a 	mov	r5,zero
 b006228:	e13fff17 	ldw	r4,-4(fp)
 b00622c:	b0077e80 	call	b0077e8 <alt_avalon_spi_command>
    1,
    &status,
    0
  );

  return status;
 b006230:	e0bffe43 	ldbu	r2,-7(fp)
}
 b006234:	e037883a 	mov	sp,fp
 b006238:	dfc00117 	ldw	ra,4(sp)
 b00623c:	df000017 	ldw	fp,0(sp)
 b006240:	dec00204 	addi	sp,sp,8
 b006244:	f800283a 	ret

0b006248 <epcs_test_wip>:

static ALT_INLINE int epcs_test_wip(alt_u32 base)
{
 b006248:	defffd04 	addi	sp,sp,-12
 b00624c:	dfc00215 	stw	ra,8(sp)
 b006250:	df000115 	stw	fp,4(sp)
 b006254:	df000104 	addi	fp,sp,4
 b006258:	e13fff15 	stw	r4,-4(fp)
  return epcs_read_status_register(base) & 1;
 b00625c:	e13fff17 	ldw	r4,-4(fp)
 b006260:	b0061ec0 	call	b0061ec <epcs_read_status_register>
 b006264:	10803fcc 	andi	r2,r2,255
 b006268:	1080004c 	andi	r2,r2,1
}
 b00626c:	e037883a 	mov	sp,fp
 b006270:	dfc00117 	ldw	ra,4(sp)
 b006274:	df000017 	ldw	fp,0(sp)
 b006278:	dec00204 	addi	sp,sp,8
 b00627c:	f800283a 	ret

0b006280 <epcs_await_wip_released>:

static ALT_INLINE void epcs_await_wip_released(alt_u32 base)
{
 b006280:	defffd04 	addi	sp,sp,-12
 b006284:	dfc00215 	stw	ra,8(sp)
 b006288:	df000115 	stw	fp,4(sp)
 b00628c:	df000104 	addi	fp,sp,4
 b006290:	e13fff15 	stw	r4,-4(fp)
  /* Wait until the WIP bit goes low. */
  while (epcs_test_wip(base))
 b006294:	0001883a 	nop
 b006298:	e13fff17 	ldw	r4,-4(fp)
 b00629c:	b0062480 	call	b006248 <epcs_test_wip>
 b0062a0:	103ffd1e 	bne	r2,zero,b006298 <__alt_mem_flash+0xff005298>
  {
  }
}
 b0062a4:	0001883a 	nop
 b0062a8:	e037883a 	mov	sp,fp
 b0062ac:	dfc00117 	ldw	ra,4(sp)
 b0062b0:	df000017 	ldw	fp,0(sp)
 b0062b4:	dec00204 	addi	sp,sp,8
 b0062b8:	f800283a 	ret

0b0062bc <epcs_sector_erase>:

void epcs_sector_erase(alt_u32 base, alt_u32 offset, alt_u32 four_bytes_mode)
{
 b0062bc:	defff604 	addi	sp,sp,-40
 b0062c0:	dfc00915 	stw	ra,36(sp)
 b0062c4:	df000815 	stw	fp,32(sp)
 b0062c8:	df000804 	addi	fp,sp,32
 b0062cc:	e13ffd15 	stw	r4,-12(fp)
 b0062d0:	e17ffe15 	stw	r5,-8(fp)
 b0062d4:	e1bfff15 	stw	r6,-4(fp)
  alt_u8 se[5];
  alt_u8 len;
  
  if(four_bytes_mode)
 b0062d8:	e0bfff17 	ldw	r2,-4(fp)
 b0062dc:	10001226 	beq	r2,zero,b006328 <epcs_sector_erase+0x6c>
  {
      se[0] = epcs_se;  /* Note: Use epcs_se for Micron EPCS256 */
 b0062e0:	00bff604 	movi	r2,-40
 b0062e4:	e0bffb45 	stb	r2,-19(fp)
      se[1] = (offset >> 24) & 0xFF;
 b0062e8:	e0bffe17 	ldw	r2,-8(fp)
 b0062ec:	1004d63a 	srli	r2,r2,24
 b0062f0:	e0bffb85 	stb	r2,-18(fp)
      se[2] = (offset >> 16) & 0xFF;
 b0062f4:	e0bffe17 	ldw	r2,-8(fp)
 b0062f8:	1004d43a 	srli	r2,r2,16
 b0062fc:	e0bffbc5 	stb	r2,-17(fp)
      se[3] = (offset >> 8) & 0xFF;
 b006300:	e0bffe17 	ldw	r2,-8(fp)
 b006304:	1004d23a 	srli	r2,r2,8
 b006308:	e0bffc05 	stb	r2,-16(fp)
      se[4] = offset & 0xFF;
 b00630c:	e0bffe17 	ldw	r2,-8(fp)
 b006310:	e0bffc45 	stb	r2,-15(fp)
      len   = 5;
 b006314:	00800144 	movi	r2,5
 b006318:	e0bffb05 	stb	r2,-20(fp)
      epcs_enter_4_bytes_mode(base);
 b00631c:	e13ffd17 	ldw	r4,-12(fp)
 b006320:	b0067700 	call	b006770 <epcs_enter_4_bytes_mode>
 b006324:	00000c06 	br	b006358 <epcs_sector_erase+0x9c>
  }
  else
  {
      se[0] = epcs_se;
 b006328:	00bff604 	movi	r2,-40
 b00632c:	e0bffb45 	stb	r2,-19(fp)
      se[1] = (offset >> 16) & 0xFF;
 b006330:	e0bffe17 	ldw	r2,-8(fp)
 b006334:	1004d43a 	srli	r2,r2,16
 b006338:	e0bffb85 	stb	r2,-18(fp)
      se[2] = (offset >> 8) & 0xFF;
 b00633c:	e0bffe17 	ldw	r2,-8(fp)
 b006340:	1004d23a 	srli	r2,r2,8
 b006344:	e0bffbc5 	stb	r2,-17(fp)
      se[3] = offset & 0xFF;
 b006348:	e0bffe17 	ldw	r2,-8(fp)
 b00634c:	e0bffc05 	stb	r2,-16(fp)
      len   = 4;
 b006350:	00800104 	movi	r2,4
 b006354:	e0bffb05 	stb	r2,-20(fp)
  }

  /* Execute a WREN instruction */
  epcs_write_enable(base);
 b006358:	e13ffd17 	ldw	r4,-12(fp)
 b00635c:	b0064ac0 	call	b0064ac <epcs_write_enable>

  alt_avalon_spi_command(
 b006360:	e0bffb03 	ldbu	r2,-20(fp)
 b006364:	e0fffb44 	addi	r3,fp,-19
 b006368:	d8000215 	stw	zero,8(sp)
 b00636c:	d8000115 	stw	zero,4(sp)
 b006370:	d8000015 	stw	zero,0(sp)
 b006374:	180f883a 	mov	r7,r3
 b006378:	100d883a 	mov	r6,r2
 b00637c:	000b883a 	mov	r5,zero
 b006380:	e13ffd17 	ldw	r4,-12(fp)
 b006384:	b0077e80 	call	b0077e8 <alt_avalon_spi_command>
    0,
    (alt_u8*)0,
    0
  );

  epcs_await_wip_released(base);
 b006388:	e13ffd17 	ldw	r4,-12(fp)
 b00638c:	b0062800 	call	b006280 <epcs_await_wip_released>

  if(four_bytes_mode)
 b006390:	e0bfff17 	ldw	r2,-4(fp)
 b006394:	10000226 	beq	r2,zero,b0063a0 <epcs_sector_erase+0xe4>
  {
    epcs_exit_4_bytes_mode(base);
 b006398:	e13ffd17 	ldw	r4,-12(fp)
 b00639c:	b0067cc0 	call	b0067cc <epcs_exit_4_bytes_mode>
  }
}
 b0063a0:	0001883a 	nop
 b0063a4:	e037883a 	mov	sp,fp
 b0063a8:	dfc00117 	ldw	ra,4(sp)
 b0063ac:	df000017 	ldw	fp,0(sp)
 b0063b0:	dec00204 	addi	sp,sp,8
 b0063b4:	f800283a 	ret

0b0063b8 <epcs_read_buffer>:

alt_32 epcs_read_buffer(alt_u32 base, int offset, alt_u8 *dest_addr, int length,
                        alt_u32 four_bytes_mode)
{
 b0063b8:	defff404 	addi	sp,sp,-48
 b0063bc:	dfc00b15 	stw	ra,44(sp)
 b0063c0:	df000a15 	stw	fp,40(sp)
 b0063c4:	df000a04 	addi	fp,sp,40
 b0063c8:	e13ffc15 	stw	r4,-16(fp)
 b0063cc:	e17ffd15 	stw	r5,-12(fp)
 b0063d0:	e1bffe15 	stw	r6,-8(fp)
 b0063d4:	e1ffff15 	stw	r7,-4(fp)
  alt_u8 read_command[5];
  alt_u32 cmd_len;

  read_command[0] = epcs_read;
 b0063d8:	008000c4 	movi	r2,3
 b0063dc:	e0bffa05 	stb	r2,-24(fp)
  
  if(four_bytes_mode)
 b0063e0:	e0800217 	ldw	r2,8(fp)
 b0063e4:	10001026 	beq	r2,zero,b006428 <epcs_read_buffer+0x70>
  {
        read_command[1] = (offset >> 24) & 0xFF;
 b0063e8:	e0bffd17 	ldw	r2,-12(fp)
 b0063ec:	1004d63a 	srli	r2,r2,24
 b0063f0:	e0bffa45 	stb	r2,-23(fp)
        read_command[2] = (offset >> 16) & 0xFF;
 b0063f4:	e0bffd17 	ldw	r2,-12(fp)
 b0063f8:	1005d43a 	srai	r2,r2,16
 b0063fc:	e0bffa85 	stb	r2,-22(fp)
        read_command[3] = (offset >> 8) & 0xFF;
 b006400:	e0bffd17 	ldw	r2,-12(fp)
 b006404:	1005d23a 	srai	r2,r2,8
 b006408:	e0bffac5 	stb	r2,-21(fp)
        read_command[4] = offset & 0xFF;
 b00640c:	e0bffd17 	ldw	r2,-12(fp)
 b006410:	e0bffb05 	stb	r2,-20(fp)
        cmd_len = 5;
 b006414:	00800144 	movi	r2,5
 b006418:	e0bff915 	stw	r2,-28(fp)
        epcs_enter_4_bytes_mode(base);
 b00641c:	e13ffc17 	ldw	r4,-16(fp)
 b006420:	b0067700 	call	b006770 <epcs_enter_4_bytes_mode>
 b006424:	00000a06 	br	b006450 <epcs_read_buffer+0x98>
  }
  else
  {
        read_command[1] = (offset >> 16) & 0xFF;
 b006428:	e0bffd17 	ldw	r2,-12(fp)
 b00642c:	1005d43a 	srai	r2,r2,16
 b006430:	e0bffa45 	stb	r2,-23(fp)
        read_command[2] = (offset >> 8) & 0xFF;
 b006434:	e0bffd17 	ldw	r2,-12(fp)
 b006438:	1005d23a 	srai	r2,r2,8
 b00643c:	e0bffa85 	stb	r2,-22(fp)
        read_command[3] = offset & 0xFF;
 b006440:	e0bffd17 	ldw	r2,-12(fp)
 b006444:	e0bffac5 	stb	r2,-21(fp)
        cmd_len = 4;
 b006448:	00800104 	movi	r2,4
 b00644c:	e0bff915 	stw	r2,-28(fp)
  }

  epcs_await_wip_released(base);
 b006450:	e13ffc17 	ldw	r4,-16(fp)
 b006454:	b0062800 	call	b006280 <epcs_await_wip_released>

  alt_avalon_spi_command(
 b006458:	e0bfff17 	ldw	r2,-4(fp)
 b00645c:	e13ffa04 	addi	r4,fp,-24
 b006460:	d8000215 	stw	zero,8(sp)
 b006464:	e0fffe17 	ldw	r3,-8(fp)
 b006468:	d8c00115 	stw	r3,4(sp)
 b00646c:	d8800015 	stw	r2,0(sp)
 b006470:	200f883a 	mov	r7,r4
 b006474:	e1bff917 	ldw	r6,-28(fp)
 b006478:	000b883a 	mov	r5,zero
 b00647c:	e13ffc17 	ldw	r4,-16(fp)
 b006480:	b0077e80 	call	b0077e8 <alt_avalon_spi_command>
    length,
    (alt_u8*)dest_addr,
    0
  );

  if(four_bytes_mode)
 b006484:	e0800217 	ldw	r2,8(fp)
 b006488:	10000226 	beq	r2,zero,b006494 <epcs_read_buffer+0xdc>
  {
    epcs_exit_4_bytes_mode(base);
 b00648c:	e13ffc17 	ldw	r4,-16(fp)
 b006490:	b0067cc0 	call	b0067cc <epcs_exit_4_bytes_mode>
  }

  return length;
 b006494:	e0bfff17 	ldw	r2,-4(fp)
}
 b006498:	e037883a 	mov	sp,fp
 b00649c:	dfc00117 	ldw	ra,4(sp)
 b0064a0:	df000017 	ldw	fp,0(sp)
 b0064a4:	dec00204 	addi	sp,sp,8
 b0064a8:	f800283a 	ret

0b0064ac <epcs_write_enable>:

void epcs_write_enable(alt_u32 base)
{
 b0064ac:	defff904 	addi	sp,sp,-28
 b0064b0:	dfc00615 	stw	ra,24(sp)
 b0064b4:	df000515 	stw	fp,20(sp)
 b0064b8:	df000504 	addi	fp,sp,20
 b0064bc:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 wren = epcs_wren;
 b0064c0:	00800184 	movi	r2,6
 b0064c4:	e0bffe05 	stb	r2,-8(fp)
  alt_avalon_spi_command(
 b0064c8:	d8000215 	stw	zero,8(sp)
 b0064cc:	d8000115 	stw	zero,4(sp)
 b0064d0:	d8000015 	stw	zero,0(sp)
 b0064d4:	e1fffe04 	addi	r7,fp,-8
 b0064d8:	01800044 	movi	r6,1
 b0064dc:	000b883a 	mov	r5,zero
 b0064e0:	e13fff17 	ldw	r4,-4(fp)
 b0064e4:	b0077e80 	call	b0077e8 <alt_avalon_spi_command>
    &wren,
    0,
    (alt_u8*)0,
    0
  );
}
 b0064e8:	0001883a 	nop
 b0064ec:	e037883a 	mov	sp,fp
 b0064f0:	dfc00117 	ldw	ra,4(sp)
 b0064f4:	df000017 	ldw	fp,0(sp)
 b0064f8:	dec00204 	addi	sp,sp,8
 b0064fc:	f800283a 	ret

0b006500 <epcs_write_status_register>:

void epcs_write_status_register(alt_u32 base, alt_u8 value)
{
 b006500:	defff804 	addi	sp,sp,-32
 b006504:	dfc00715 	stw	ra,28(sp)
 b006508:	df000615 	stw	fp,24(sp)
 b00650c:	df000604 	addi	fp,sp,24
 b006510:	e13ffe15 	stw	r4,-8(fp)
 b006514:	2805883a 	mov	r2,r5
 b006518:	e0bfff05 	stb	r2,-4(fp)
  alt_u8 wrsr[2];
  
  wrsr[0] = epcs_wrsr;
 b00651c:	00800044 	movi	r2,1
 b006520:	e0bffd05 	stb	r2,-12(fp)
  wrsr[1] = value;
 b006524:	e0bfff03 	ldbu	r2,-4(fp)
 b006528:	e0bffd45 	stb	r2,-11(fp)

  alt_avalon_spi_command(
 b00652c:	d8000215 	stw	zero,8(sp)
 b006530:	d8000115 	stw	zero,4(sp)
 b006534:	d8000015 	stw	zero,0(sp)
 b006538:	e1fffd04 	addi	r7,fp,-12
 b00653c:	01800084 	movi	r6,2
 b006540:	000b883a 	mov	r5,zero
 b006544:	e13ffe17 	ldw	r4,-8(fp)
 b006548:	b0077e80 	call	b0077e8 <alt_avalon_spi_command>
    0,
    (alt_u8*)0,
    0
  );

  epcs_await_wip_released(base);
 b00654c:	e13ffe17 	ldw	r4,-8(fp)
 b006550:	b0062800 	call	b006280 <epcs_await_wip_released>
}
 b006554:	0001883a 	nop
 b006558:	e037883a 	mov	sp,fp
 b00655c:	dfc00117 	ldw	ra,4(sp)
 b006560:	df000017 	ldw	fp,0(sp)
 b006564:	dec00204 	addi	sp,sp,8
 b006568:	f800283a 	ret

0b00656c <epcs_write_buffer>:

/* Write a partial or full page, assuming that page has been erased */
alt_32 epcs_write_buffer(alt_u32 base, int offset, const alt_u8* src_addr, 
                         int length, alt_u32 four_bytes_mode)
{
 b00656c:	defff404 	addi	sp,sp,-48
 b006570:	dfc00b15 	stw	ra,44(sp)
 b006574:	df000a15 	stw	fp,40(sp)
 b006578:	df000a04 	addi	fp,sp,40
 b00657c:	e13ffc15 	stw	r4,-16(fp)
 b006580:	e17ffd15 	stw	r5,-12(fp)
 b006584:	e1bffe15 	stw	r6,-8(fp)
 b006588:	e1ffff15 	stw	r7,-4(fp)
  alt_u8 pp[5];
  alt_u32 cmd_len;
  
  pp[0] = epcs_pp;
 b00658c:	00800084 	movi	r2,2
 b006590:	e0bffa05 	stb	r2,-24(fp)
  
  if(four_bytes_mode)
 b006594:	e0800217 	ldw	r2,8(fp)
 b006598:	10001026 	beq	r2,zero,b0065dc <epcs_write_buffer+0x70>
  {
      pp[1] = (offset >> 24) & 0xFF;
 b00659c:	e0bffd17 	ldw	r2,-12(fp)
 b0065a0:	1004d63a 	srli	r2,r2,24
 b0065a4:	e0bffa45 	stb	r2,-23(fp)
      pp[2] = (offset >> 16) & 0xFF;
 b0065a8:	e0bffd17 	ldw	r2,-12(fp)
 b0065ac:	1005d43a 	srai	r2,r2,16
 b0065b0:	e0bffa85 	stb	r2,-22(fp)
      pp[3] = (offset >> 8) & 0xFF;
 b0065b4:	e0bffd17 	ldw	r2,-12(fp)
 b0065b8:	1005d23a 	srai	r2,r2,8
 b0065bc:	e0bffac5 	stb	r2,-21(fp)
      pp[4] = offset & 0xFF;
 b0065c0:	e0bffd17 	ldw	r2,-12(fp)
 b0065c4:	e0bffb05 	stb	r2,-20(fp)
      cmd_len = 5;
 b0065c8:	00800144 	movi	r2,5
 b0065cc:	e0bff915 	stw	r2,-28(fp)
      epcs_enter_4_bytes_mode(base);
 b0065d0:	e13ffc17 	ldw	r4,-16(fp)
 b0065d4:	b0067700 	call	b006770 <epcs_enter_4_bytes_mode>
 b0065d8:	00000a06 	br	b006604 <epcs_write_buffer+0x98>
  }
  else
  {
      pp[1] = (offset >> 16) & 0xFF;
 b0065dc:	e0bffd17 	ldw	r2,-12(fp)
 b0065e0:	1005d43a 	srai	r2,r2,16
 b0065e4:	e0bffa45 	stb	r2,-23(fp)
      pp[2] = (offset >> 8) & 0xFF;
 b0065e8:	e0bffd17 	ldw	r2,-12(fp)
 b0065ec:	1005d23a 	srai	r2,r2,8
 b0065f0:	e0bffa85 	stb	r2,-22(fp)
      pp[3] = offset & 0xFF;
 b0065f4:	e0bffd17 	ldw	r2,-12(fp)
 b0065f8:	e0bffac5 	stb	r2,-21(fp)
      cmd_len = 4;
 b0065fc:	00800104 	movi	r2,4
 b006600:	e0bff915 	stw	r2,-28(fp)
  }

  /* First, WREN */
  epcs_write_enable(base);
 b006604:	e13ffc17 	ldw	r4,-16(fp)
 b006608:	b0064ac0 	call	b0064ac <epcs_write_enable>

  /* Send the PP command */
  alt_avalon_spi_command(
 b00660c:	e0fffa04 	addi	r3,fp,-24
 b006610:	00800044 	movi	r2,1
 b006614:	d8800215 	stw	r2,8(sp)
 b006618:	d8000115 	stw	zero,4(sp)
 b00661c:	d8000015 	stw	zero,0(sp)
 b006620:	180f883a 	mov	r7,r3
 b006624:	e1bff917 	ldw	r6,-28(fp)
 b006628:	000b883a 	mov	r5,zero
 b00662c:	e13ffc17 	ldw	r4,-16(fp)
 b006630:	b0077e80 	call	b0077e8 <alt_avalon_spi_command>
    (alt_u8*)0,
    ALT_AVALON_SPI_COMMAND_MERGE
  );

  /* Send the user's buffer */
  alt_avalon_spi_command(
 b006634:	e0bfff17 	ldw	r2,-4(fp)
 b006638:	d8000215 	stw	zero,8(sp)
 b00663c:	d8000115 	stw	zero,4(sp)
 b006640:	d8000015 	stw	zero,0(sp)
 b006644:	e1fffe17 	ldw	r7,-8(fp)
 b006648:	100d883a 	mov	r6,r2
 b00664c:	000b883a 	mov	r5,zero
 b006650:	e13ffc17 	ldw	r4,-16(fp)
 b006654:	b0077e80 	call	b0077e8 <alt_avalon_spi_command>
   * if the user's going to go off and ignore the flash for
   * a while, its writes could occur in parallel with user code
   * execution.  Unfortunately, I have to guard all reads/writes
   * with wip-tests, to make that happen.
   */
  epcs_await_wip_released(base);
 b006658:	e13ffc17 	ldw	r4,-16(fp)
 b00665c:	b0062800 	call	b006280 <epcs_await_wip_released>

  if(four_bytes_mode)
 b006660:	e0800217 	ldw	r2,8(fp)
 b006664:	10000226 	beq	r2,zero,b006670 <epcs_write_buffer+0x104>
  {
    epcs_exit_4_bytes_mode(base);
 b006668:	e13ffc17 	ldw	r4,-16(fp)
 b00666c:	b0067cc0 	call	b0067cc <epcs_exit_4_bytes_mode>
  }

  return length;
 b006670:	e0bfff17 	ldw	r2,-4(fp)
}
 b006674:	e037883a 	mov	sp,fp
 b006678:	dfc00117 	ldw	ra,4(sp)
 b00667c:	df000017 	ldw	fp,0(sp)
 b006680:	dec00204 	addi	sp,sp,8
 b006684:	f800283a 	ret

0b006688 <epcs_read_electronic_signature>:


alt_u8 epcs_read_electronic_signature(alt_u32 base)
{
 b006688:	defff804 	addi	sp,sp,-32
 b00668c:	dfc00715 	stw	ra,28(sp)
 b006690:	df000615 	stw	fp,24(sp)
 b006694:	df000604 	addi	fp,sp,24
 b006698:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 res_cmd[] = {epcs_res, 0, 0, 0};
 b00669c:	00bfeac4 	movi	r2,-85
 b0066a0:	e0bffd05 	stb	r2,-12(fp)
 b0066a4:	e03ffd45 	stb	zero,-11(fp)
 b0066a8:	e03ffd85 	stb	zero,-10(fp)
 b0066ac:	e03ffdc5 	stb	zero,-9(fp)
  alt_u8 res;

  alt_avalon_spi_command(
 b0066b0:	d8000215 	stw	zero,8(sp)
 b0066b4:	e0bffe04 	addi	r2,fp,-8
 b0066b8:	d8800115 	stw	r2,4(sp)
 b0066bc:	00800044 	movi	r2,1
 b0066c0:	d8800015 	stw	r2,0(sp)
 b0066c4:	e1fffd04 	addi	r7,fp,-12
 b0066c8:	01800104 	movi	r6,4
 b0066cc:	000b883a 	mov	r5,zero
 b0066d0:	e13fff17 	ldw	r4,-4(fp)
 b0066d4:	b0077e80 	call	b0077e8 <alt_avalon_spi_command>
    1,
    &res,
    0
  );

  return res;
 b0066d8:	e0bffe03 	ldbu	r2,-8(fp)
}
 b0066dc:	e037883a 	mov	sp,fp
 b0066e0:	dfc00117 	ldw	ra,4(sp)
 b0066e4:	df000017 	ldw	fp,0(sp)
 b0066e8:	dec00204 	addi	sp,sp,8
 b0066ec:	f800283a 	ret

0b0066f0 <epcs_read_device_id>:

alt_u32 epcs_read_device_id(alt_u32 base)
{
 b0066f0:	defff904 	addi	sp,sp,-28
 b0066f4:	dfc00615 	stw	ra,24(sp)
 b0066f8:	df000515 	stw	fp,20(sp)
 b0066fc:	df000504 	addi	fp,sp,20
 b006700:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 rd_id_cmd[] = {epcs_rdid};
 b006704:	00bfe7c4 	movi	r2,-97
 b006708:	e0bffe05 	stb	r2,-8(fp)
  alt_u8 id[3];

  alt_avalon_spi_command(
 b00670c:	d8000215 	stw	zero,8(sp)
 b006710:	e0bffe44 	addi	r2,fp,-7
 b006714:	d8800115 	stw	r2,4(sp)
 b006718:	008000c4 	movi	r2,3
 b00671c:	d8800015 	stw	r2,0(sp)
 b006720:	e1fffe04 	addi	r7,fp,-8
 b006724:	01800044 	movi	r6,1
 b006728:	000b883a 	mov	r5,zero
 b00672c:	e13fff17 	ldw	r4,-4(fp)
 b006730:	b0077e80 	call	b0077e8 <alt_avalon_spi_command>
    3,
    id,
    0
  );

  return (alt_u32) ((id[0] << 16) | (id[1] << 8) | id[2]);
 b006734:	e0bffe43 	ldbu	r2,-7(fp)
 b006738:	10803fcc 	andi	r2,r2,255
 b00673c:	1006943a 	slli	r3,r2,16
 b006740:	e0bffe83 	ldbu	r2,-6(fp)
 b006744:	10803fcc 	andi	r2,r2,255
 b006748:	1004923a 	slli	r2,r2,8
 b00674c:	1886b03a 	or	r3,r3,r2
 b006750:	e0bffec3 	ldbu	r2,-5(fp)
 b006754:	10803fcc 	andi	r2,r2,255
 b006758:	1884b03a 	or	r2,r3,r2
}
 b00675c:	e037883a 	mov	sp,fp
 b006760:	dfc00117 	ldw	ra,4(sp)
 b006764:	df000017 	ldw	fp,0(sp)
 b006768:	dec00204 	addi	sp,sp,8
 b00676c:	f800283a 	ret

0b006770 <epcs_enter_4_bytes_mode>:

void epcs_enter_4_bytes_mode(alt_u32 base)
{
 b006770:	defff904 	addi	sp,sp,-28
 b006774:	dfc00615 	stw	ra,24(sp)
 b006778:	df000515 	stw	fp,20(sp)
 b00677c:	df000504 	addi	fp,sp,20
 b006780:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 en4b_cmd = epcs_en4b;
 b006784:	00bfedc4 	movi	r2,-73
 b006788:	e0bffe05 	stb	r2,-8(fp)

  /* First, WREN */
  epcs_write_enable(base);
 b00678c:	e13fff17 	ldw	r4,-4(fp)
 b006790:	b0064ac0 	call	b0064ac <epcs_write_enable>

  alt_avalon_spi_command(
 b006794:	d8000215 	stw	zero,8(sp)
 b006798:	d8000115 	stw	zero,4(sp)
 b00679c:	d8000015 	stw	zero,0(sp)
 b0067a0:	e1fffe04 	addi	r7,fp,-8
 b0067a4:	01800044 	movi	r6,1
 b0067a8:	000b883a 	mov	r5,zero
 b0067ac:	e13fff17 	ldw	r4,-4(fp)
 b0067b0:	b0077e80 	call	b0077e8 <alt_avalon_spi_command>
    0,
    (alt_u8*)0,
    0
  );

  return;
 b0067b4:	0001883a 	nop
}
 b0067b8:	e037883a 	mov	sp,fp
 b0067bc:	dfc00117 	ldw	ra,4(sp)
 b0067c0:	df000017 	ldw	fp,0(sp)
 b0067c4:	dec00204 	addi	sp,sp,8
 b0067c8:	f800283a 	ret

0b0067cc <epcs_exit_4_bytes_mode>:

void epcs_exit_4_bytes_mode(alt_u32 base)
{
 b0067cc:	defff904 	addi	sp,sp,-28
 b0067d0:	dfc00615 	stw	ra,24(sp)
 b0067d4:	df000515 	stw	fp,20(sp)
 b0067d8:	df000504 	addi	fp,sp,20
 b0067dc:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 exit4b_cmd = epcs_dis4b;
 b0067e0:	00bffa44 	movi	r2,-23
 b0067e4:	e0bffe05 	stb	r2,-8(fp)

  /* First, WREN */
  epcs_write_enable(base);
 b0067e8:	e13fff17 	ldw	r4,-4(fp)
 b0067ec:	b0064ac0 	call	b0064ac <epcs_write_enable>

  alt_avalon_spi_command(
 b0067f0:	d8000215 	stw	zero,8(sp)
 b0067f4:	d8000115 	stw	zero,4(sp)
 b0067f8:	d8000015 	stw	zero,0(sp)
 b0067fc:	e1fffe04 	addi	r7,fp,-8
 b006800:	01800044 	movi	r6,1
 b006804:	000b883a 	mov	r5,zero
 b006808:	e13fff17 	ldw	r4,-4(fp)
 b00680c:	b0077e80 	call	b0077e8 <alt_avalon_spi_command>
    0,
    (alt_u8*)0,
    0
  );

  return;
 b006810:	0001883a 	nop
}
 b006814:	e037883a 	mov	sp,fp
 b006818:	dfc00117 	ldw	ra,4(sp)
 b00681c:	df000017 	ldw	fp,0(sp)
 b006820:	dec00204 	addi	sp,sp,8
 b006824:	f800283a 	ret

0b006828 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
 b006828:	defff504 	addi	sp,sp,-44
 b00682c:	df000a15 	stw	fp,40(sp)
 b006830:	df000a04 	addi	fp,sp,40
 b006834:	e13ffc15 	stw	r4,-16(fp)
 b006838:	e17ffd15 	stw	r5,-12(fp)
 b00683c:	e1bffe15 	stw	r6,-8(fp)
 b006840:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
 b006844:	e03ff615 	stw	zero,-40(fp)
 b006848:	d0a61a17 	ldw	r2,-26520(gp)
  
  if (alt_ticks_per_second ())
 b00684c:	10003c26 	beq	r2,zero,b006940 <alt_alarm_start+0x118>
  {
    if (alarm)
 b006850:	e0bffc17 	ldw	r2,-16(fp)
 b006854:	10003826 	beq	r2,zero,b006938 <alt_alarm_start+0x110>
    {
      alarm->callback = callback;
 b006858:	e0bffc17 	ldw	r2,-16(fp)
 b00685c:	e0fffe17 	ldw	r3,-8(fp)
 b006860:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
 b006864:	e0bffc17 	ldw	r2,-16(fp)
 b006868:	e0ffff17 	ldw	r3,-4(fp)
 b00686c:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 b006870:	0005303a 	rdctl	r2,status
 b006874:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 b006878:	e0fff917 	ldw	r3,-28(fp)
 b00687c:	00bfff84 	movi	r2,-2
 b006880:	1884703a 	and	r2,r3,r2
 b006884:	1001703a 	wrctl	status,r2
  
  return context;
 b006888:	e0bff917 	ldw	r2,-28(fp)
 
      irq_context = alt_irq_disable_all ();
 b00688c:	e0bff815 	stw	r2,-32(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
 b006890:	d0a61b17 	ldw	r2,-26516(gp)
      
      current_nticks = alt_nticks();
 b006894:	e0bff615 	stw	r2,-40(fp)
      
      alarm->time = nticks + current_nticks + 1; 
 b006898:	e0fffd17 	ldw	r3,-12(fp)
 b00689c:	e0bff617 	ldw	r2,-40(fp)
 b0068a0:	1885883a 	add	r2,r3,r2
 b0068a4:	10c00044 	addi	r3,r2,1
 b0068a8:	e0bffc17 	ldw	r2,-16(fp)
 b0068ac:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
 b0068b0:	e0bffc17 	ldw	r2,-16(fp)
 b0068b4:	10c00217 	ldw	r3,8(r2)
 b0068b8:	e0bff617 	ldw	r2,-40(fp)
 b0068bc:	1880042e 	bgeu	r3,r2,b0068d0 <alt_alarm_start+0xa8>
      {
        alarm->rollover = 1;
 b0068c0:	e0bffc17 	ldw	r2,-16(fp)
 b0068c4:	00c00044 	movi	r3,1
 b0068c8:	10c00405 	stb	r3,16(r2)
 b0068cc:	00000206 	br	b0068d8 <alt_alarm_start+0xb0>
      }
      else
      {
        alarm->rollover = 0;
 b0068d0:	e0bffc17 	ldw	r2,-16(fp)
 b0068d4:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
 b0068d8:	e0bffc17 	ldw	r2,-16(fp)
 b0068dc:	d0e00c04 	addi	r3,gp,-32720
 b0068e0:	e0fffa15 	stw	r3,-24(fp)
 b0068e4:	e0bffb15 	stw	r2,-20(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 b0068e8:	e0bffb17 	ldw	r2,-20(fp)
 b0068ec:	e0fffa17 	ldw	r3,-24(fp)
 b0068f0:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 b0068f4:	e0bffa17 	ldw	r2,-24(fp)
 b0068f8:	10c00017 	ldw	r3,0(r2)
 b0068fc:	e0bffb17 	ldw	r2,-20(fp)
 b006900:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 b006904:	e0bffa17 	ldw	r2,-24(fp)
 b006908:	10800017 	ldw	r2,0(r2)
 b00690c:	e0fffb17 	ldw	r3,-20(fp)
 b006910:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 b006914:	e0bffa17 	ldw	r2,-24(fp)
 b006918:	e0fffb17 	ldw	r3,-20(fp)
 b00691c:	10c00015 	stw	r3,0(r2)
 b006920:	e0bff817 	ldw	r2,-32(fp)
 b006924:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 b006928:	e0bff717 	ldw	r2,-36(fp)
 b00692c:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
 b006930:	0005883a 	mov	r2,zero
 b006934:	00000306 	br	b006944 <alt_alarm_start+0x11c>
    }
    else
    {
      return -EINVAL;
 b006938:	00bffa84 	movi	r2,-22
 b00693c:	00000106 	br	b006944 <alt_alarm_start+0x11c>
    }
  }
  else
  {
    return -ENOTSUP;
 b006940:	00bfde84 	movi	r2,-134
  }
}
 b006944:	e037883a 	mov	sp,fp
 b006948:	df000017 	ldw	fp,0(sp)
 b00694c:	dec00104 	addi	sp,sp,4
 b006950:	f800283a 	ret

0b006954 <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
 b006954:	defffa04 	addi	sp,sp,-24
 b006958:	dfc00515 	stw	ra,20(sp)
 b00695c:	df000415 	stw	fp,16(sp)
 b006960:	df000404 	addi	fp,sp,16
 b006964:	e13fff15 	stw	r4,-4(fp)
  int big_loops;
  alt_u32 cycles_per_loop;
  
  if (!strcmp(NIOS2_CPU_IMPLEMENTATION,"tiny"))
  {
    cycles_per_loop = 9;
 b006968:	00800244 	movi	r2,9
 b00696c:	e0bffd15 	stw	r2,-12(fp)
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));
 b006970:	014003f4 	movhi	r5,15
 b006974:	29509004 	addi	r5,r5,16960
 b006978:	e13ffd17 	ldw	r4,-12(fp)
 b00697c:	b003fb80 	call	b003fb8 <__mulsi3>
 b006980:	100b883a 	mov	r5,r2
 b006984:	01017db4 	movhi	r4,1526
 b006988:	21384004 	addi	r4,r4,-7936
 b00698c:	b003efc0 	call	b003efc <__udivsi3>
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
 b006990:	100b883a 	mov	r5,r2
 b006994:	01200034 	movhi	r4,32768
 b006998:	213fffc4 	addi	r4,r4,-1
 b00699c:	b003efc0 	call	b003efc <__udivsi3>
 b0069a0:	100b883a 	mov	r5,r2
 b0069a4:	e13fff17 	ldw	r4,-4(fp)
 b0069a8:	b003efc0 	call	b003efc <__udivsi3>
 b0069ac:	e0bffe15 	stw	r2,-8(fp)
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
 b0069b0:	e0bffe17 	ldw	r2,-8(fp)
 b0069b4:	10002a26 	beq	r2,zero,b006a60 <alt_busy_sleep+0x10c>
  {
    for(i=0;i<big_loops;i++)
 b0069b8:	e03ffc15 	stw	zero,-16(fp)
 b0069bc:	00001706 	br	b006a1c <alt_busy_sleep+0xc8>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
 b0069c0:	00a00034 	movhi	r2,32768
 b0069c4:	10bfffc4 	addi	r2,r2,-1
 b0069c8:	10bfffc4 	addi	r2,r2,-1
 b0069cc:	103ffe1e 	bne	r2,zero,b0069c8 <__alt_mem_flash+0xff0059c8>
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
      (cycles_per_loop * 1000000)));
 b0069d0:	014003f4 	movhi	r5,15
 b0069d4:	29509004 	addi	r5,r5,16960
 b0069d8:	e13ffd17 	ldw	r4,-12(fp)
 b0069dc:	b003fb80 	call	b003fb8 <__mulsi3>
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
 b0069e0:	100b883a 	mov	r5,r2
 b0069e4:	01017db4 	movhi	r4,1526
 b0069e8:	21384004 	addi	r4,r4,-7936
 b0069ec:	b003efc0 	call	b003efc <__udivsi3>
 b0069f0:	100b883a 	mov	r5,r2
 b0069f4:	01200034 	movhi	r4,32768
 b0069f8:	213fffc4 	addi	r4,r4,-1
 b0069fc:	b003efc0 	call	b003efc <__udivsi3>
 b006a00:	1007883a 	mov	r3,r2
 b006a04:	e0bfff17 	ldw	r2,-4(fp)
 b006a08:	10c5c83a 	sub	r2,r2,r3
 b006a0c:	e0bfff15 	stw	r2,-4(fp)
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
 b006a10:	e0bffc17 	ldw	r2,-16(fp)
 b006a14:	10800044 	addi	r2,r2,1
 b006a18:	e0bffc15 	stw	r2,-16(fp)
 b006a1c:	e0fffc17 	ldw	r3,-16(fp)
 b006a20:	e0bffe17 	ldw	r2,-8(fp)
 b006a24:	18bfe616 	blt	r3,r2,b0069c0 <__alt_mem_flash+0xff0059c0>
      "\n\tbne %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
 b006a28:	014003f4 	movhi	r5,15
 b006a2c:	29509004 	addi	r5,r5,16960
 b006a30:	e13ffd17 	ldw	r4,-12(fp)
 b006a34:	b003fb80 	call	b003fb8 <__mulsi3>
 b006a38:	100b883a 	mov	r5,r2
 b006a3c:	01017db4 	movhi	r4,1526
 b006a40:	21384004 	addi	r4,r4,-7936
 b006a44:	b003efc0 	call	b003efc <__udivsi3>
 b006a48:	e17fff17 	ldw	r5,-4(fp)
 b006a4c:	1009883a 	mov	r4,r2
 b006a50:	b003fb80 	call	b003fb8 <__mulsi3>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
 b006a54:	10bfffc4 	addi	r2,r2,-1
 b006a58:	103ffe1e 	bne	r2,zero,b006a54 <__alt_mem_flash+0xff005a54>
 b006a5c:	00000d06 	br	b006a94 <alt_busy_sleep+0x140>
      "\n\tbgt %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
 b006a60:	014003f4 	movhi	r5,15
 b006a64:	29509004 	addi	r5,r5,16960
 b006a68:	e13ffd17 	ldw	r4,-12(fp)
 b006a6c:	b003fb80 	call	b003fb8 <__mulsi3>
 b006a70:	100b883a 	mov	r5,r2
 b006a74:	01017db4 	movhi	r4,1526
 b006a78:	21384004 	addi	r4,r4,-7936
 b006a7c:	b003efc0 	call	b003efc <__udivsi3>
 b006a80:	e17fff17 	ldw	r5,-4(fp)
 b006a84:	1009883a 	mov	r4,r2
 b006a88:	b003fb80 	call	b003fb8 <__mulsi3>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
 b006a8c:	10bfffc4 	addi	r2,r2,-1
 b006a90:	00bffe16 	blt	zero,r2,b006a8c <__alt_mem_flash+0xff005a8c>
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
 b006a94:	0005883a 	mov	r2,zero
}
 b006a98:	e037883a 	mov	sp,fp
 b006a9c:	dfc00117 	ldw	ra,4(sp)
 b006aa0:	df000017 	ldw	fp,0(sp)
 b006aa4:	dec00204 	addi	sp,sp,8
 b006aa8:	f800283a 	ret

0b006aac <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 b006aac:	defffe04 	addi	sp,sp,-8
 b006ab0:	dfc00115 	stw	ra,4(sp)
 b006ab4:	df000015 	stw	fp,0(sp)
 b006ab8:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 b006abc:	d0a00817 	ldw	r2,-32736(gp)
 b006ac0:	10000326 	beq	r2,zero,b006ad0 <alt_get_errno+0x24>
 b006ac4:	d0a00817 	ldw	r2,-32736(gp)
 b006ac8:	103ee83a 	callr	r2
 b006acc:	00000106 	br	b006ad4 <alt_get_errno+0x28>
 b006ad0:	d0a61d04 	addi	r2,gp,-26508
}
 b006ad4:	e037883a 	mov	sp,fp
 b006ad8:	dfc00117 	ldw	ra,4(sp)
 b006adc:	df000017 	ldw	fp,0(sp)
 b006ae0:	dec00204 	addi	sp,sp,8
 b006ae4:	f800283a 	ret

0b006ae8 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
 b006ae8:	defffb04 	addi	sp,sp,-20
 b006aec:	dfc00415 	stw	ra,16(sp)
 b006af0:	df000315 	stw	fp,12(sp)
 b006af4:	df000304 	addi	fp,sp,12
 b006af8:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
 b006afc:	e0bfff17 	ldw	r2,-4(fp)
 b006b00:	10000816 	blt	r2,zero,b006b24 <close+0x3c>
 b006b04:	01400304 	movi	r5,12
 b006b08:	e13fff17 	ldw	r4,-4(fp)
 b006b0c:	b003fb80 	call	b003fb8 <__mulsi3>
 b006b10:	1007883a 	mov	r3,r2
 b006b14:	0082c074 	movhi	r2,2817
 b006b18:	10a66904 	addi	r2,r2,-26204
 b006b1c:	1885883a 	add	r2,r3,r2
 b006b20:	00000106 	br	b006b28 <close+0x40>
 b006b24:	0005883a 	mov	r2,zero
 b006b28:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
 b006b2c:	e0bffd17 	ldw	r2,-12(fp)
 b006b30:	10001926 	beq	r2,zero,b006b98 <close+0xb0>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
 b006b34:	e0bffd17 	ldw	r2,-12(fp)
 b006b38:	10800017 	ldw	r2,0(r2)
 b006b3c:	10800417 	ldw	r2,16(r2)
 b006b40:	10000626 	beq	r2,zero,b006b5c <close+0x74>
 b006b44:	e0bffd17 	ldw	r2,-12(fp)
 b006b48:	10800017 	ldw	r2,0(r2)
 b006b4c:	10800417 	ldw	r2,16(r2)
 b006b50:	e13ffd17 	ldw	r4,-12(fp)
 b006b54:	103ee83a 	callr	r2
 b006b58:	00000106 	br	b006b60 <close+0x78>
 b006b5c:	0005883a 	mov	r2,zero
 b006b60:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
 b006b64:	e13fff17 	ldw	r4,-4(fp)
 b006b68:	b00759c0 	call	b00759c <alt_release_fd>
    if (rval < 0)
 b006b6c:	e0bffe17 	ldw	r2,-8(fp)
 b006b70:	1000070e 	bge	r2,zero,b006b90 <close+0xa8>
    {
      ALT_ERRNO = -rval;
 b006b74:	b006aac0 	call	b006aac <alt_get_errno>
 b006b78:	1007883a 	mov	r3,r2
 b006b7c:	e0bffe17 	ldw	r2,-8(fp)
 b006b80:	0085c83a 	sub	r2,zero,r2
 b006b84:	18800015 	stw	r2,0(r3)
      return -1;
 b006b88:	00bfffc4 	movi	r2,-1
 b006b8c:	00000706 	br	b006bac <close+0xc4>
    }
    return 0;
 b006b90:	0005883a 	mov	r2,zero
 b006b94:	00000506 	br	b006bac <close+0xc4>
  }
  else
  {
    ALT_ERRNO = EBADFD;
 b006b98:	b006aac0 	call	b006aac <alt_get_errno>
 b006b9c:	1007883a 	mov	r3,r2
 b006ba0:	00801444 	movi	r2,81
 b006ba4:	18800015 	stw	r2,0(r3)
    return -1;
 b006ba8:	00bfffc4 	movi	r2,-1
  }
}
 b006bac:	e037883a 	mov	sp,fp
 b006bb0:	dfc00117 	ldw	ra,4(sp)
 b006bb4:	df000017 	ldw	fp,0(sp)
 b006bb8:	dec00204 	addi	sp,sp,8
 b006bbc:	f800283a 	ret

0b006bc0 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
 b006bc0:	deffff04 	addi	sp,sp,-4
 b006bc4:	df000015 	stw	fp,0(sp)
 b006bc8:	d839883a 	mov	fp,sp
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
 b006bcc:	0001883a 	nop
 b006bd0:	e037883a 	mov	sp,fp
 b006bd4:	df000017 	ldw	fp,0(sp)
 b006bd8:	dec00104 	addi	sp,sp,4
 b006bdc:	f800283a 	ret

0b006be0 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
 b006be0:	defffc04 	addi	sp,sp,-16
 b006be4:	df000315 	stw	fp,12(sp)
 b006be8:	df000304 	addi	fp,sp,12
 b006bec:	e13ffd15 	stw	r4,-12(fp)
 b006bf0:	e17ffe15 	stw	r5,-8(fp)
 b006bf4:	e1bfff15 	stw	r6,-4(fp)
  return len;
 b006bf8:	e0bfff17 	ldw	r2,-4(fp)
}
 b006bfc:	e037883a 	mov	sp,fp
 b006c00:	df000017 	ldw	fp,0(sp)
 b006c04:	dec00104 	addi	sp,sp,4
 b006c08:	f800283a 	ret

0b006c0c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 b006c0c:	defffe04 	addi	sp,sp,-8
 b006c10:	dfc00115 	stw	ra,4(sp)
 b006c14:	df000015 	stw	fp,0(sp)
 b006c18:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 b006c1c:	d0a00817 	ldw	r2,-32736(gp)
 b006c20:	10000326 	beq	r2,zero,b006c30 <alt_get_errno+0x24>
 b006c24:	d0a00817 	ldw	r2,-32736(gp)
 b006c28:	103ee83a 	callr	r2
 b006c2c:	00000106 	br	b006c34 <alt_get_errno+0x28>
 b006c30:	d0a61d04 	addi	r2,gp,-26508
}
 b006c34:	e037883a 	mov	sp,fp
 b006c38:	dfc00117 	ldw	ra,4(sp)
 b006c3c:	df000017 	ldw	fp,0(sp)
 b006c40:	dec00204 	addi	sp,sp,8
 b006c44:	f800283a 	ret

0b006c48 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
 b006c48:	defffa04 	addi	sp,sp,-24
 b006c4c:	dfc00515 	stw	ra,20(sp)
 b006c50:	df000415 	stw	fp,16(sp)
 b006c54:	df000404 	addi	fp,sp,16
 b006c58:	e13ffe15 	stw	r4,-8(fp)
 b006c5c:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
 b006c60:	e0bffe17 	ldw	r2,-8(fp)
 b006c64:	10000326 	beq	r2,zero,b006c74 <alt_dev_llist_insert+0x2c>
 b006c68:	e0bffe17 	ldw	r2,-8(fp)
 b006c6c:	10800217 	ldw	r2,8(r2)
 b006c70:	1000061e 	bne	r2,zero,b006c8c <alt_dev_llist_insert+0x44>
  {
    ALT_ERRNO = EINVAL;
 b006c74:	b006c0c0 	call	b006c0c <alt_get_errno>
 b006c78:	1007883a 	mov	r3,r2
 b006c7c:	00800584 	movi	r2,22
 b006c80:	18800015 	stw	r2,0(r3)
    return -EINVAL;
 b006c84:	00bffa84 	movi	r2,-22
 b006c88:	00001306 	br	b006cd8 <alt_dev_llist_insert+0x90>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
 b006c8c:	e0bffe17 	ldw	r2,-8(fp)
 b006c90:	e0ffff17 	ldw	r3,-4(fp)
 b006c94:	e0fffc15 	stw	r3,-16(fp)
 b006c98:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 b006c9c:	e0bffd17 	ldw	r2,-12(fp)
 b006ca0:	e0fffc17 	ldw	r3,-16(fp)
 b006ca4:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 b006ca8:	e0bffc17 	ldw	r2,-16(fp)
 b006cac:	10c00017 	ldw	r3,0(r2)
 b006cb0:	e0bffd17 	ldw	r2,-12(fp)
 b006cb4:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 b006cb8:	e0bffc17 	ldw	r2,-16(fp)
 b006cbc:	10800017 	ldw	r2,0(r2)
 b006cc0:	e0fffd17 	ldw	r3,-12(fp)
 b006cc4:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 b006cc8:	e0bffc17 	ldw	r2,-16(fp)
 b006ccc:	e0fffd17 	ldw	r3,-12(fp)
 b006cd0:	10c00015 	stw	r3,0(r2)

  return 0;  
 b006cd4:	0005883a 	mov	r2,zero
}
 b006cd8:	e037883a 	mov	sp,fp
 b006cdc:	dfc00117 	ldw	ra,4(sp)
 b006ce0:	df000017 	ldw	fp,0(sp)
 b006ce4:	dec00204 	addi	sp,sp,8
 b006ce8:	f800283a 	ret

0b006cec <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
 b006cec:	defffd04 	addi	sp,sp,-12
 b006cf0:	dfc00215 	stw	ra,8(sp)
 b006cf4:	df000115 	stw	fp,4(sp)
 b006cf8:	df000104 	addi	fp,sp,4
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 b006cfc:	0082c074 	movhi	r2,2817
 b006d00:	10a06f04 	addi	r2,r2,-32324
 b006d04:	e0bfff15 	stw	r2,-4(fp)
 b006d08:	00000606 	br	b006d24 <_do_ctors+0x38>
        (*ctor) (); 
 b006d0c:	e0bfff17 	ldw	r2,-4(fp)
 b006d10:	10800017 	ldw	r2,0(r2)
 b006d14:	103ee83a 	callr	r2

void _do_ctors(void)
{
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 b006d18:	e0bfff17 	ldw	r2,-4(fp)
 b006d1c:	10bfff04 	addi	r2,r2,-4
 b006d20:	e0bfff15 	stw	r2,-4(fp)
 b006d24:	e0ffff17 	ldw	r3,-4(fp)
 b006d28:	0082c074 	movhi	r2,2817
 b006d2c:	10a07004 	addi	r2,r2,-32320
 b006d30:	18bff62e 	bgeu	r3,r2,b006d0c <__alt_mem_flash+0xff005d0c>
        (*ctor) (); 
}
 b006d34:	0001883a 	nop
 b006d38:	e037883a 	mov	sp,fp
 b006d3c:	dfc00117 	ldw	ra,4(sp)
 b006d40:	df000017 	ldw	fp,0(sp)
 b006d44:	dec00204 	addi	sp,sp,8
 b006d48:	f800283a 	ret

0b006d4c <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
 b006d4c:	defffd04 	addi	sp,sp,-12
 b006d50:	dfc00215 	stw	ra,8(sp)
 b006d54:	df000115 	stw	fp,4(sp)
 b006d58:	df000104 	addi	fp,sp,4
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 b006d5c:	0082c074 	movhi	r2,2817
 b006d60:	10a06f04 	addi	r2,r2,-32324
 b006d64:	e0bfff15 	stw	r2,-4(fp)
 b006d68:	00000606 	br	b006d84 <_do_dtors+0x38>
        (*dtor) (); 
 b006d6c:	e0bfff17 	ldw	r2,-4(fp)
 b006d70:	10800017 	ldw	r2,0(r2)
 b006d74:	103ee83a 	callr	r2

void _do_dtors(void)
{
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 b006d78:	e0bfff17 	ldw	r2,-4(fp)
 b006d7c:	10bfff04 	addi	r2,r2,-4
 b006d80:	e0bfff15 	stw	r2,-4(fp)
 b006d84:	e0ffff17 	ldw	r3,-4(fp)
 b006d88:	0082c074 	movhi	r2,2817
 b006d8c:	10a07004 	addi	r2,r2,-32320
 b006d90:	18bff62e 	bgeu	r3,r2,b006d6c <__alt_mem_flash+0xff005d6c>
        (*dtor) (); 
}
 b006d94:	0001883a 	nop
 b006d98:	e037883a 	mov	sp,fp
 b006d9c:	dfc00117 	ldw	ra,4(sp)
 b006da0:	df000017 	ldw	fp,0(sp)
 b006da4:	dec00204 	addi	sp,sp,8
 b006da8:	f800283a 	ret

0b006dac <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
 b006dac:	defffa04 	addi	sp,sp,-24
 b006db0:	dfc00515 	stw	ra,20(sp)
 b006db4:	df000415 	stw	fp,16(sp)
 b006db8:	df000404 	addi	fp,sp,16
 b006dbc:	e13ffe15 	stw	r4,-8(fp)
 b006dc0:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
 b006dc4:	e0bfff17 	ldw	r2,-4(fp)
 b006dc8:	10800017 	ldw	r2,0(r2)
 b006dcc:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
 b006dd0:	e13ffe17 	ldw	r4,-8(fp)
 b006dd4:	b007e5c0 	call	b007e5c <strlen>
 b006dd8:	10800044 	addi	r2,r2,1
 b006ddc:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 b006de0:	00000d06 	br	b006e18 <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
 b006de4:	e0bffc17 	ldw	r2,-16(fp)
 b006de8:	10800217 	ldw	r2,8(r2)
 b006dec:	e0fffd17 	ldw	r3,-12(fp)
 b006df0:	180d883a 	mov	r6,r3
 b006df4:	e17ffe17 	ldw	r5,-8(fp)
 b006df8:	1009883a 	mov	r4,r2
 b006dfc:	b007c980 	call	b007c98 <memcmp>
 b006e00:	1000021e 	bne	r2,zero,b006e0c <alt_find_dev+0x60>
    {
      /* match found */

      return next;
 b006e04:	e0bffc17 	ldw	r2,-16(fp)
 b006e08:	00000706 	br	b006e28 <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
 b006e0c:	e0bffc17 	ldw	r2,-16(fp)
 b006e10:	10800017 	ldw	r2,0(r2)
 b006e14:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 b006e18:	e0fffc17 	ldw	r3,-16(fp)
 b006e1c:	e0bfff17 	ldw	r2,-4(fp)
 b006e20:	18bff01e 	bne	r3,r2,b006de4 <__alt_mem_flash+0xff005de4>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
 b006e24:	0005883a 	mov	r2,zero
}
 b006e28:	e037883a 	mov	sp,fp
 b006e2c:	dfc00117 	ldw	ra,4(sp)
 b006e30:	df000017 	ldw	fp,0(sp)
 b006e34:	dec00204 	addi	sp,sp,8
 b006e38:	f800283a 	ret

0b006e3c <alt_flash_open_dev>:
#include "priv/alt_file.h"

ALT_LLIST_HEAD(alt_flash_dev_list);

alt_flash_fd* alt_flash_open_dev(const char* name)
{
 b006e3c:	defffc04 	addi	sp,sp,-16
 b006e40:	dfc00315 	stw	ra,12(sp)
 b006e44:	df000215 	stw	fp,8(sp)
 b006e48:	df000204 	addi	fp,sp,8
 b006e4c:	e13fff15 	stw	r4,-4(fp)
  alt_flash_dev* dev = (alt_flash_dev*)alt_find_dev(name, &alt_flash_dev_list);
 b006e50:	d1600904 	addi	r5,gp,-32732
 b006e54:	e13fff17 	ldw	r4,-4(fp)
 b006e58:	b006dac0 	call	b006dac <alt_find_dev>
 b006e5c:	e0bffe15 	stw	r2,-8(fp)

  if ((dev) && dev->open)
 b006e60:	e0bffe17 	ldw	r2,-8(fp)
 b006e64:	10000926 	beq	r2,zero,b006e8c <alt_flash_open_dev+0x50>
 b006e68:	e0bffe17 	ldw	r2,-8(fp)
 b006e6c:	10800317 	ldw	r2,12(r2)
 b006e70:	10000626 	beq	r2,zero,b006e8c <alt_flash_open_dev+0x50>
  {
    return dev->open(dev, name);
 b006e74:	e0bffe17 	ldw	r2,-8(fp)
 b006e78:	10800317 	ldw	r2,12(r2)
 b006e7c:	e17fff17 	ldw	r5,-4(fp)
 b006e80:	e13ffe17 	ldw	r4,-8(fp)
 b006e84:	103ee83a 	callr	r2
 b006e88:	00000106 	br	b006e90 <alt_flash_open_dev+0x54>
  }

  return dev;
 b006e8c:	e0bffe17 	ldw	r2,-8(fp)
}
 b006e90:	e037883a 	mov	sp,fp
 b006e94:	dfc00117 	ldw	ra,4(sp)
 b006e98:	df000017 	ldw	fp,0(sp)
 b006e9c:	dec00204 	addi	sp,sp,8
 b006ea0:	f800283a 	ret

0b006ea4 <alt_flash_close_dev>:

void alt_flash_close_dev(alt_flash_fd* fd)
{
 b006ea4:	defffd04 	addi	sp,sp,-12
 b006ea8:	dfc00215 	stw	ra,8(sp)
 b006eac:	df000115 	stw	fp,4(sp)
 b006eb0:	df000104 	addi	fp,sp,4
 b006eb4:	e13fff15 	stw	r4,-4(fp)
  if (fd && fd->close)
 b006eb8:	e0bfff17 	ldw	r2,-4(fp)
 b006ebc:	10000826 	beq	r2,zero,b006ee0 <alt_flash_close_dev+0x3c>
 b006ec0:	e0bfff17 	ldw	r2,-4(fp)
 b006ec4:	10800417 	ldw	r2,16(r2)
 b006ec8:	10000526 	beq	r2,zero,b006ee0 <alt_flash_close_dev+0x3c>
  {
    fd->close(fd);
 b006ecc:	e0bfff17 	ldw	r2,-4(fp)
 b006ed0:	10800417 	ldw	r2,16(r2)
 b006ed4:	e13fff17 	ldw	r4,-4(fp)
 b006ed8:	103ee83a 	callr	r2
  }
  return;
 b006edc:	0001883a 	nop
 b006ee0:	0001883a 	nop
}
 b006ee4:	e037883a 	mov	sp,fp
 b006ee8:	dfc00117 	ldw	ra,4(sp)
 b006eec:	df000017 	ldw	fp,0(sp)
 b006ef0:	dec00204 	addi	sp,sp,8
 b006ef4:	f800283a 	ret

0b006ef8 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
 b006ef8:	deffff04 	addi	sp,sp,-4
 b006efc:	df000015 	stw	fp,0(sp)
 b006f00:	d839883a 	mov	fp,sp
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
#endif
}
 b006f04:	0001883a 	nop
 b006f08:	e037883a 	mov	sp,fp
 b006f0c:	df000017 	ldw	fp,0(sp)
 b006f10:	dec00104 	addi	sp,sp,4
 b006f14:	f800283a 	ret

0b006f18 <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 b006f18:	defff904 	addi	sp,sp,-28
 b006f1c:	dfc00615 	stw	ra,24(sp)
 b006f20:	df000515 	stw	fp,20(sp)
 b006f24:	df000504 	addi	fp,sp,20
 b006f28:	e13ffc15 	stw	r4,-16(fp)
 b006f2c:	e17ffd15 	stw	r5,-12(fp)
 b006f30:	e1bffe15 	stw	r6,-8(fp)
 b006f34:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
 b006f38:	e0800217 	ldw	r2,8(fp)
 b006f3c:	d8800015 	stw	r2,0(sp)
 b006f40:	e1ffff17 	ldw	r7,-4(fp)
 b006f44:	e1bffe17 	ldw	r6,-8(fp)
 b006f48:	e17ffd17 	ldw	r5,-12(fp)
 b006f4c:	e13ffc17 	ldw	r4,-16(fp)
 b006f50:	b0070c80 	call	b0070c8 <alt_iic_isr_register>
}  
 b006f54:	e037883a 	mov	sp,fp
 b006f58:	dfc00117 	ldw	ra,4(sp)
 b006f5c:	df000017 	ldw	fp,0(sp)
 b006f60:	dec00204 	addi	sp,sp,8
 b006f64:	f800283a 	ret

0b006f68 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
 b006f68:	defff904 	addi	sp,sp,-28
 b006f6c:	df000615 	stw	fp,24(sp)
 b006f70:	df000604 	addi	fp,sp,24
 b006f74:	e13ffe15 	stw	r4,-8(fp)
 b006f78:	e17fff15 	stw	r5,-4(fp)
 b006f7c:	e0bfff17 	ldw	r2,-4(fp)
 b006f80:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 b006f84:	0005303a 	rdctl	r2,status
 b006f88:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 b006f8c:	e0fffb17 	ldw	r3,-20(fp)
 b006f90:	00bfff84 	movi	r2,-2
 b006f94:	1884703a 	and	r2,r3,r2
 b006f98:	1001703a 	wrctl	status,r2
  
  return context;
 b006f9c:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 b006fa0:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active |= (1 << id);
 b006fa4:	00c00044 	movi	r3,1
 b006fa8:	e0bffa17 	ldw	r2,-24(fp)
 b006fac:	1884983a 	sll	r2,r3,r2
 b006fb0:	1007883a 	mov	r3,r2
 b006fb4:	d0a61917 	ldw	r2,-26524(gp)
 b006fb8:	1884b03a 	or	r2,r3,r2
 b006fbc:	d0a61915 	stw	r2,-26524(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 b006fc0:	d0a61917 	ldw	r2,-26524(gp)
 b006fc4:	100170fa 	wrctl	ienable,r2
 b006fc8:	e0bffc17 	ldw	r2,-16(fp)
 b006fcc:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 b006fd0:	e0bffd17 	ldw	r2,-12(fp)
 b006fd4:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 b006fd8:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
 b006fdc:	0001883a 	nop
}
 b006fe0:	e037883a 	mov	sp,fp
 b006fe4:	df000017 	ldw	fp,0(sp)
 b006fe8:	dec00104 	addi	sp,sp,4
 b006fec:	f800283a 	ret

0b006ff0 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
 b006ff0:	defff904 	addi	sp,sp,-28
 b006ff4:	df000615 	stw	fp,24(sp)
 b006ff8:	df000604 	addi	fp,sp,24
 b006ffc:	e13ffe15 	stw	r4,-8(fp)
 b007000:	e17fff15 	stw	r5,-4(fp)
 b007004:	e0bfff17 	ldw	r2,-4(fp)
 b007008:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 b00700c:	0005303a 	rdctl	r2,status
 b007010:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 b007014:	e0fffb17 	ldw	r3,-20(fp)
 b007018:	00bfff84 	movi	r2,-2
 b00701c:	1884703a 	and	r2,r3,r2
 b007020:	1001703a 	wrctl	status,r2
  
  return context;
 b007024:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 b007028:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active &= ~(1 << id);
 b00702c:	00c00044 	movi	r3,1
 b007030:	e0bffa17 	ldw	r2,-24(fp)
 b007034:	1884983a 	sll	r2,r3,r2
 b007038:	0084303a 	nor	r2,zero,r2
 b00703c:	1007883a 	mov	r3,r2
 b007040:	d0a61917 	ldw	r2,-26524(gp)
 b007044:	1884703a 	and	r2,r3,r2
 b007048:	d0a61915 	stw	r2,-26524(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 b00704c:	d0a61917 	ldw	r2,-26524(gp)
 b007050:	100170fa 	wrctl	ienable,r2
 b007054:	e0bffc17 	ldw	r2,-16(fp)
 b007058:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 b00705c:	e0bffd17 	ldw	r2,-12(fp)
 b007060:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 b007064:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
 b007068:	0001883a 	nop
}
 b00706c:	e037883a 	mov	sp,fp
 b007070:	df000017 	ldw	fp,0(sp)
 b007074:	dec00104 	addi	sp,sp,4
 b007078:	f800283a 	ret

0b00707c <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
 b00707c:	defffc04 	addi	sp,sp,-16
 b007080:	df000315 	stw	fp,12(sp)
 b007084:	df000304 	addi	fp,sp,12
 b007088:	e13ffe15 	stw	r4,-8(fp)
 b00708c:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
 b007090:	000530fa 	rdctl	r2,ienable
 b007094:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
 b007098:	00c00044 	movi	r3,1
 b00709c:	e0bfff17 	ldw	r2,-4(fp)
 b0070a0:	1884983a 	sll	r2,r3,r2
 b0070a4:	1007883a 	mov	r3,r2
 b0070a8:	e0bffd17 	ldw	r2,-12(fp)
 b0070ac:	1884703a 	and	r2,r3,r2
 b0070b0:	1004c03a 	cmpne	r2,r2,zero
 b0070b4:	10803fcc 	andi	r2,r2,255
}
 b0070b8:	e037883a 	mov	sp,fp
 b0070bc:	df000017 	ldw	fp,0(sp)
 b0070c0:	dec00104 	addi	sp,sp,4
 b0070c4:	f800283a 	ret

0b0070c8 <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 b0070c8:	defff504 	addi	sp,sp,-44
 b0070cc:	dfc00a15 	stw	ra,40(sp)
 b0070d0:	df000915 	stw	fp,36(sp)
 b0070d4:	df000904 	addi	fp,sp,36
 b0070d8:	e13ffc15 	stw	r4,-16(fp)
 b0070dc:	e17ffd15 	stw	r5,-12(fp)
 b0070e0:	e1bffe15 	stw	r6,-8(fp)
 b0070e4:	e1ffff15 	stw	r7,-4(fp)
  int rc = -EINVAL;  
 b0070e8:	00bffa84 	movi	r2,-22
 b0070ec:	e0bff715 	stw	r2,-36(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
 b0070f0:	e0bffd17 	ldw	r2,-12(fp)
 b0070f4:	e0bff815 	stw	r2,-32(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
 b0070f8:	e0bff817 	ldw	r2,-32(fp)
 b0070fc:	10800808 	cmpgei	r2,r2,32
 b007100:	1000271e 	bne	r2,zero,b0071a0 <alt_iic_isr_register+0xd8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 b007104:	0005303a 	rdctl	r2,status
 b007108:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 b00710c:	e0fffb17 	ldw	r3,-20(fp)
 b007110:	00bfff84 	movi	r2,-2
 b007114:	1884703a 	and	r2,r3,r2
 b007118:	1001703a 	wrctl	status,r2
  
  return context;
 b00711c:	e0bffb17 	ldw	r2,-20(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
 b007120:	e0bffa15 	stw	r2,-24(fp)

    alt_irq[id].handler = isr;
 b007124:	0082c074 	movhi	r2,2817
 b007128:	10ace704 	addi	r2,r2,-19556
 b00712c:	e0fff817 	ldw	r3,-32(fp)
 b007130:	180690fa 	slli	r3,r3,3
 b007134:	10c5883a 	add	r2,r2,r3
 b007138:	e0fffe17 	ldw	r3,-8(fp)
 b00713c:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = isr_context;
 b007140:	0082c074 	movhi	r2,2817
 b007144:	10ace704 	addi	r2,r2,-19556
 b007148:	e0fff817 	ldw	r3,-32(fp)
 b00714c:	180690fa 	slli	r3,r3,3
 b007150:	10c5883a 	add	r2,r2,r3
 b007154:	10800104 	addi	r2,r2,4
 b007158:	e0ffff17 	ldw	r3,-4(fp)
 b00715c:	10c00015 	stw	r3,0(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
 b007160:	e0bffe17 	ldw	r2,-8(fp)
 b007164:	10000526 	beq	r2,zero,b00717c <alt_iic_isr_register+0xb4>
 b007168:	e0bff817 	ldw	r2,-32(fp)
 b00716c:	100b883a 	mov	r5,r2
 b007170:	e13ffc17 	ldw	r4,-16(fp)
 b007174:	b006f680 	call	b006f68 <alt_ic_irq_enable>
 b007178:	00000406 	br	b00718c <alt_iic_isr_register+0xc4>
 b00717c:	e0bff817 	ldw	r2,-32(fp)
 b007180:	100b883a 	mov	r5,r2
 b007184:	e13ffc17 	ldw	r4,-16(fp)
 b007188:	b006ff00 	call	b006ff0 <alt_ic_irq_disable>
 b00718c:	e0bff715 	stw	r2,-36(fp)
 b007190:	e0bffa17 	ldw	r2,-24(fp)
 b007194:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 b007198:	e0bff917 	ldw	r2,-28(fp)
 b00719c:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
 b0071a0:	e0bff717 	ldw	r2,-36(fp)
}
 b0071a4:	e037883a 	mov	sp,fp
 b0071a8:	dfc00117 	ldw	ra,4(sp)
 b0071ac:	df000017 	ldw	fp,0(sp)
 b0071b0:	dec00204 	addi	sp,sp,8
 b0071b4:	f800283a 	ret

0b0071b8 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
 b0071b8:	defff804 	addi	sp,sp,-32
 b0071bc:	dfc00715 	stw	ra,28(sp)
 b0071c0:	df000615 	stw	fp,24(sp)
 b0071c4:	dc000515 	stw	r16,20(sp)
 b0071c8:	df000604 	addi	fp,sp,24
 b0071cc:	e13ffb15 	stw	r4,-20(fp)
 b0071d0:	e17ffc15 	stw	r5,-16(fp)
 b0071d4:	e1bffd15 	stw	r6,-12(fp)
 b0071d8:	e1fffe15 	stw	r7,-8(fp)
  int old;

  old = open (name, flags, mode);
 b0071dc:	e1bffe17 	ldw	r6,-8(fp)
 b0071e0:	e17ffd17 	ldw	r5,-12(fp)
 b0071e4:	e13ffc17 	ldw	r4,-16(fp)
 b0071e8:	b0074400 	call	b007440 <open>
 b0071ec:	e0bffa15 	stw	r2,-24(fp)

  if (old >= 0)
 b0071f0:	e0bffa17 	ldw	r2,-24(fp)
 b0071f4:	10002216 	blt	r2,zero,b007280 <alt_open_fd+0xc8>
  {
    fd->dev      = alt_fd_list[old].dev;
 b0071f8:	0402c074 	movhi	r16,2817
 b0071fc:	84266904 	addi	r16,r16,-26204
 b007200:	e0bffa17 	ldw	r2,-24(fp)
 b007204:	01400304 	movi	r5,12
 b007208:	1009883a 	mov	r4,r2
 b00720c:	b003fb80 	call	b003fb8 <__mulsi3>
 b007210:	8085883a 	add	r2,r16,r2
 b007214:	10c00017 	ldw	r3,0(r2)
 b007218:	e0bffb17 	ldw	r2,-20(fp)
 b00721c:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
 b007220:	0402c074 	movhi	r16,2817
 b007224:	84266904 	addi	r16,r16,-26204
 b007228:	e0bffa17 	ldw	r2,-24(fp)
 b00722c:	01400304 	movi	r5,12
 b007230:	1009883a 	mov	r4,r2
 b007234:	b003fb80 	call	b003fb8 <__mulsi3>
 b007238:	8085883a 	add	r2,r16,r2
 b00723c:	10800104 	addi	r2,r2,4
 b007240:	10c00017 	ldw	r3,0(r2)
 b007244:	e0bffb17 	ldw	r2,-20(fp)
 b007248:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
 b00724c:	0402c074 	movhi	r16,2817
 b007250:	84266904 	addi	r16,r16,-26204
 b007254:	e0bffa17 	ldw	r2,-24(fp)
 b007258:	01400304 	movi	r5,12
 b00725c:	1009883a 	mov	r4,r2
 b007260:	b003fb80 	call	b003fb8 <__mulsi3>
 b007264:	8085883a 	add	r2,r16,r2
 b007268:	10800204 	addi	r2,r2,8
 b00726c:	10c00017 	ldw	r3,0(r2)
 b007270:	e0bffb17 	ldw	r2,-20(fp)
 b007274:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
 b007278:	e13ffa17 	ldw	r4,-24(fp)
 b00727c:	b00759c0 	call	b00759c <alt_release_fd>
  }
} 
 b007280:	0001883a 	nop
 b007284:	e6ffff04 	addi	sp,fp,-4
 b007288:	dfc00217 	ldw	ra,8(sp)
 b00728c:	df000117 	ldw	fp,4(sp)
 b007290:	dc000017 	ldw	r16,0(sp)
 b007294:	dec00304 	addi	sp,sp,12
 b007298:	f800283a 	ret

0b00729c <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
 b00729c:	defffb04 	addi	sp,sp,-20
 b0072a0:	dfc00415 	stw	ra,16(sp)
 b0072a4:	df000315 	stw	fp,12(sp)
 b0072a8:	df000304 	addi	fp,sp,12
 b0072ac:	e13ffd15 	stw	r4,-12(fp)
 b0072b0:	e17ffe15 	stw	r5,-8(fp)
 b0072b4:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
 b0072b8:	01c07fc4 	movi	r7,511
 b0072bc:	01800044 	movi	r6,1
 b0072c0:	e17ffd17 	ldw	r5,-12(fp)
 b0072c4:	0102c074 	movhi	r4,2817
 b0072c8:	21266c04 	addi	r4,r4,-26192
 b0072cc:	b0071b80 	call	b0071b8 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
 b0072d0:	01c07fc4 	movi	r7,511
 b0072d4:	000d883a 	mov	r6,zero
 b0072d8:	e17ffe17 	ldw	r5,-8(fp)
 b0072dc:	0102c074 	movhi	r4,2817
 b0072e0:	21266904 	addi	r4,r4,-26204
 b0072e4:	b0071b80 	call	b0071b8 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
 b0072e8:	01c07fc4 	movi	r7,511
 b0072ec:	01800044 	movi	r6,1
 b0072f0:	e17fff17 	ldw	r5,-4(fp)
 b0072f4:	0102c074 	movhi	r4,2817
 b0072f8:	21266f04 	addi	r4,r4,-26180
 b0072fc:	b0071b80 	call	b0071b8 <alt_open_fd>
}  
 b007300:	0001883a 	nop
 b007304:	e037883a 	mov	sp,fp
 b007308:	dfc00117 	ldw	ra,4(sp)
 b00730c:	df000017 	ldw	fp,0(sp)
 b007310:	dec00204 	addi	sp,sp,8
 b007314:	f800283a 	ret

0b007318 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 b007318:	defffe04 	addi	sp,sp,-8
 b00731c:	dfc00115 	stw	ra,4(sp)
 b007320:	df000015 	stw	fp,0(sp)
 b007324:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 b007328:	d0a00817 	ldw	r2,-32736(gp)
 b00732c:	10000326 	beq	r2,zero,b00733c <alt_get_errno+0x24>
 b007330:	d0a00817 	ldw	r2,-32736(gp)
 b007334:	103ee83a 	callr	r2
 b007338:	00000106 	br	b007340 <alt_get_errno+0x28>
 b00733c:	d0a61d04 	addi	r2,gp,-26508
}
 b007340:	e037883a 	mov	sp,fp
 b007344:	dfc00117 	ldw	ra,4(sp)
 b007348:	df000017 	ldw	fp,0(sp)
 b00734c:	dec00204 	addi	sp,sp,8
 b007350:	f800283a 	ret

0b007354 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
 b007354:	defffb04 	addi	sp,sp,-20
 b007358:	dfc00415 	stw	ra,16(sp)
 b00735c:	df000315 	stw	fp,12(sp)
 b007360:	dc000215 	stw	r16,8(sp)
 b007364:	df000304 	addi	fp,sp,12
 b007368:	e13ffe15 	stw	r4,-8(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
 b00736c:	e0bffe17 	ldw	r2,-8(fp)
 b007370:	10800217 	ldw	r2,8(r2)
 b007374:	10d00034 	orhi	r3,r2,16384
 b007378:	e0bffe17 	ldw	r2,-8(fp)
 b00737c:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 b007380:	e03ffd15 	stw	zero,-12(fp)
 b007384:	00002306 	br	b007414 <alt_file_locked+0xc0>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
 b007388:	0402c074 	movhi	r16,2817
 b00738c:	84266904 	addi	r16,r16,-26204
 b007390:	e0bffd17 	ldw	r2,-12(fp)
 b007394:	01400304 	movi	r5,12
 b007398:	1009883a 	mov	r4,r2
 b00739c:	b003fb80 	call	b003fb8 <__mulsi3>
 b0073a0:	8085883a 	add	r2,r16,r2
 b0073a4:	10c00017 	ldw	r3,0(r2)
 b0073a8:	e0bffe17 	ldw	r2,-8(fp)
 b0073ac:	10800017 	ldw	r2,0(r2)
 b0073b0:	1880151e 	bne	r3,r2,b007408 <alt_file_locked+0xb4>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
 b0073b4:	0402c074 	movhi	r16,2817
 b0073b8:	84266904 	addi	r16,r16,-26204
 b0073bc:	e0bffd17 	ldw	r2,-12(fp)
 b0073c0:	01400304 	movi	r5,12
 b0073c4:	1009883a 	mov	r4,r2
 b0073c8:	b003fb80 	call	b003fb8 <__mulsi3>
 b0073cc:	8085883a 	add	r2,r16,r2
 b0073d0:	10800204 	addi	r2,r2,8
 b0073d4:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
 b0073d8:	10000b0e 	bge	r2,zero,b007408 <alt_file_locked+0xb4>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
 b0073dc:	01400304 	movi	r5,12
 b0073e0:	e13ffd17 	ldw	r4,-12(fp)
 b0073e4:	b003fb80 	call	b003fb8 <__mulsi3>
 b0073e8:	1007883a 	mov	r3,r2
 b0073ec:	0082c074 	movhi	r2,2817
 b0073f0:	10a66904 	addi	r2,r2,-26204
 b0073f4:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
 b0073f8:	e0bffe17 	ldw	r2,-8(fp)
 b0073fc:	18800226 	beq	r3,r2,b007408 <alt_file_locked+0xb4>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
 b007400:	00bffcc4 	movi	r2,-13
 b007404:	00000806 	br	b007428 <alt_file_locked+0xd4>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 b007408:	e0bffd17 	ldw	r2,-12(fp)
 b00740c:	10800044 	addi	r2,r2,1
 b007410:	e0bffd15 	stw	r2,-12(fp)
 b007414:	d0a00717 	ldw	r2,-32740(gp)
 b007418:	1007883a 	mov	r3,r2
 b00741c:	e0bffd17 	ldw	r2,-12(fp)
 b007420:	18bfd92e 	bgeu	r3,r2,b007388 <__alt_mem_flash+0xff006388>
    }
  }
  
  /* The device is not locked */
 
  return 0;
 b007424:	0005883a 	mov	r2,zero
}
 b007428:	e6ffff04 	addi	sp,fp,-4
 b00742c:	dfc00217 	ldw	ra,8(sp)
 b007430:	df000117 	ldw	fp,4(sp)
 b007434:	dc000017 	ldw	r16,0(sp)
 b007438:	dec00304 	addi	sp,sp,12
 b00743c:	f800283a 	ret

0b007440 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
 b007440:	defff604 	addi	sp,sp,-40
 b007444:	dfc00915 	stw	ra,36(sp)
 b007448:	df000815 	stw	fp,32(sp)
 b00744c:	df000804 	addi	fp,sp,32
 b007450:	e13ffd15 	stw	r4,-12(fp)
 b007454:	e17ffe15 	stw	r5,-8(fp)
 b007458:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
 b00745c:	00bfffc4 	movi	r2,-1
 b007460:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
 b007464:	00bffb44 	movi	r2,-19
 b007468:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
 b00746c:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
 b007470:	d1600504 	addi	r5,gp,-32748
 b007474:	e13ffd17 	ldw	r4,-12(fp)
 b007478:	b006dac0 	call	b006dac <alt_find_dev>
 b00747c:	e0bff815 	stw	r2,-32(fp)
 b007480:	e0bff817 	ldw	r2,-32(fp)
 b007484:	1000051e 	bne	r2,zero,b00749c <open+0x5c>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
 b007488:	e13ffd17 	ldw	r4,-12(fp)
 b00748c:	b0079e40 	call	b0079e4 <alt_find_file>
 b007490:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
 b007494:	00800044 	movi	r2,1
 b007498:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
 b00749c:	e0bff817 	ldw	r2,-32(fp)
 b0074a0:	10002b26 	beq	r2,zero,b007550 <open+0x110>
  {
    if ((index = alt_get_fd (dev)) < 0)
 b0074a4:	e13ff817 	ldw	r4,-32(fp)
 b0074a8:	b007aec0 	call	b007aec <alt_get_fd>
 b0074ac:	e0bff915 	stw	r2,-28(fp)
 b0074b0:	e0bff917 	ldw	r2,-28(fp)
 b0074b4:	1000030e 	bge	r2,zero,b0074c4 <open+0x84>
    {
      status = index;
 b0074b8:	e0bff917 	ldw	r2,-28(fp)
 b0074bc:	e0bffa15 	stw	r2,-24(fp)
 b0074c0:	00002506 	br	b007558 <open+0x118>
    }
    else
    {
      fd = &alt_fd_list[index];
 b0074c4:	01400304 	movi	r5,12
 b0074c8:	e13ff917 	ldw	r4,-28(fp)
 b0074cc:	b003fb80 	call	b003fb8 <__mulsi3>
 b0074d0:	1007883a 	mov	r3,r2
 b0074d4:	0082c074 	movhi	r2,2817
 b0074d8:	10a66904 	addi	r2,r2,-26204
 b0074dc:	1885883a 	add	r2,r3,r2
 b0074e0:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
 b0074e4:	e0fffe17 	ldw	r3,-8(fp)
 b0074e8:	00900034 	movhi	r2,16384
 b0074ec:	10bfffc4 	addi	r2,r2,-1
 b0074f0:	1886703a 	and	r3,r3,r2
 b0074f4:	e0bffc17 	ldw	r2,-16(fp)
 b0074f8:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
 b0074fc:	e0bffb17 	ldw	r2,-20(fp)
 b007500:	1000051e 	bne	r2,zero,b007518 <open+0xd8>
 b007504:	e13ffc17 	ldw	r4,-16(fp)
 b007508:	b0073540 	call	b007354 <alt_file_locked>
 b00750c:	e0bffa15 	stw	r2,-24(fp)
 b007510:	e0bffa17 	ldw	r2,-24(fp)
 b007514:	10001016 	blt	r2,zero,b007558 <open+0x118>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
 b007518:	e0bff817 	ldw	r2,-32(fp)
 b00751c:	10800317 	ldw	r2,12(r2)
 b007520:	10000826 	beq	r2,zero,b007544 <open+0x104>
 b007524:	e0bff817 	ldw	r2,-32(fp)
 b007528:	10800317 	ldw	r2,12(r2)
 b00752c:	e1ffff17 	ldw	r7,-4(fp)
 b007530:	e1bffe17 	ldw	r6,-8(fp)
 b007534:	e17ffd17 	ldw	r5,-12(fp)
 b007538:	e13ffc17 	ldw	r4,-16(fp)
 b00753c:	103ee83a 	callr	r2
 b007540:	00000106 	br	b007548 <open+0x108>
 b007544:	0005883a 	mov	r2,zero
 b007548:	e0bffa15 	stw	r2,-24(fp)
 b00754c:	00000206 	br	b007558 <open+0x118>
      }
    }
  }
  else
  {
    status = -ENODEV;
 b007550:	00bffb44 	movi	r2,-19
 b007554:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
 b007558:	e0bffa17 	ldw	r2,-24(fp)
 b00755c:	1000090e 	bge	r2,zero,b007584 <open+0x144>
  {
    alt_release_fd (index);  
 b007560:	e13ff917 	ldw	r4,-28(fp)
 b007564:	b00759c0 	call	b00759c <alt_release_fd>
    ALT_ERRNO = -status;
 b007568:	b0073180 	call	b007318 <alt_get_errno>
 b00756c:	1007883a 	mov	r3,r2
 b007570:	e0bffa17 	ldw	r2,-24(fp)
 b007574:	0085c83a 	sub	r2,zero,r2
 b007578:	18800015 	stw	r2,0(r3)
    return -1;
 b00757c:	00bfffc4 	movi	r2,-1
 b007580:	00000106 	br	b007588 <open+0x148>
  }
  
  /* return the reference upon success */

  return index;
 b007584:	e0bff917 	ldw	r2,-28(fp)
}
 b007588:	e037883a 	mov	sp,fp
 b00758c:	dfc00117 	ldw	ra,4(sp)
 b007590:	df000017 	ldw	fp,0(sp)
 b007594:	dec00204 	addi	sp,sp,8
 b007598:	f800283a 	ret

0b00759c <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
 b00759c:	defffc04 	addi	sp,sp,-16
 b0075a0:	dfc00315 	stw	ra,12(sp)
 b0075a4:	df000215 	stw	fp,8(sp)
 b0075a8:	dc000115 	stw	r16,4(sp)
 b0075ac:	df000204 	addi	fp,sp,8
 b0075b0:	e13ffe15 	stw	r4,-8(fp)
  if (fd > 2)
 b0075b4:	e0bffe17 	ldw	r2,-8(fp)
 b0075b8:	108000d0 	cmplti	r2,r2,3
 b0075bc:	1000111e 	bne	r2,zero,b007604 <alt_release_fd+0x68>
  {
    alt_fd_list[fd].fd_flags = 0;
 b0075c0:	0402c074 	movhi	r16,2817
 b0075c4:	84266904 	addi	r16,r16,-26204
 b0075c8:	e0bffe17 	ldw	r2,-8(fp)
 b0075cc:	01400304 	movi	r5,12
 b0075d0:	1009883a 	mov	r4,r2
 b0075d4:	b003fb80 	call	b003fb8 <__mulsi3>
 b0075d8:	8085883a 	add	r2,r16,r2
 b0075dc:	10800204 	addi	r2,r2,8
 b0075e0:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
 b0075e4:	0402c074 	movhi	r16,2817
 b0075e8:	84266904 	addi	r16,r16,-26204
 b0075ec:	e0bffe17 	ldw	r2,-8(fp)
 b0075f0:	01400304 	movi	r5,12
 b0075f4:	1009883a 	mov	r4,r2
 b0075f8:	b003fb80 	call	b003fb8 <__mulsi3>
 b0075fc:	8085883a 	add	r2,r16,r2
 b007600:	10000015 	stw	zero,0(r2)
  }
}
 b007604:	0001883a 	nop
 b007608:	e6ffff04 	addi	sp,fp,-4
 b00760c:	dfc00217 	ldw	ra,8(sp)
 b007610:	df000117 	ldw	fp,4(sp)
 b007614:	dc000017 	ldw	r16,0(sp)
 b007618:	dec00304 	addi	sp,sp,12
 b00761c:	f800283a 	ret

0b007620 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
 b007620:	defffa04 	addi	sp,sp,-24
 b007624:	df000515 	stw	fp,20(sp)
 b007628:	df000504 	addi	fp,sp,20
 b00762c:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 b007630:	0005303a 	rdctl	r2,status
 b007634:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 b007638:	e0fffc17 	ldw	r3,-16(fp)
 b00763c:	00bfff84 	movi	r2,-2
 b007640:	1884703a 	and	r2,r3,r2
 b007644:	1001703a 	wrctl	status,r2
  
  return context;
 b007648:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
 b00764c:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
 b007650:	e0bfff17 	ldw	r2,-4(fp)
 b007654:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
 b007658:	e0bffd17 	ldw	r2,-12(fp)
 b00765c:	10800017 	ldw	r2,0(r2)
 b007660:	e0fffd17 	ldw	r3,-12(fp)
 b007664:	18c00117 	ldw	r3,4(r3)
 b007668:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
 b00766c:	e0bffd17 	ldw	r2,-12(fp)
 b007670:	10800117 	ldw	r2,4(r2)
 b007674:	e0fffd17 	ldw	r3,-12(fp)
 b007678:	18c00017 	ldw	r3,0(r3)
 b00767c:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
 b007680:	e0bffd17 	ldw	r2,-12(fp)
 b007684:	e0fffd17 	ldw	r3,-12(fp)
 b007688:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
 b00768c:	e0bffd17 	ldw	r2,-12(fp)
 b007690:	e0fffd17 	ldw	r3,-12(fp)
 b007694:	10c00015 	stw	r3,0(r2)
 b007698:	e0bffb17 	ldw	r2,-20(fp)
 b00769c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 b0076a0:	e0bffe17 	ldw	r2,-8(fp)
 b0076a4:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
 b0076a8:	0001883a 	nop
 b0076ac:	e037883a 	mov	sp,fp
 b0076b0:	df000017 	ldw	fp,0(sp)
 b0076b4:	dec00104 	addi	sp,sp,4
 b0076b8:	f800283a 	ret

0b0076bc <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
 b0076bc:	defffb04 	addi	sp,sp,-20
 b0076c0:	dfc00415 	stw	ra,16(sp)
 b0076c4:	df000315 	stw	fp,12(sp)
 b0076c8:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
 b0076cc:	d0a00c17 	ldw	r2,-32720(gp)
 b0076d0:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
 b0076d4:	d0a61b17 	ldw	r2,-26516(gp)
 b0076d8:	10800044 	addi	r2,r2,1
 b0076dc:	d0a61b15 	stw	r2,-26516(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 b0076e0:	00002e06 	br	b00779c <alt_tick+0xe0>
  {
    next = (alt_alarm*) alarm->llist.next;
 b0076e4:	e0bffd17 	ldw	r2,-12(fp)
 b0076e8:	10800017 	ldw	r2,0(r2)
 b0076ec:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
 b0076f0:	e0bffd17 	ldw	r2,-12(fp)
 b0076f4:	10800403 	ldbu	r2,16(r2)
 b0076f8:	10803fcc 	andi	r2,r2,255
 b0076fc:	10000426 	beq	r2,zero,b007710 <alt_tick+0x54>
 b007700:	d0a61b17 	ldw	r2,-26516(gp)
 b007704:	1000021e 	bne	r2,zero,b007710 <alt_tick+0x54>
    {
      alarm->rollover = 0;
 b007708:	e0bffd17 	ldw	r2,-12(fp)
 b00770c:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
 b007710:	e0bffd17 	ldw	r2,-12(fp)
 b007714:	10800217 	ldw	r2,8(r2)
 b007718:	d0e61b17 	ldw	r3,-26516(gp)
 b00771c:	18801d36 	bltu	r3,r2,b007794 <alt_tick+0xd8>
 b007720:	e0bffd17 	ldw	r2,-12(fp)
 b007724:	10800403 	ldbu	r2,16(r2)
 b007728:	10803fcc 	andi	r2,r2,255
 b00772c:	1000191e 	bne	r2,zero,b007794 <alt_tick+0xd8>
    {
      next_callback = alarm->callback (alarm->context);
 b007730:	e0bffd17 	ldw	r2,-12(fp)
 b007734:	10800317 	ldw	r2,12(r2)
 b007738:	e0fffd17 	ldw	r3,-12(fp)
 b00773c:	18c00517 	ldw	r3,20(r3)
 b007740:	1809883a 	mov	r4,r3
 b007744:	103ee83a 	callr	r2
 b007748:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
 b00774c:	e0bfff17 	ldw	r2,-4(fp)
 b007750:	1000031e 	bne	r2,zero,b007760 <alt_tick+0xa4>
      {
        alt_alarm_stop (alarm);
 b007754:	e13ffd17 	ldw	r4,-12(fp)
 b007758:	b0076200 	call	b007620 <alt_alarm_stop>
 b00775c:	00000d06 	br	b007794 <alt_tick+0xd8>
      }
      else
      {
        alarm->time += next_callback;
 b007760:	e0bffd17 	ldw	r2,-12(fp)
 b007764:	10c00217 	ldw	r3,8(r2)
 b007768:	e0bfff17 	ldw	r2,-4(fp)
 b00776c:	1887883a 	add	r3,r3,r2
 b007770:	e0bffd17 	ldw	r2,-12(fp)
 b007774:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
 b007778:	e0bffd17 	ldw	r2,-12(fp)
 b00777c:	10c00217 	ldw	r3,8(r2)
 b007780:	d0a61b17 	ldw	r2,-26516(gp)
 b007784:	1880032e 	bgeu	r3,r2,b007794 <alt_tick+0xd8>
        {
          alarm->rollover = 1;
 b007788:	e0bffd17 	ldw	r2,-12(fp)
 b00778c:	00c00044 	movi	r3,1
 b007790:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
 b007794:	e0bffe17 	ldw	r2,-8(fp)
 b007798:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 b00779c:	e0fffd17 	ldw	r3,-12(fp)
 b0077a0:	d0a00c04 	addi	r2,gp,-32720
 b0077a4:	18bfcf1e 	bne	r3,r2,b0076e4 <__alt_mem_flash+0xff0066e4>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
 b0077a8:	0001883a 	nop
}
 b0077ac:	0001883a 	nop
 b0077b0:	e037883a 	mov	sp,fp
 b0077b4:	dfc00117 	ldw	ra,4(sp)
 b0077b8:	df000017 	ldw	fp,0(sp)
 b0077bc:	dec00204 	addi	sp,sp,8
 b0077c0:	f800283a 	ret

0b0077c4 <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
 b0077c4:	deffff04 	addi	sp,sp,-4
 b0077c8:	df000015 	stw	fp,0(sp)
 b0077cc:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
 b0077d0:	000170fa 	wrctl	ienable,zero
}
 b0077d4:	0001883a 	nop
 b0077d8:	e037883a 	mov	sp,fp
 b0077dc:	df000017 	ldw	fp,0(sp)
 b0077e0:	dec00104 	addi	sp,sp,4
 b0077e4:	f800283a 	ret

0b0077e8 <alt_avalon_spi_command>:

int alt_avalon_spi_command(alt_u32 base, alt_u32 slave,
                           alt_u32 write_length, const alt_u8 * write_data,
                           alt_u32 read_length, alt_u8 * read_data,
                           alt_u32 flags)
{
 b0077e8:	defff404 	addi	sp,sp,-48
 b0077ec:	df000b15 	stw	fp,44(sp)
 b0077f0:	df000b04 	addi	fp,sp,44
 b0077f4:	e13ffc15 	stw	r4,-16(fp)
 b0077f8:	e17ffd15 	stw	r5,-12(fp)
 b0077fc:	e1bffe15 	stw	r6,-8(fp)
 b007800:	e1ffff15 	stw	r7,-4(fp)
  const alt_u8 * write_end = write_data + write_length;
 b007804:	e0ffff17 	ldw	r3,-4(fp)
 b007808:	e0bffe17 	ldw	r2,-8(fp)
 b00780c:	1885883a 	add	r2,r3,r2
 b007810:	e0bff815 	stw	r2,-32(fp)
  alt_u8 * read_end = read_data + read_length;
 b007814:	e0c00217 	ldw	r3,8(fp)
 b007818:	e0800117 	ldw	r2,4(fp)
 b00781c:	1885883a 	add	r2,r3,r2
 b007820:	e0bff915 	stw	r2,-28(fp)

  alt_u32 write_zeros = read_length;
 b007824:	e0800117 	ldw	r2,4(fp)
 b007828:	e0bff515 	stw	r2,-44(fp)
  alt_u32 read_ignore = write_length;
 b00782c:	e0bffe17 	ldw	r2,-8(fp)
 b007830:	e0bff615 	stw	r2,-40(fp)

  /* We must not send more than two bytes to the target before it has
   * returned any as otherwise it will overflow. */
  /* Unfortunately the hardware does not seem to work with credits > 1,
   * leave it at 1 for now. */
  alt_32 credits = 1;
 b007834:	00800044 	movi	r2,1
 b007838:	e0bff715 	stw	r2,-36(fp)
  /* Warning: this function is not currently safe if called in a multi-threaded
   * environment, something above must perform locking to make it safe if more
   * than one thread intends to use it.
   */

  IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(base, 1 << slave);
 b00783c:	e0bffc17 	ldw	r2,-16(fp)
 b007840:	10800504 	addi	r2,r2,20
 b007844:	1009883a 	mov	r4,r2
 b007848:	00c00044 	movi	r3,1
 b00784c:	e0bffd17 	ldw	r2,-12(fp)
 b007850:	1884983a 	sll	r2,r3,r2
 b007854:	20800035 	stwio	r2,0(r4)
  
  /* Set the SSO bit (force chipselect) only if the toggle flag is not set */
  if ((flags & ALT_AVALON_SPI_COMMAND_TOGGLE_SS_N) == 0) {
 b007858:	e0800317 	ldw	r2,12(fp)
 b00785c:	1080008c 	andi	r2,r2,2
 b007860:	1000051e 	bne	r2,zero,b007878 <alt_avalon_spi_command+0x90>
    IOWR_ALTERA_AVALON_SPI_CONTROL(base, ALTERA_AVALON_SPI_CONTROL_SSO_MSK);
 b007864:	e0bffc17 	ldw	r2,-16(fp)
 b007868:	10800304 	addi	r2,r2,12
 b00786c:	1007883a 	mov	r3,r2
 b007870:	00810004 	movi	r2,1024
 b007874:	18800035 	stwio	r2,0(r3)
  /*
   * Discard any stale data present in the RXDATA register, in case
   * previous communication was interrupted and stale data was left
   * behind.
   */
  IORD_ALTERA_AVALON_SPI_RXDATA(base);
 b007878:	e0bffc17 	ldw	r2,-16(fp)
 b00787c:	10800037 	ldwio	r2,0(r2)
  for ( ; ; )
  {
    
    do
    {
      status = IORD_ALTERA_AVALON_SPI_STATUS(base);
 b007880:	e0bffc17 	ldw	r2,-16(fp)
 b007884:	10800204 	addi	r2,r2,8
 b007888:	10800037 	ldwio	r2,0(r2)
 b00788c:	e0bffa15 	stw	r2,-24(fp)
    }
    while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
 b007890:	e0bffa17 	ldw	r2,-24(fp)
 b007894:	1080100c 	andi	r2,r2,64
            (status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) == 0);
 b007898:	10000226 	beq	r2,zero,b0078a4 <alt_avalon_spi_command+0xbc>
    
    do
    {
      status = IORD_ALTERA_AVALON_SPI_STATUS(base);
    }
    while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
 b00789c:	e0bff717 	ldw	r2,-36(fp)
 b0078a0:	1000031e 	bne	r2,zero,b0078b0 <alt_avalon_spi_command+0xc8>
            (status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) == 0);
 b0078a4:	e0bffa17 	ldw	r2,-24(fp)
 b0078a8:	1080200c 	andi	r2,r2,128
    
    do
    {
      status = IORD_ALTERA_AVALON_SPI_STATUS(base);
    }
    while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
 b0078ac:	103ff426 	beq	r2,zero,b007880 <__alt_mem_flash+0xff006880>
            (status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) == 0);

    if ((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) != 0 && credits > 0)
 b0078b0:	e0bffa17 	ldw	r2,-24(fp)
 b0078b4:	1080100c 	andi	r2,r2,64
 b0078b8:	10001e26 	beq	r2,zero,b007934 <alt_avalon_spi_command+0x14c>
 b0078bc:	e0bff717 	ldw	r2,-36(fp)
 b0078c0:	00801c0e 	bge	zero,r2,b007934 <alt_avalon_spi_command+0x14c>
    {
      credits--;
 b0078c4:	e0bff717 	ldw	r2,-36(fp)
 b0078c8:	10bfffc4 	addi	r2,r2,-1
 b0078cc:	e0bff715 	stw	r2,-36(fp)

      if (write_data < write_end)
 b0078d0:	e0ffff17 	ldw	r3,-4(fp)
 b0078d4:	e0bff817 	ldw	r2,-32(fp)
 b0078d8:	18800a2e 	bgeu	r3,r2,b007904 <alt_avalon_spi_command+0x11c>
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, *write_data++);
 b0078dc:	e0bffc17 	ldw	r2,-16(fp)
 b0078e0:	10800104 	addi	r2,r2,4
 b0078e4:	1009883a 	mov	r4,r2
 b0078e8:	e0bfff17 	ldw	r2,-4(fp)
 b0078ec:	10c00044 	addi	r3,r2,1
 b0078f0:	e0ffff15 	stw	r3,-4(fp)
 b0078f4:	10800003 	ldbu	r2,0(r2)
 b0078f8:	10803fcc 	andi	r2,r2,255
 b0078fc:	20800035 	stwio	r2,0(r4)
 b007900:	00000c06 	br	b007934 <alt_avalon_spi_command+0x14c>
      else if (write_zeros > 0)
 b007904:	e0bff517 	ldw	r2,-44(fp)
 b007908:	10000826 	beq	r2,zero,b00792c <alt_avalon_spi_command+0x144>
      {
        write_zeros--;
 b00790c:	e0bff517 	ldw	r2,-44(fp)
 b007910:	10bfffc4 	addi	r2,r2,-1
 b007914:	e0bff515 	stw	r2,-44(fp)
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, 0);
 b007918:	e0bffc17 	ldw	r2,-16(fp)
 b00791c:	10800104 	addi	r2,r2,4
 b007920:	0007883a 	mov	r3,zero
 b007924:	10c00035 	stwio	r3,0(r2)
 b007928:	00000206 	br	b007934 <alt_avalon_spi_command+0x14c>
      }
      else
        credits = -1024;
 b00792c:	00bf0004 	movi	r2,-1024
 b007930:	e0bff715 	stw	r2,-36(fp)
    };

    if ((status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) != 0)
 b007934:	e0bffa17 	ldw	r2,-24(fp)
 b007938:	1080200c 	andi	r2,r2,128
 b00793c:	103fd026 	beq	r2,zero,b007880 <__alt_mem_flash+0xff006880>
    {
      alt_u32 rxdata = IORD_ALTERA_AVALON_SPI_RXDATA(base);
 b007940:	e0bffc17 	ldw	r2,-16(fp)
 b007944:	10800037 	ldwio	r2,0(r2)
 b007948:	e0bffb15 	stw	r2,-20(fp)

      if (read_ignore > 0)
 b00794c:	e0bff617 	ldw	r2,-40(fp)
 b007950:	10000426 	beq	r2,zero,b007964 <alt_avalon_spi_command+0x17c>
        read_ignore--;
 b007954:	e0bff617 	ldw	r2,-40(fp)
 b007958:	10bfffc4 	addi	r2,r2,-1
 b00795c:	e0bff615 	stw	r2,-40(fp)
 b007960:	00000506 	br	b007978 <alt_avalon_spi_command+0x190>
      else
        *read_data++ = (alt_u8)rxdata;
 b007964:	e0800217 	ldw	r2,8(fp)
 b007968:	10c00044 	addi	r3,r2,1
 b00796c:	e0c00215 	stw	r3,8(fp)
 b007970:	e0fffb17 	ldw	r3,-20(fp)
 b007974:	10c00005 	stb	r3,0(r2)
      credits++;
 b007978:	e0bff717 	ldw	r2,-36(fp)
 b00797c:	10800044 	addi	r2,r2,1
 b007980:	e0bff715 	stw	r2,-36(fp)

      if (read_ignore == 0 && read_data == read_end)
 b007984:	e0bff617 	ldw	r2,-40(fp)
 b007988:	103fbd1e 	bne	r2,zero,b007880 <__alt_mem_flash+0xff006880>
 b00798c:	e0c00217 	ldw	r3,8(fp)
 b007990:	e0bff917 	ldw	r2,-28(fp)
 b007994:	18bfba1e 	bne	r3,r2,b007880 <__alt_mem_flash+0xff006880>
  }

  /* Wait until the interface has finished transmitting */
  do
  {
    status = IORD_ALTERA_AVALON_SPI_STATUS(base);
 b007998:	e0bffc17 	ldw	r2,-16(fp)
 b00799c:	10800204 	addi	r2,r2,8
 b0079a0:	10800037 	ldwio	r2,0(r2)
 b0079a4:	e0bffa15 	stw	r2,-24(fp)
  }
  while ((status & ALTERA_AVALON_SPI_STATUS_TMT_MSK) == 0);
 b0079a8:	e0bffa17 	ldw	r2,-24(fp)
 b0079ac:	1080080c 	andi	r2,r2,32
 b0079b0:	103ff926 	beq	r2,zero,b007998 <__alt_mem_flash+0xff006998>

  /* Clear SSO (release chipselect) unless the caller is going to
   * keep using this chip
   */
  if ((flags & ALT_AVALON_SPI_COMMAND_MERGE) == 0)
 b0079b4:	e0800317 	ldw	r2,12(fp)
 b0079b8:	1080004c 	andi	r2,r2,1
 b0079bc:	1000041e 	bne	r2,zero,b0079d0 <alt_avalon_spi_command+0x1e8>
    IOWR_ALTERA_AVALON_SPI_CONTROL(base, 0);
 b0079c0:	e0bffc17 	ldw	r2,-16(fp)
 b0079c4:	10800304 	addi	r2,r2,12
 b0079c8:	0007883a 	mov	r3,zero
 b0079cc:	10c00035 	stwio	r3,0(r2)

  return read_length;
 b0079d0:	e0800117 	ldw	r2,4(fp)
}
 b0079d4:	e037883a 	mov	sp,fp
 b0079d8:	df000017 	ldw	fp,0(sp)
 b0079dc:	dec00104 	addi	sp,sp,4
 b0079e0:	f800283a 	ret

0b0079e4 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
 b0079e4:	defffb04 	addi	sp,sp,-20
 b0079e8:	dfc00415 	stw	ra,16(sp)
 b0079ec:	df000315 	stw	fp,12(sp)
 b0079f0:	df000304 	addi	fp,sp,12
 b0079f4:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
 b0079f8:	d0a00317 	ldw	r2,-32756(gp)
 b0079fc:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 b007a00:	00003106 	br	b007ac8 <alt_find_file+0xe4>
  {
    len = strlen(next->name);
 b007a04:	e0bffd17 	ldw	r2,-12(fp)
 b007a08:	10800217 	ldw	r2,8(r2)
 b007a0c:	1009883a 	mov	r4,r2
 b007a10:	b007e5c0 	call	b007e5c <strlen>
 b007a14:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
 b007a18:	e0bffd17 	ldw	r2,-12(fp)
 b007a1c:	10c00217 	ldw	r3,8(r2)
 b007a20:	e0bffe17 	ldw	r2,-8(fp)
 b007a24:	10bfffc4 	addi	r2,r2,-1
 b007a28:	1885883a 	add	r2,r3,r2
 b007a2c:	10800003 	ldbu	r2,0(r2)
 b007a30:	10803fcc 	andi	r2,r2,255
 b007a34:	1080201c 	xori	r2,r2,128
 b007a38:	10bfe004 	addi	r2,r2,-128
 b007a3c:	10800bd8 	cmpnei	r2,r2,47
 b007a40:	1000031e 	bne	r2,zero,b007a50 <alt_find_file+0x6c>
    {
      len -= 1;
 b007a44:	e0bffe17 	ldw	r2,-8(fp)
 b007a48:	10bfffc4 	addi	r2,r2,-1
 b007a4c:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
 b007a50:	e0bffe17 	ldw	r2,-8(fp)
 b007a54:	e0ffff17 	ldw	r3,-4(fp)
 b007a58:	1885883a 	add	r2,r3,r2
 b007a5c:	10800003 	ldbu	r2,0(r2)
 b007a60:	10803fcc 	andi	r2,r2,255
 b007a64:	1080201c 	xori	r2,r2,128
 b007a68:	10bfe004 	addi	r2,r2,-128
 b007a6c:	10800be0 	cmpeqi	r2,r2,47
 b007a70:	1000081e 	bne	r2,zero,b007a94 <alt_find_file+0xb0>
 b007a74:	e0bffe17 	ldw	r2,-8(fp)
 b007a78:	e0ffff17 	ldw	r3,-4(fp)
 b007a7c:	1885883a 	add	r2,r3,r2
 b007a80:	10800003 	ldbu	r2,0(r2)
 b007a84:	10803fcc 	andi	r2,r2,255
 b007a88:	1080201c 	xori	r2,r2,128
 b007a8c:	10bfe004 	addi	r2,r2,-128
 b007a90:	10000a1e 	bne	r2,zero,b007abc <alt_find_file+0xd8>
        !memcmp (next->name, name, len))
 b007a94:	e0bffd17 	ldw	r2,-12(fp)
 b007a98:	10800217 	ldw	r2,8(r2)
 b007a9c:	e0fffe17 	ldw	r3,-8(fp)
 b007aa0:	180d883a 	mov	r6,r3
 b007aa4:	e17fff17 	ldw	r5,-4(fp)
 b007aa8:	1009883a 	mov	r4,r2
 b007aac:	b007c980 	call	b007c98 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
 b007ab0:	1000021e 	bne	r2,zero,b007abc <alt_find_file+0xd8>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
 b007ab4:	e0bffd17 	ldw	r2,-12(fp)
 b007ab8:	00000706 	br	b007ad8 <alt_find_file+0xf4>
    }
    next = (alt_dev*) next->llist.next;
 b007abc:	e0bffd17 	ldw	r2,-12(fp)
 b007ac0:	10800017 	ldw	r2,0(r2)
 b007ac4:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 b007ac8:	e0fffd17 	ldw	r3,-12(fp)
 b007acc:	d0a00304 	addi	r2,gp,-32756
 b007ad0:	18bfcc1e 	bne	r3,r2,b007a04 <__alt_mem_flash+0xff006a04>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
 b007ad4:	0005883a 	mov	r2,zero
}
 b007ad8:	e037883a 	mov	sp,fp
 b007adc:	dfc00117 	ldw	ra,4(sp)
 b007ae0:	df000017 	ldw	fp,0(sp)
 b007ae4:	dec00204 	addi	sp,sp,8
 b007ae8:	f800283a 	ret

0b007aec <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
 b007aec:	defffa04 	addi	sp,sp,-24
 b007af0:	dfc00515 	stw	ra,20(sp)
 b007af4:	df000415 	stw	fp,16(sp)
 b007af8:	dc000315 	stw	r16,12(sp)
 b007afc:	df000404 	addi	fp,sp,16
 b007b00:	e13ffe15 	stw	r4,-8(fp)
  alt_32 i;
  int rc = -EMFILE;
 b007b04:	00bffa04 	movi	r2,-24
 b007b08:	e0bffd15 	stw	r2,-12(fp)
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 b007b0c:	e03ffc15 	stw	zero,-16(fp)
 b007b10:	00001d06 	br	b007b88 <alt_get_fd+0x9c>
  {
    if (!alt_fd_list[i].dev)
 b007b14:	0402c074 	movhi	r16,2817
 b007b18:	84266904 	addi	r16,r16,-26204
 b007b1c:	e0bffc17 	ldw	r2,-16(fp)
 b007b20:	01400304 	movi	r5,12
 b007b24:	1009883a 	mov	r4,r2
 b007b28:	b003fb80 	call	b003fb8 <__mulsi3>
 b007b2c:	8085883a 	add	r2,r16,r2
 b007b30:	10800017 	ldw	r2,0(r2)
 b007b34:	1000111e 	bne	r2,zero,b007b7c <alt_get_fd+0x90>
    {
      alt_fd_list[i].dev = dev;
 b007b38:	0402c074 	movhi	r16,2817
 b007b3c:	84266904 	addi	r16,r16,-26204
 b007b40:	e0bffc17 	ldw	r2,-16(fp)
 b007b44:	01400304 	movi	r5,12
 b007b48:	1009883a 	mov	r4,r2
 b007b4c:	b003fb80 	call	b003fb8 <__mulsi3>
 b007b50:	8085883a 	add	r2,r16,r2
 b007b54:	e0fffe17 	ldw	r3,-8(fp)
 b007b58:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
 b007b5c:	d0e00717 	ldw	r3,-32740(gp)
 b007b60:	e0bffc17 	ldw	r2,-16(fp)
 b007b64:	1880020e 	bge	r3,r2,b007b70 <alt_get_fd+0x84>
      {
        alt_max_fd = i;
 b007b68:	e0bffc17 	ldw	r2,-16(fp)
 b007b6c:	d0a00715 	stw	r2,-32740(gp)
      }
      rc = i;
 b007b70:	e0bffc17 	ldw	r2,-16(fp)
 b007b74:	e0bffd15 	stw	r2,-12(fp)
      goto alt_get_fd_exit;
 b007b78:	00000606 	br	b007b94 <alt_get_fd+0xa8>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 b007b7c:	e0bffc17 	ldw	r2,-16(fp)
 b007b80:	10800044 	addi	r2,r2,1
 b007b84:	e0bffc15 	stw	r2,-16(fp)
 b007b88:	e0bffc17 	ldw	r2,-16(fp)
 b007b8c:	10800810 	cmplti	r2,r2,32
 b007b90:	103fe01e 	bne	r2,zero,b007b14 <__alt_mem_flash+0xff006b14>
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);

  return rc;
 b007b94:	e0bffd17 	ldw	r2,-12(fp)
}
 b007b98:	e6ffff04 	addi	sp,fp,-4
 b007b9c:	dfc00217 	ldw	ra,8(sp)
 b007ba0:	df000117 	ldw	fp,4(sp)
 b007ba4:	dc000017 	ldw	r16,0(sp)
 b007ba8:	dec00304 	addi	sp,sp,12
 b007bac:	f800283a 	ret

0b007bb0 <alt_exception_cause_generated_bad_addr>:
 * Return: 1: BADADDR (bad_addr argument to handler) is valid
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
 b007bb0:	defffe04 	addi	sp,sp,-8
 b007bb4:	df000115 	stw	fp,4(sp)
 b007bb8:	df000104 	addi	fp,sp,4
 b007bbc:	e13fff15 	stw	r4,-4(fp)
  switch (cause) {
 b007bc0:	e0bfff17 	ldw	r2,-4(fp)
 b007bc4:	10bffe84 	addi	r2,r2,-6
 b007bc8:	10c00428 	cmpgeui	r3,r2,16
 b007bcc:	18001a1e 	bne	r3,zero,b007c38 <alt_exception_cause_generated_bad_addr+0x88>
 b007bd0:	100690ba 	slli	r3,r2,2
 b007bd4:	0082c034 	movhi	r2,2816
 b007bd8:	109efa04 	addi	r2,r2,31720
 b007bdc:	1885883a 	add	r2,r3,r2
 b007be0:	10800017 	ldw	r2,0(r2)
 b007be4:	1000683a 	jmp	r2
 b007be8:	0b007c28 	cmpgeui	r12,at,496
 b007bec:	0b007c28 	cmpgeui	r12,at,496
 b007bf0:	0b007c38 	rdprs	r12,at,496
 b007bf4:	0b007c38 	rdprs	r12,at,496
 b007bf8:	0b007c38 	rdprs	r12,at,496
 b007bfc:	0b007c28 	cmpgeui	r12,at,496
 b007c00:	0b007c30 	cmpltui	r12,at,496
 b007c04:	0b007c38 	rdprs	r12,at,496
 b007c08:	0b007c28 	cmpgeui	r12,at,496
 b007c0c:	0b007c28 	cmpgeui	r12,at,496
 b007c10:	0b007c38 	rdprs	r12,at,496
 b007c14:	0b007c28 	cmpgeui	r12,at,496
 b007c18:	0b007c30 	cmpltui	r12,at,496
 b007c1c:	0b007c38 	rdprs	r12,at,496
 b007c20:	0b007c38 	rdprs	r12,at,496
 b007c24:	0b007c28 	cmpgeui	r12,at,496
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
 b007c28:	00800044 	movi	r2,1
 b007c2c:	00000306 	br	b007c3c <alt_exception_cause_generated_bad_addr+0x8c>

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
 b007c30:	0005883a 	mov	r2,zero
 b007c34:	00000106 	br	b007c3c <alt_exception_cause_generated_bad_addr+0x8c>

  default:
    return 0;
 b007c38:	0005883a 	mov	r2,zero
  }
}
 b007c3c:	e037883a 	mov	sp,fp
 b007c40:	df000017 	ldw	fp,0(sp)
 b007c44:	dec00104 	addi	sp,sp,4
 b007c48:	f800283a 	ret

0b007c4c <atexit>:
 b007c4c:	200b883a 	mov	r5,r4
 b007c50:	000f883a 	mov	r7,zero
 b007c54:	000d883a 	mov	r6,zero
 b007c58:	0009883a 	mov	r4,zero
 b007c5c:	b007ef41 	jmpi	b007ef4 <__register_exitproc>

0b007c60 <exit>:
 b007c60:	defffe04 	addi	sp,sp,-8
 b007c64:	000b883a 	mov	r5,zero
 b007c68:	dc000015 	stw	r16,0(sp)
 b007c6c:	dfc00115 	stw	ra,4(sp)
 b007c70:	2021883a 	mov	r16,r4
 b007c74:	b00800c0 	call	b00800c <__call_exitprocs>
 b007c78:	0082c074 	movhi	r2,2817
 b007c7c:	10a6ca04 	addi	r2,r2,-25816
 b007c80:	11000017 	ldw	r4,0(r2)
 b007c84:	20800f17 	ldw	r2,60(r4)
 b007c88:	10000126 	beq	r2,zero,b007c90 <exit+0x30>
 b007c8c:	103ee83a 	callr	r2
 b007c90:	8009883a 	mov	r4,r16
 b007c94:	b00818c0 	call	b00818c <_exit>

0b007c98 <memcmp>:
 b007c98:	01c000c4 	movi	r7,3
 b007c9c:	3980192e 	bgeu	r7,r6,b007d04 <memcmp+0x6c>
 b007ca0:	2144b03a 	or	r2,r4,r5
 b007ca4:	11c4703a 	and	r2,r2,r7
 b007ca8:	10000f26 	beq	r2,zero,b007ce8 <memcmp+0x50>
 b007cac:	20800003 	ldbu	r2,0(r4)
 b007cb0:	28c00003 	ldbu	r3,0(r5)
 b007cb4:	10c0151e 	bne	r2,r3,b007d0c <memcmp+0x74>
 b007cb8:	31bfff84 	addi	r6,r6,-2
 b007cbc:	01ffffc4 	movi	r7,-1
 b007cc0:	00000406 	br	b007cd4 <memcmp+0x3c>
 b007cc4:	20800003 	ldbu	r2,0(r4)
 b007cc8:	28c00003 	ldbu	r3,0(r5)
 b007ccc:	31bfffc4 	addi	r6,r6,-1
 b007cd0:	10c00e1e 	bne	r2,r3,b007d0c <memcmp+0x74>
 b007cd4:	21000044 	addi	r4,r4,1
 b007cd8:	29400044 	addi	r5,r5,1
 b007cdc:	31fff91e 	bne	r6,r7,b007cc4 <__alt_mem_flash+0xff006cc4>
 b007ce0:	0005883a 	mov	r2,zero
 b007ce4:	f800283a 	ret
 b007ce8:	20c00017 	ldw	r3,0(r4)
 b007cec:	28800017 	ldw	r2,0(r5)
 b007cf0:	18bfee1e 	bne	r3,r2,b007cac <__alt_mem_flash+0xff006cac>
 b007cf4:	31bfff04 	addi	r6,r6,-4
 b007cf8:	21000104 	addi	r4,r4,4
 b007cfc:	29400104 	addi	r5,r5,4
 b007d00:	39bff936 	bltu	r7,r6,b007ce8 <__alt_mem_flash+0xff006ce8>
 b007d04:	303fe91e 	bne	r6,zero,b007cac <__alt_mem_flash+0xff006cac>
 b007d08:	003ff506 	br	b007ce0 <__alt_mem_flash+0xff006ce0>
 b007d0c:	10c5c83a 	sub	r2,r2,r3
 b007d10:	f800283a 	ret

0b007d14 <memcpy>:
 b007d14:	defffd04 	addi	sp,sp,-12
 b007d18:	dfc00215 	stw	ra,8(sp)
 b007d1c:	dc400115 	stw	r17,4(sp)
 b007d20:	dc000015 	stw	r16,0(sp)
 b007d24:	00c003c4 	movi	r3,15
 b007d28:	2005883a 	mov	r2,r4
 b007d2c:	1980452e 	bgeu	r3,r6,b007e44 <memcpy+0x130>
 b007d30:	2906b03a 	or	r3,r5,r4
 b007d34:	18c000cc 	andi	r3,r3,3
 b007d38:	1800441e 	bne	r3,zero,b007e4c <memcpy+0x138>
 b007d3c:	347ffc04 	addi	r17,r6,-16
 b007d40:	8822d13a 	srli	r17,r17,4
 b007d44:	28c00104 	addi	r3,r5,4
 b007d48:	23400104 	addi	r13,r4,4
 b007d4c:	8820913a 	slli	r16,r17,4
 b007d50:	2b000204 	addi	r12,r5,8
 b007d54:	22c00204 	addi	r11,r4,8
 b007d58:	84000504 	addi	r16,r16,20
 b007d5c:	2a800304 	addi	r10,r5,12
 b007d60:	22400304 	addi	r9,r4,12
 b007d64:	2c21883a 	add	r16,r5,r16
 b007d68:	2811883a 	mov	r8,r5
 b007d6c:	200f883a 	mov	r7,r4
 b007d70:	41000017 	ldw	r4,0(r8)
 b007d74:	1fc00017 	ldw	ra,0(r3)
 b007d78:	63c00017 	ldw	r15,0(r12)
 b007d7c:	39000015 	stw	r4,0(r7)
 b007d80:	53800017 	ldw	r14,0(r10)
 b007d84:	6fc00015 	stw	ra,0(r13)
 b007d88:	5bc00015 	stw	r15,0(r11)
 b007d8c:	4b800015 	stw	r14,0(r9)
 b007d90:	18c00404 	addi	r3,r3,16
 b007d94:	39c00404 	addi	r7,r7,16
 b007d98:	42000404 	addi	r8,r8,16
 b007d9c:	6b400404 	addi	r13,r13,16
 b007da0:	63000404 	addi	r12,r12,16
 b007da4:	5ac00404 	addi	r11,r11,16
 b007da8:	52800404 	addi	r10,r10,16
 b007dac:	4a400404 	addi	r9,r9,16
 b007db0:	1c3fef1e 	bne	r3,r16,b007d70 <__alt_mem_flash+0xff006d70>
 b007db4:	89c00044 	addi	r7,r17,1
 b007db8:	380e913a 	slli	r7,r7,4
 b007dbc:	310003cc 	andi	r4,r6,15
 b007dc0:	02c000c4 	movi	r11,3
 b007dc4:	11c7883a 	add	r3,r2,r7
 b007dc8:	29cb883a 	add	r5,r5,r7
 b007dcc:	5900212e 	bgeu	r11,r4,b007e54 <memcpy+0x140>
 b007dd0:	1813883a 	mov	r9,r3
 b007dd4:	2811883a 	mov	r8,r5
 b007dd8:	200f883a 	mov	r7,r4
 b007ddc:	42800017 	ldw	r10,0(r8)
 b007de0:	4a400104 	addi	r9,r9,4
 b007de4:	39ffff04 	addi	r7,r7,-4
 b007de8:	4abfff15 	stw	r10,-4(r9)
 b007dec:	42000104 	addi	r8,r8,4
 b007df0:	59fffa36 	bltu	r11,r7,b007ddc <__alt_mem_flash+0xff006ddc>
 b007df4:	213fff04 	addi	r4,r4,-4
 b007df8:	2008d0ba 	srli	r4,r4,2
 b007dfc:	318000cc 	andi	r6,r6,3
 b007e00:	21000044 	addi	r4,r4,1
 b007e04:	2109883a 	add	r4,r4,r4
 b007e08:	2109883a 	add	r4,r4,r4
 b007e0c:	1907883a 	add	r3,r3,r4
 b007e10:	290b883a 	add	r5,r5,r4
 b007e14:	30000626 	beq	r6,zero,b007e30 <memcpy+0x11c>
 b007e18:	198d883a 	add	r6,r3,r6
 b007e1c:	29c00003 	ldbu	r7,0(r5)
 b007e20:	18c00044 	addi	r3,r3,1
 b007e24:	29400044 	addi	r5,r5,1
 b007e28:	19ffffc5 	stb	r7,-1(r3)
 b007e2c:	19bffb1e 	bne	r3,r6,b007e1c <__alt_mem_flash+0xff006e1c>
 b007e30:	dfc00217 	ldw	ra,8(sp)
 b007e34:	dc400117 	ldw	r17,4(sp)
 b007e38:	dc000017 	ldw	r16,0(sp)
 b007e3c:	dec00304 	addi	sp,sp,12
 b007e40:	f800283a 	ret
 b007e44:	2007883a 	mov	r3,r4
 b007e48:	003ff206 	br	b007e14 <__alt_mem_flash+0xff006e14>
 b007e4c:	2007883a 	mov	r3,r4
 b007e50:	003ff106 	br	b007e18 <__alt_mem_flash+0xff006e18>
 b007e54:	200d883a 	mov	r6,r4
 b007e58:	003fee06 	br	b007e14 <__alt_mem_flash+0xff006e14>

0b007e5c <strlen>:
 b007e5c:	208000cc 	andi	r2,r4,3
 b007e60:	10002026 	beq	r2,zero,b007ee4 <strlen+0x88>
 b007e64:	20800007 	ldb	r2,0(r4)
 b007e68:	10002026 	beq	r2,zero,b007eec <strlen+0x90>
 b007e6c:	2005883a 	mov	r2,r4
 b007e70:	00000206 	br	b007e7c <strlen+0x20>
 b007e74:	10c00007 	ldb	r3,0(r2)
 b007e78:	18001826 	beq	r3,zero,b007edc <strlen+0x80>
 b007e7c:	10800044 	addi	r2,r2,1
 b007e80:	10c000cc 	andi	r3,r2,3
 b007e84:	183ffb1e 	bne	r3,zero,b007e74 <__alt_mem_flash+0xff006e74>
 b007e88:	10c00017 	ldw	r3,0(r2)
 b007e8c:	01ffbff4 	movhi	r7,65279
 b007e90:	39ffbfc4 	addi	r7,r7,-257
 b007e94:	00ca303a 	nor	r5,zero,r3
 b007e98:	01a02074 	movhi	r6,32897
 b007e9c:	19c7883a 	add	r3,r3,r7
 b007ea0:	31a02004 	addi	r6,r6,-32640
 b007ea4:	1946703a 	and	r3,r3,r5
 b007ea8:	1986703a 	and	r3,r3,r6
 b007eac:	1800091e 	bne	r3,zero,b007ed4 <strlen+0x78>
 b007eb0:	10800104 	addi	r2,r2,4
 b007eb4:	10c00017 	ldw	r3,0(r2)
 b007eb8:	19cb883a 	add	r5,r3,r7
 b007ebc:	00c6303a 	nor	r3,zero,r3
 b007ec0:	28c6703a 	and	r3,r5,r3
 b007ec4:	1986703a 	and	r3,r3,r6
 b007ec8:	183ff926 	beq	r3,zero,b007eb0 <__alt_mem_flash+0xff006eb0>
 b007ecc:	00000106 	br	b007ed4 <strlen+0x78>
 b007ed0:	10800044 	addi	r2,r2,1
 b007ed4:	10c00007 	ldb	r3,0(r2)
 b007ed8:	183ffd1e 	bne	r3,zero,b007ed0 <__alt_mem_flash+0xff006ed0>
 b007edc:	1105c83a 	sub	r2,r2,r4
 b007ee0:	f800283a 	ret
 b007ee4:	2005883a 	mov	r2,r4
 b007ee8:	003fe706 	br	b007e88 <__alt_mem_flash+0xff006e88>
 b007eec:	0005883a 	mov	r2,zero
 b007ef0:	f800283a 	ret

0b007ef4 <__register_exitproc>:
 b007ef4:	defffa04 	addi	sp,sp,-24
 b007ef8:	dc000315 	stw	r16,12(sp)
 b007efc:	0402c074 	movhi	r16,2817
 b007f00:	8426ca04 	addi	r16,r16,-25816
 b007f04:	80c00017 	ldw	r3,0(r16)
 b007f08:	dc400415 	stw	r17,16(sp)
 b007f0c:	dfc00515 	stw	ra,20(sp)
 b007f10:	18805217 	ldw	r2,328(r3)
 b007f14:	2023883a 	mov	r17,r4
 b007f18:	10003726 	beq	r2,zero,b007ff8 <__register_exitproc+0x104>
 b007f1c:	10c00117 	ldw	r3,4(r2)
 b007f20:	010007c4 	movi	r4,31
 b007f24:	20c00e16 	blt	r4,r3,b007f60 <__register_exitproc+0x6c>
 b007f28:	1a000044 	addi	r8,r3,1
 b007f2c:	8800221e 	bne	r17,zero,b007fb8 <__register_exitproc+0xc4>
 b007f30:	18c00084 	addi	r3,r3,2
 b007f34:	18c7883a 	add	r3,r3,r3
 b007f38:	18c7883a 	add	r3,r3,r3
 b007f3c:	12000115 	stw	r8,4(r2)
 b007f40:	10c7883a 	add	r3,r2,r3
 b007f44:	19400015 	stw	r5,0(r3)
 b007f48:	0005883a 	mov	r2,zero
 b007f4c:	dfc00517 	ldw	ra,20(sp)
 b007f50:	dc400417 	ldw	r17,16(sp)
 b007f54:	dc000317 	ldw	r16,12(sp)
 b007f58:	dec00604 	addi	sp,sp,24
 b007f5c:	f800283a 	ret
 b007f60:	00800034 	movhi	r2,0
 b007f64:	10800004 	addi	r2,r2,0
 b007f68:	10002626 	beq	r2,zero,b008004 <__register_exitproc+0x110>
 b007f6c:	01006404 	movi	r4,400
 b007f70:	d9400015 	stw	r5,0(sp)
 b007f74:	d9800115 	stw	r6,4(sp)
 b007f78:	d9c00215 	stw	r7,8(sp)
 b007f7c:	00000000 	call	0 <__alt_mem_onchip-0x4000000>
 b007f80:	d9400017 	ldw	r5,0(sp)
 b007f84:	d9800117 	ldw	r6,4(sp)
 b007f88:	d9c00217 	ldw	r7,8(sp)
 b007f8c:	10001d26 	beq	r2,zero,b008004 <__register_exitproc+0x110>
 b007f90:	81000017 	ldw	r4,0(r16)
 b007f94:	10000115 	stw	zero,4(r2)
 b007f98:	02000044 	movi	r8,1
 b007f9c:	22405217 	ldw	r9,328(r4)
 b007fa0:	0007883a 	mov	r3,zero
 b007fa4:	12400015 	stw	r9,0(r2)
 b007fa8:	20805215 	stw	r2,328(r4)
 b007fac:	10006215 	stw	zero,392(r2)
 b007fb0:	10006315 	stw	zero,396(r2)
 b007fb4:	883fde26 	beq	r17,zero,b007f30 <__alt_mem_flash+0xff006f30>
 b007fb8:	18c9883a 	add	r4,r3,r3
 b007fbc:	2109883a 	add	r4,r4,r4
 b007fc0:	1109883a 	add	r4,r2,r4
 b007fc4:	21802215 	stw	r6,136(r4)
 b007fc8:	01800044 	movi	r6,1
 b007fcc:	12406217 	ldw	r9,392(r2)
 b007fd0:	30cc983a 	sll	r6,r6,r3
 b007fd4:	4992b03a 	or	r9,r9,r6
 b007fd8:	12406215 	stw	r9,392(r2)
 b007fdc:	21c04215 	stw	r7,264(r4)
 b007fe0:	01000084 	movi	r4,2
 b007fe4:	893fd21e 	bne	r17,r4,b007f30 <__alt_mem_flash+0xff006f30>
 b007fe8:	11006317 	ldw	r4,396(r2)
 b007fec:	218cb03a 	or	r6,r4,r6
 b007ff0:	11806315 	stw	r6,396(r2)
 b007ff4:	003fce06 	br	b007f30 <__alt_mem_flash+0xff006f30>
 b007ff8:	18805304 	addi	r2,r3,332
 b007ffc:	18805215 	stw	r2,328(r3)
 b008000:	003fc606 	br	b007f1c <__alt_mem_flash+0xff006f1c>
 b008004:	00bfffc4 	movi	r2,-1
 b008008:	003fd006 	br	b007f4c <__alt_mem_flash+0xff006f4c>

0b00800c <__call_exitprocs>:
 b00800c:	defff504 	addi	sp,sp,-44
 b008010:	df000915 	stw	fp,36(sp)
 b008014:	dd400615 	stw	r21,24(sp)
 b008018:	dc800315 	stw	r18,12(sp)
 b00801c:	dfc00a15 	stw	ra,40(sp)
 b008020:	ddc00815 	stw	r23,32(sp)
 b008024:	dd800715 	stw	r22,28(sp)
 b008028:	dd000515 	stw	r20,20(sp)
 b00802c:	dcc00415 	stw	r19,16(sp)
 b008030:	dc400215 	stw	r17,8(sp)
 b008034:	dc000115 	stw	r16,4(sp)
 b008038:	d9000015 	stw	r4,0(sp)
 b00803c:	2839883a 	mov	fp,r5
 b008040:	04800044 	movi	r18,1
 b008044:	057fffc4 	movi	r21,-1
 b008048:	0082c074 	movhi	r2,2817
 b00804c:	10a6ca04 	addi	r2,r2,-25816
 b008050:	12000017 	ldw	r8,0(r2)
 b008054:	45005217 	ldw	r20,328(r8)
 b008058:	44c05204 	addi	r19,r8,328
 b00805c:	a0001c26 	beq	r20,zero,b0080d0 <__call_exitprocs+0xc4>
 b008060:	a0800117 	ldw	r2,4(r20)
 b008064:	15ffffc4 	addi	r23,r2,-1
 b008068:	b8000d16 	blt	r23,zero,b0080a0 <__call_exitprocs+0x94>
 b00806c:	14000044 	addi	r16,r2,1
 b008070:	8421883a 	add	r16,r16,r16
 b008074:	8421883a 	add	r16,r16,r16
 b008078:	84402004 	addi	r17,r16,128
 b00807c:	a463883a 	add	r17,r20,r17
 b008080:	a421883a 	add	r16,r20,r16
 b008084:	e0001e26 	beq	fp,zero,b008100 <__call_exitprocs+0xf4>
 b008088:	80804017 	ldw	r2,256(r16)
 b00808c:	e0801c26 	beq	fp,r2,b008100 <__call_exitprocs+0xf4>
 b008090:	bdffffc4 	addi	r23,r23,-1
 b008094:	843fff04 	addi	r16,r16,-4
 b008098:	8c7fff04 	addi	r17,r17,-4
 b00809c:	bd7ff91e 	bne	r23,r21,b008084 <__alt_mem_flash+0xff007084>
 b0080a0:	00800034 	movhi	r2,0
 b0080a4:	10800004 	addi	r2,r2,0
 b0080a8:	10000926 	beq	r2,zero,b0080d0 <__call_exitprocs+0xc4>
 b0080ac:	a0800117 	ldw	r2,4(r20)
 b0080b0:	1000301e 	bne	r2,zero,b008174 <__call_exitprocs+0x168>
 b0080b4:	a0800017 	ldw	r2,0(r20)
 b0080b8:	10003226 	beq	r2,zero,b008184 <__call_exitprocs+0x178>
 b0080bc:	a009883a 	mov	r4,r20
 b0080c0:	98800015 	stw	r2,0(r19)
 b0080c4:	00000000 	call	0 <__alt_mem_onchip-0x4000000>
 b0080c8:	9d000017 	ldw	r20,0(r19)
 b0080cc:	a03fe41e 	bne	r20,zero,b008060 <__alt_mem_flash+0xff007060>
 b0080d0:	dfc00a17 	ldw	ra,40(sp)
 b0080d4:	df000917 	ldw	fp,36(sp)
 b0080d8:	ddc00817 	ldw	r23,32(sp)
 b0080dc:	dd800717 	ldw	r22,28(sp)
 b0080e0:	dd400617 	ldw	r21,24(sp)
 b0080e4:	dd000517 	ldw	r20,20(sp)
 b0080e8:	dcc00417 	ldw	r19,16(sp)
 b0080ec:	dc800317 	ldw	r18,12(sp)
 b0080f0:	dc400217 	ldw	r17,8(sp)
 b0080f4:	dc000117 	ldw	r16,4(sp)
 b0080f8:	dec00b04 	addi	sp,sp,44
 b0080fc:	f800283a 	ret
 b008100:	a0800117 	ldw	r2,4(r20)
 b008104:	80c00017 	ldw	r3,0(r16)
 b008108:	10bfffc4 	addi	r2,r2,-1
 b00810c:	15c01426 	beq	r2,r23,b008160 <__call_exitprocs+0x154>
 b008110:	80000015 	stw	zero,0(r16)
 b008114:	183fde26 	beq	r3,zero,b008090 <__alt_mem_flash+0xff007090>
 b008118:	95c8983a 	sll	r4,r18,r23
 b00811c:	a0806217 	ldw	r2,392(r20)
 b008120:	a5800117 	ldw	r22,4(r20)
 b008124:	2084703a 	and	r2,r4,r2
 b008128:	10000b26 	beq	r2,zero,b008158 <__call_exitprocs+0x14c>
 b00812c:	a0806317 	ldw	r2,396(r20)
 b008130:	2088703a 	and	r4,r4,r2
 b008134:	20000c1e 	bne	r4,zero,b008168 <__call_exitprocs+0x15c>
 b008138:	89400017 	ldw	r5,0(r17)
 b00813c:	d9000017 	ldw	r4,0(sp)
 b008140:	183ee83a 	callr	r3
 b008144:	a0800117 	ldw	r2,4(r20)
 b008148:	15bfbf1e 	bne	r2,r22,b008048 <__alt_mem_flash+0xff007048>
 b00814c:	98800017 	ldw	r2,0(r19)
 b008150:	153fcf26 	beq	r2,r20,b008090 <__alt_mem_flash+0xff007090>
 b008154:	003fbc06 	br	b008048 <__alt_mem_flash+0xff007048>
 b008158:	183ee83a 	callr	r3
 b00815c:	003ff906 	br	b008144 <__alt_mem_flash+0xff007144>
 b008160:	a5c00115 	stw	r23,4(r20)
 b008164:	003feb06 	br	b008114 <__alt_mem_flash+0xff007114>
 b008168:	89000017 	ldw	r4,0(r17)
 b00816c:	183ee83a 	callr	r3
 b008170:	003ff406 	br	b008144 <__alt_mem_flash+0xff007144>
 b008174:	a0800017 	ldw	r2,0(r20)
 b008178:	a027883a 	mov	r19,r20
 b00817c:	1029883a 	mov	r20,r2
 b008180:	003fb606 	br	b00805c <__alt_mem_flash+0xff00705c>
 b008184:	0005883a 	mov	r2,zero
 b008188:	003ffb06 	br	b008178 <__alt_mem_flash+0xff007178>

0b00818c <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
 b00818c:	defffd04 	addi	sp,sp,-12
 b008190:	df000215 	stw	fp,8(sp)
 b008194:	df000204 	addi	fp,sp,8
 b008198:	e13fff15 	stw	r4,-4(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
 b00819c:	0001883a 	nop
 b0081a0:	e0bfff17 	ldw	r2,-4(fp)
 b0081a4:	e0bffe15 	stw	r2,-8(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
 b0081a8:	e0bffe17 	ldw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
 b0081ac:	10000226 	beq	r2,zero,b0081b8 <_exit+0x2c>
    ALT_SIM_FAIL();
 b0081b0:	002af070 	cmpltui	zero,zero,43969
 b0081b4:	00000106 	br	b0081bc <_exit+0x30>
  } else {
    ALT_SIM_PASS();
 b0081b8:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
 b0081bc:	003fff06 	br	b0081bc <__alt_mem_flash+0xff0071bc>
