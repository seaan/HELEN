
test_2.elf:     file format elf32-littlenios2
test_2.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x0b000210

Program Header:
    LOAD off    0x00001060 vaddr 0x04000060 paddr 0x04000060 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00002000 vaddr 0x0b000000 paddr 0x0b000000 align 2**12
         filesz 0x00007640 memsz 0x00007640 flags r-x
    LOAD off    0x00009640 vaddr 0x0b007640 paddr 0x0b009270 align 2**12
         filesz 0x00001c30 memsz 0x00001c30 flags rw-
    LOAD off    0x0000bea0 vaddr 0x0b00aea0 paddr 0x0b00aea0 align 2**12
         filesz 0x00000000 memsz 0x00000154 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  04000060  04000060  00001060  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000210  0b000000  0b000000  00002000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         000073c4  0b000210  0b000210  00002210  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       0000006c  0b0075d4  0b0075d4  000095d4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00001c30  0b007640  0b009270  00009640  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          00000154  0b00aea0  0b00aea0  0000bea0  2**2
                  ALLOC, SMALL_DATA
  6 .onchip       00000000  04000080  04000080  0000b270  2**0
                  CONTENTS
  7 .sdram        00000000  0b00aff4  0b00aff4  0000b270  2**0
                  CONTENTS
  8 .flash        00000000  0c001000  0c001000  0000b270  2**0
                  CONTENTS
  9 .comment      00000023  00000000  00000000  0000b270  2**0
                  CONTENTS, READONLY
 10 .debug_aranges 00000b50  00000000  00000000  0000b298  2**3
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_info   00019027  00000000  00000000  0000bde8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 00006ba1  00000000  00000000  00024e0f  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   000075cc  00000000  00000000  0002b9b0  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00001be8  00000000  00000000  00032f7c  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    00002f73  00000000  00000000  00034b64  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    00004bc7  00000000  00000000  00037ad7  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_alt_sim_info 00000040  00000000  00000000  0003c6a0  2**2
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_ranges 00000680  00000000  00000000  0003c6e0  2**3
                  CONTENTS, READONLY, DEBUGGING
 19 .thread_model 00000003  00000000  00000000  0003fa82  2**0
                  CONTENTS, READONLY
 20 .cpu          00000006  00000000  00000000  0003fa85  2**0
                  CONTENTS, READONLY
 21 .qsys         00000001  00000000  00000000  0003fa8b  2**0
                  CONTENTS, READONLY
 22 .simulation_enabled 00000001  00000000  00000000  0003fa8c  2**0
                  CONTENTS, READONLY
 23 .sysid_hash   00000004  00000000  00000000  0003fa8d  2**0
                  CONTENTS, READONLY
 24 .sysid_base   00000004  00000000  00000000  0003fa91  2**0
                  CONTENTS, READONLY
 25 .sysid_time   00000004  00000000  00000000  0003fa95  2**0
                  CONTENTS, READONLY
 26 .stderr_dev   0000000b  00000000  00000000  0003fa99  2**0
                  CONTENTS, READONLY
 27 .stdin_dev    0000000b  00000000  00000000  0003faa4  2**0
                  CONTENTS, READONLY
 28 .stdout_dev   0000000b  00000000  00000000  0003faaf  2**0
                  CONTENTS, READONLY
 29 .sopc_system_name 00000005  00000000  00000000  0003faba  2**0
                  CONTENTS, READONLY
 30 .quartus_project_dir 0000002d  00000000  00000000  0003fabf  2**0
                  CONTENTS, READONLY
 31 .jdi          00007c1c  00000000  00000000  0003faec  2**0
                  CONTENTS, READONLY
 32 .sopcinfo     0008a1be  00000000  00000000  00047708  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
04000060 l    d  .entry	00000000 .entry
0b000000 l    d  .exceptions	00000000 .exceptions
0b000210 l    d  .text	00000000 .text
0b0075d4 l    d  .rodata	00000000 .rodata
0b007640 l    d  .rwdata	00000000 .rwdata
0b00aea0 l    d  .bss	00000000 .bss
04000080 l    d  .onchip	00000000 .onchip
0b00aff4 l    d  .sdram	00000000 .sdram
0c001000 l    d  .flash	00000000 .flash
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../test_2_bsp//obj/HAL/src/crt0.o
0b000248 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 main.c
00000000 l    df *ABS*	00000000 fwrite.c
00000000 l    df *ABS*	00000000 impure.c
0b007640 l     O .rwdata	00000424 impure_data
00000000 l    df *ABS*	00000000 findfp.c
0b000398 l     F .text	00000008 __fp_unlock
0b0003ac l     F .text	0000019c __sinit.part.1
0b000548 l     F .text	00000008 __fp_lock
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 lib2-mul.c
00000000 l    df *ABS*	00000000 alt_close.c
0b003038 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_dev.c
0b00314c l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_fstat.c
0b003178 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_isatty.c
0b00326c l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_load.c
0b003354 l     F .text	00000068 alt_load_section
00000000 l    df *ABS*	00000000 alt_lseek.c
0b003440 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
00000000 l    df *ABS*	00000000 alt_read.c
0b00361c l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
0b009258 l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
0b0038c0 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_sys_init.c
0b0039fc l     F .text	00000034 alt_dev_reg
0b008014 l     O .rwdata	000000cc flash
0b0080e0 l     O .rwdata	00001060 jtag_uart_0
0b009140 l     O .rwdata	000000c4 uart
0b009204 l     O .rwdata	0000002c adc
00000000 l    df *ABS*	00000000 altera_avalon_epcs_flash_controller.c
0b003ad0 l     F .text	00000034 alt_flash_device_register
0b003b58 l     F .text	000003f8 alt_epcs_flash_query
0b003f50 l     F .text	000000ec alt_epcs_flash_memcmp
0b004328 l     F .text	00000094 alt_epcs_test_address
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
0b0047f0 l     F .text	0000020c altera_avalon_jtag_uart_irq
0b0049fc l     F .text	000000a0 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_uart_init.c
0b0051f0 l     F .text	0000009c altera_avalon_uart_irq
0b00528c l     F .text	000000e4 altera_avalon_uart_rxirq
0b005370 l     F .text	00000148 altera_avalon_uart_txirq
00000000 l    df *ABS*	00000000 altera_avalon_uart_read.c
0b00550c l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 altera_avalon_uart_write.c
0b005724 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 epcs_commands.c
0b005968 l     F .text	00000038 epcs_test_wip
0b0059a0 l     F .text	0000003c epcs_await_wip_released
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
0b0061ec l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_flash_dev.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
0b006708 l     F .text	000000e4 alt_open_fd
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_open.c
0b006868 l     F .text	0000003c alt_get_errno
0b0068a4 l     F .text	000000ec alt_file_locked
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 altera_avalon_spi.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_exit.c
0b00aec8 g     O .bss	00000004 alt_instruction_exception_handler
0b00429c g     F .text	0000008c alt_epcs_flash_get_info
0b002e08 g     F .text	00000054 _isatty_r
0b003558 g     F .text	0000007c alt_main
0b00aef4 g     O .bss	00000100 alt_irq
0b002b30 g     F .text	00000060 _lseek_r
0b009270 g       *ABS*	00000000 __flash_rwdata_start
0b00aff4 g       *ABS*	00000000 __alt_heap_start
0b0020e4 g     F .text	0000005c __sseek
0b0006f8 g     F .text	00000010 __sinit
0b000550 g     F .text	00000078 __sfmoreglue
0c001000 g       *ABS*	00000000 __alt_mem_flash
0b0035f8 g     F .text	00000024 __malloc_unlock
0b0017d0 g     F .text	0000015c memmove
0b0006e0 g     F .text	00000018 _cleanup
0b006c90 g     F .text	00000024 altera_nios2_gen2_irq_init
0b0059dc g     F .text	000000fc epcs_sector_erase
04000060 g     F .entry	0000000c __reset
0b000000 g       *ABS*	00000000 __flash_exceptions_start
0b002dac g     F .text	0000005c _fstat_r
0b00aeac g     O .bss	00000004 errno
0b002060 g     F .text	00000008 __seofread
0b00aeb4 g     O .bss	00000004 alt_argv
0b011230 g       *ABS*	00000000 _gp
0b003890 g     F .text	00000030 usleep
0b007e94 g     O .rwdata	00000180 alt_fd_list
0b005c20 g     F .text	0000006c epcs_write_status_register
0b006eb0 g     F .text	00000090 alt_find_dev
0b001688 g     F .text	00000148 memcpy
0b0003a0 g     F .text	0000000c _cleanup_r
0b0067ec g     F .text	0000007c alt_io_redirect
0b0075d4 g       *ABS*	00000000 __DTOR_END__
0b00710c g     F .text	0000009c alt_exception_cause_generated_bad_addr
0b004434 g     F .text	00000100 alt_epcs_flash_write_block
0b004bf4 g     F .text	0000021c altera_avalon_jtag_uart_read
0b002f54 g     F .text	00000064 .hidden __udivsi3
0b0032a8 g     F .text	000000ac isatty
0b00aea8 g     O .bss	00000004 __malloc_top_pad
0b000748 g     F .text	000004c8 __sfvwrite_r
0b001fb8 g     F .text	00000054 _sbrk_r
0b002d4c g     F .text	00000060 _read_r
0b009250 g     O .rwdata	00000004 alt_max_fd
0b002350 g     F .text	000000f0 _fclose_r
0b0026cc g     F .text	00000030 fflush
0b00aea4 g     O .bss	00000004 __malloc_max_sbrked_mem
0b0043bc g     F .text	00000078 alt_epcs_flash_erase_block
0b00347c g     F .text	000000dc lseek
0b009230 g     O .rwdata	00000004 _global_impure_ptr
0b005eec g     F .text	0000005c epcs_exit_4_bytes_mode
0b001a54 g     F .text	00000564 _realloc_r
0b00aff4 g       *ABS*	00000000 __bss_end
0b006618 g     F .text	000000f0 alt_iic_isr_register
0b006b88 g     F .text	00000108 alt_tick
0b005144 g     F .text	000000ac altera_avalon_uart_init
0b000718 g     F .text	00000018 __fp_lock_all
0b0065cc g     F .text	0000004c alt_ic_irq_enabled
0b006aec g     F .text	0000009c alt_alarm_stop
0b00aebc g     O .bss	00000004 alt_irq_active
0b0000dc g     F .exceptions	000000d4 alt_irq_handler
0b007e6c g     O .rwdata	00000028 alt_dev_null
0b0061cc g     F .text	00000020 alt_dcache_flush_all
0b009270 g       *ABS*	00000000 __ram_rwdata_end
0b009248 g     O .rwdata	00000008 alt_dev_list
0b0038fc g     F .text	00000100 write
0b007640 g       *ABS*	00000000 __ram_rodata_end
0b0031b4 g     F .text	000000b8 fstat
0b002fb8 g     F .text	00000058 .hidden __umodsi3
0b005da8 g     F .text	00000068 epcs_read_electronic_signature
0b00aff4 g       *ABS*	00000000 end
0b005760 g     F .text	000001ac altera_avalon_uart_write
0b004730 g     F .text	000000c0 altera_avalon_jtag_uart_init
0b0001b0 g     F .exceptions	00000060 alt_instruction_exception_entry
0b0075d4 g       *ABS*	00000000 __CTOR_LIST__
0c000000 g       *ABS*	00000000 __alt_stack_pointer
0b005094 g     F .text	00000060 altera_avalon_uart_write_fd
0b0050f4 g     F .text	00000050 altera_avalon_uart_close_fd
0b004e10 g     F .text	00000224 altera_avalon_jtag_uart_write
0b000708 g     F .text	00000004 __sfp_lock_acquire
0b0015a4 g     F .text	000000e4 memchr
0b002820 g     F .text	00000310 _free_r
0b007420 g     F .text	00000180 __call_exitprocs
0b009238 g     O .rwdata	00000004 __malloc_sbrk_base
0b000210 g     F .text	0000003c _start
0b00aec0 g     O .bss	00000004 _alt_tick_rate
0b006cb4 g     F .text	000001fc alt_avalon_spi_command
0b00aec4 g     O .bss	00000004 _alt_nticks
0b003658 g     F .text	00000104 read
0b003a68 g     F .text	00000068 alt_sys_init
0b007308 g     F .text	00000118 __register_exitproc
0b004a9c g     F .text	00000068 altera_avalon_jtag_uart_close
0b003010 g     F .text	00000028 .hidden __mulsi3
0b007640 g       *ABS*	00000000 __ram_rwdata_start
0b0075d4 g       *ABS*	00000000 __ram_rodata_start
0b00aecc g     O .bss	00000028 __malloc_current_mallinfo
0b00590c g     F .text	0000005c epcs_read_status_register
0b0045cc g     F .text	00000060 altera_avalon_jtag_uart_read_fd
0b007048 g     F .text	000000c4 alt_get_fd
0b006074 g     F .text	00000158 alt_busy_sleep
0b0022fc g     F .text	00000054 _close_r
0b005e10 g     F .text	00000080 epcs_read_device_id
0b0071f4 g     F .text	0000007c memcmp
0b00468c g     F .text	00000050 altera_avalon_jtag_uart_close_fd
0b00aff4 g       *ABS*	00000000 __alt_stack_base
0b0046dc g     F .text	00000054 altera_avalon_jtag_uart_ioctl_fd
0b000288 g     F .text	000000dc _fwrite_r
0b0021a8 g     F .text	00000154 __swsetup_r
0b0005c8 g     F .text	00000118 __sfp
0b007a64 g     O .rwdata	00000408 __malloc_av_
0b000714 g     F .text	00000004 __sinit_lock_release
0b00200c g     F .text	00000054 __sread
0b006f40 g     F .text	00000108 alt_find_file
0b006228 g     F .text	000000a4 alt_dev_llist_insert
0b0035d4 g     F .text	00000024 __malloc_lock
0b0037e0 g     F .text	000000b0 sbrk
0b002670 g     F .text	0000005c _fflush_r
0b00925c g     O .rwdata	00000008 alt_flash_dev_list
0b00aea0 g       *ABS*	00000000 __bss_start
0b00192c g     F .text	00000128 memset
0b00024c g     F .text	0000003c main
0b00aeb8 g     O .bss	00000004 alt_envp
0b00aea0 g     O .bss	00000004 __malloc_max_total_mem
0b00462c g     F .text	00000060 altera_avalon_jtag_uart_write_fd
0b002140 g     F .text	00000008 __sclose
0c000000 g       *ABS*	00000000 __alt_heap_limit
0b002440 g     F .text	00000014 fclose
0b000d98 g     F .text	0000080c _malloc_r
0b009254 g     O .rwdata	00000004 alt_errno
0b000c10 g     F .text	000000c4 _fwalk
0b002e5c g     F .text	00000084 .hidden __divsi3
0b0026fc g     F .text	00000124 _malloc_trim_r
0b0075d4 g       *ABS*	00000000 __CTOR_END__
0b00403c g     F .text	00000260 alt_epcs_flash_write
0b0075d4 g       *ABS*	00000000 __flash_rodata_start
0b0075d4 g       *ABS*	00000000 __DTOR_LIST__
0b003a30 g     F .text	00000038 alt_irq_init
0b00375c g     F .text	00000084 alt_release_fd
0b0071a8 g     F .text	00000014 atexit
0b002148 g     F .text	00000060 _write_r
0b009234 g     O .rwdata	00000004 _impure_ptr
0b00aeb0 g     O .bss	00000004 alt_argc
0b002454 g     F .text	0000021c __sflush_r
0b00632c g     F .text	00000060 _do_dtors
0b000000 g       .exceptions	00000000 alt_irq_entry
0b000730 g     F .text	00000018 __fp_unlock_all
0b009240 g     O .rwdata	00000008 alt_fs_list
0b000000 g       *ABS*	00000000 __ram_exceptions_start
0b005ad8 g     F .text	000000f4 epcs_read_buffer
0b003b04 g     F .text	00000054 alt_epcs_flash_init
0b006468 g     F .text	00000050 alt_ic_isr_register
0b000364 g     F .text	00000034 fwrite
0b009270 g       *ABS*	00000000 _edata
0b005034 g     F .text	00000060 altera_avalon_uart_read_fd
0b00aff4 g       *ABS*	00000000 _end
0b00638c g     F .text	00000068 alt_flash_open_dev
0b000210 g       *ABS*	00000000 __ram_exceptions_end
0b004b04 g     F .text	000000f0 altera_avalon_jtag_uart_ioctl
0b006540 g     F .text	0000008c alt_ic_irq_disable
0b005e90 g     F .text	0000005c epcs_enter_4_bytes_mode
0b002068 g     F .text	0000007c __swrite
0b00923c g     O .rwdata	00000004 __malloc_trim_threshold
04000000 g       *ABS*	00000000 __alt_mem_onchip
0b0071bc g     F .text	00000038 exit
0b000cd4 g     F .text	000000c4 _fwalk_reent
0b0063f4 g     F .text	00000054 alt_flash_close_dev
0b002ee0 g     F .text	00000074 .hidden __modsi3
0c000000 g       *ABS*	00000000 __alt_data_end
0b000000 g     F .exceptions	00000000 alt_exception
0b00070c g     F .text	00000004 __sfp_lock_release
0a000000 g       *ABS*	00000000 __alt_mem_sdram
0b0054b8 g     F .text	00000054 altera_avalon_uart_close
0b0075a0 g     F .text	00000034 _exit
0b005f48 g     F .text	0000012c alt_alarm_start
0b002b90 g     F .text	000001bc __smakebuf_r
0b007270 g     F .text	00000098 strlen
0b005bcc g     F .text	00000054 epcs_write_enable
0b006990 g     F .text	0000015c open
0b006448 g     F .text	00000020 alt_icache_flush_all
0b009264 g     O .rwdata	00000004 alt_priority_mask
0b0064b8 g     F .text	00000088 alt_ic_irq_enable
0b005548 g     F .text	000001dc altera_avalon_uart_read
0b004534 g     F .text	00000098 alt_epcs_flash_read
0b009268 g     O .rwdata	00000008 alt_alarm_list
0b0062cc g     F .text	00000060 _do_ctors
0b003074 g     F .text	000000d8 close
0b0033bc g     F .text	00000084 alt_load
0b000710 g     F .text	00000004 __sinit_lock_acquire
0b005c8c g     F .text	0000011c epcs_write_buffer



Disassembly of section .entry:

04000060 <__reset>:
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
 4000060:	0042c034 	movhi	at,2816
    ori r1, r1, %lo(_start)
 4000064:	08408414 	ori	at,at,528
    jmp r1
 4000068:	0800683a 	jmp	at
	...

Disassembly of section .exceptions:

0b000000 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
 b000000:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
 b000004:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
 b000008:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
 b00000c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
 b000010:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
 b000014:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
 b000018:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
 b00001c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
 b000020:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
 b000024:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
 b000028:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
 b00002c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
 b000030:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
 b000034:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
 b000038:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
 b00003c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
 b000040:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
 b000044:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
 b000048:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
 b00004c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
 b000050:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
 b000054:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
 b000058:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
 b00005c:	10000326 	beq	r2,zero,b00006c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
 b000060:	20000226 	beq	r4,zero,b00006c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
 b000064:	b0000dc0 	call	b0000dc <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
 b000068:	00000706 	br	b000088 <alt_exception+0x88>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
 b00006c:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
 b000070:	e8bfff17 	ldw	r2,-4(ea)
         * debugger is present) or go into an infinite loop since the
         * handling behavior is undefined; in that case we will not return here.
         */

        /* Load exception-causing address as first argument (r4) */
        addi   r4, ea, -4
 b000074:	e93fff04 	addi	r4,ea,-4

        /* Call the instruction-exception entry */
        call   alt_instruction_exception_entry
 b000078:	b0001b00 	call	b0001b0 <alt_instruction_exception_entry>
         * instruction
         *
         * Return code was 0: Skip. The instruction after the exception is
         * already stored in 72(sp).
         */
        bne   r2, r0, .Lexception_exit
 b00007c:	1000021e 	bne	r2,zero,b000088 <alt_exception+0x88>

        /*
         * Otherwise, modify 72(sp) to re-issue the instruction that caused the
         * exception.
         */
        addi  r15, ea, -4  /* instruction that caused exception */
 b000080:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
 b000084:	dbc01215 	stw	r15,72(sp)
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
 b000088:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
 b00008c:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
 b000090:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
 b000094:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
 b000098:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
 b00009c:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
 b0000a0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
 b0000a4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
 b0000a8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
 b0000ac:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
 b0000b0:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
 b0000b4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
 b0000b8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
 b0000bc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
 b0000c0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
 b0000c4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
 b0000c8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
 b0000cc:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
 b0000d0:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
 b0000d4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
 b0000d8:	ef80083a 	eret

0b0000dc <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
 b0000dc:	defff904 	addi	sp,sp,-28
 b0000e0:	dfc00615 	stw	ra,24(sp)
 b0000e4:	df000515 	stw	fp,20(sp)
 b0000e8:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
 b0000ec:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 b0000f0:	0005313a 	rdctl	r2,ipending
 b0000f4:	e0bffe15 	stw	r2,-8(fp)

  return active;
 b0000f8:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
 b0000fc:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
 b000100:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
 b000104:	00800044 	movi	r2,1
 b000108:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
 b00010c:	e0fffb17 	ldw	r3,-20(fp)
 b000110:	e0bffc17 	ldw	r2,-16(fp)
 b000114:	1884703a 	and	r2,r3,r2
 b000118:	10001426 	beq	r2,zero,b00016c <alt_irq_handler+0x90>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
 b00011c:	0082c074 	movhi	r2,2817
 b000120:	10abbd04 	addi	r2,r2,-20748
 b000124:	e0fffd17 	ldw	r3,-12(fp)
 b000128:	180690fa 	slli	r3,r3,3
 b00012c:	10c5883a 	add	r2,r2,r3
 b000130:	10c00017 	ldw	r3,0(r2)
 b000134:	0082c074 	movhi	r2,2817
 b000138:	10abbd04 	addi	r2,r2,-20748
 b00013c:	e13ffd17 	ldw	r4,-12(fp)
 b000140:	200890fa 	slli	r4,r4,3
 b000144:	1105883a 	add	r2,r2,r4
 b000148:	10800104 	addi	r2,r2,4
 b00014c:	10800017 	ldw	r2,0(r2)
 b000150:	1009883a 	mov	r4,r2
 b000154:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
 b000158:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 b00015c:	0005313a 	rdctl	r2,ipending
 b000160:	e0bfff15 	stw	r2,-4(fp)

  return active;
 b000164:	e0bfff17 	ldw	r2,-4(fp)
 b000168:	00000706 	br	b000188 <alt_irq_handler+0xac>
      }
      mask <<= 1;
 b00016c:	e0bffc17 	ldw	r2,-16(fp)
 b000170:	1085883a 	add	r2,r2,r2
 b000174:	e0bffc15 	stw	r2,-16(fp)
      i++;
 b000178:	e0bffd17 	ldw	r2,-12(fp)
 b00017c:	10800044 	addi	r2,r2,1
 b000180:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
 b000184:	003fe106 	br	b00010c <__alt_mem_flash+0xfefff10c>

    active = alt_irq_pending ();
 b000188:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
 b00018c:	e0bffb17 	ldw	r2,-20(fp)
 b000190:	103fdb1e 	bne	r2,zero,b000100 <__alt_mem_flash+0xfefff100>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
 b000194:	0001883a 	nop
}
 b000198:	0001883a 	nop
 b00019c:	e037883a 	mov	sp,fp
 b0001a0:	dfc00117 	ldw	ra,4(sp)
 b0001a4:	df000017 	ldw	fp,0(sp)
 b0001a8:	dec00204 	addi	sp,sp,8
 b0001ac:	f800283a 	ret

0b0001b0 <alt_instruction_exception_entry>:
 * that handler if it has been registered. Absent a handler, it will
 * break break or hang as discussed below.
 */
int 
alt_instruction_exception_entry (alt_u32 exception_pc)
{
 b0001b0:	defffb04 	addi	sp,sp,-20
 b0001b4:	dfc00415 	stw	ra,16(sp)
 b0001b8:	df000315 	stw	fp,12(sp)
 b0001bc:	df000304 	addi	fp,sp,12
 b0001c0:	e13fff15 	stw	r4,-4(fp)
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
              NIOS2_EXCEPTION_REG_CAUSE_OFST );

  NIOS2_READ_BADADDR(badaddr);
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
 b0001c4:	00bfffc4 	movi	r2,-1
 b0001c8:	e0bffd15 	stw	r2,-12(fp)
  badaddr = 0;
 b0001cc:	e03ffe15 	stw	zero,-8(fp)
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
 b0001d0:	d0a72617 	ldw	r2,-25448(gp)
 b0001d4:	10000726 	beq	r2,zero,b0001f4 <alt_instruction_exception_entry+0x44>
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
 b0001d8:	d0a72617 	ldw	r2,-25448(gp)
 b0001dc:	e0fffd17 	ldw	r3,-12(fp)
 b0001e0:	e1bffe17 	ldw	r6,-8(fp)
 b0001e4:	e17fff17 	ldw	r5,-4(fp)
 b0001e8:	1809883a 	mov	r4,r3
 b0001ec:	103ee83a 	callr	r2
 b0001f0:	00000206 	br	b0001fc <alt_instruction_exception_entry+0x4c>
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
 b0001f4:	003da03a 	break	0
      ;
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
 b0001f8:	0005883a 	mov	r2,zero
}
 b0001fc:	e037883a 	mov	sp,fp
 b000200:	dfc00117 	ldw	ra,4(sp)
 b000204:	df000017 	ldw	fp,0(sp)
 b000208:	dec00204 	addi	sp,sp,8
 b00020c:	f800283a 	ret

Disassembly of section .text:

0b000210 <_start>:

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
 b000210:	06c30034 	movhi	sp,3072
    ori sp, sp, %lo(__alt_stack_pointer)
 b000214:	dec00014 	ori	sp,sp,0
    movhi gp, %hi(_gp)
 b000218:	0682c074 	movhi	gp,2817
    ori gp, gp, %lo(_gp)
 b00021c:	d6848c14 	ori	gp,gp,4656
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
 b000220:	0082c034 	movhi	r2,2816
    ori r2, r2, %lo(__bss_start)
 b000224:	10aba814 	ori	r2,r2,44704

    movhi r3, %hi(__bss_end)
 b000228:	00c2c034 	movhi	r3,2816
    ori r3, r3, %lo(__bss_end)
 b00022c:	18ebfd14 	ori	r3,r3,45044

    beq r2, r3, 1f
 b000230:	10c00326 	beq	r2,r3,b000240 <_start+0x30>

0:
    stw zero, (r2)
 b000234:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
 b000238:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
 b00023c:	10fffd36 	bltu	r2,r3,b000234 <__alt_mem_flash+0xfefff234>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
 b000240:	b0033bc0 	call	b0033bc <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
 b000244:	b0035580 	call	b003558 <alt_main>

0b000248 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
 b000248:	003fff06 	br	b000248 <__alt_mem_flash+0xfefff248>

0b00024c <main>:
#include <stdio.h>

int main()
{
 b00024c:	defffe04 	addi	sp,sp,-8
 b000250:	dfc00115 	stw	ra,4(sp)
 b000254:	df000015 	stw	fp,0(sp)
 b000258:	d839883a 	mov	fp,sp
	while(1){
		fprintf(stderr,"goodbye world!\n");
 b00025c:	d0a00117 	ldw	r2,-32764(gp)
 b000260:	10800317 	ldw	r2,12(r2)
 b000264:	100f883a 	mov	r7,r2
 b000268:	018003c4 	movi	r6,15
 b00026c:	01400044 	movi	r5,1
 b000270:	0102c034 	movhi	r4,2816
 b000274:	211d7504 	addi	r4,r4,30164
 b000278:	b0003640 	call	b000364 <fwrite>
		usleep(1000);
 b00027c:	0100fa04 	movi	r4,1000
 b000280:	b0038900 	call	b003890 <usleep>
	}
 b000284:	003ff506 	br	b00025c <__alt_mem_flash+0xfefff25c>

0b000288 <_fwrite_r>:
 b000288:	defff504 	addi	sp,sp,-44
 b00028c:	dc400715 	stw	r17,28(sp)
 b000290:	d9400315 	stw	r5,12(sp)
 b000294:	2023883a 	mov	r17,r4
 b000298:	300b883a 	mov	r5,r6
 b00029c:	3809883a 	mov	r4,r7
 b0002a0:	dcc00915 	stw	r19,36(sp)
 b0002a4:	dc800815 	stw	r18,32(sp)
 b0002a8:	dc000615 	stw	r16,24(sp)
 b0002ac:	dfc00a15 	stw	ra,40(sp)
 b0002b0:	3027883a 	mov	r19,r6
 b0002b4:	3821883a 	mov	r16,r7
 b0002b8:	b0030100 	call	b003010 <__mulsi3>
 b0002bc:	1025883a 	mov	r18,r2
 b0002c0:	d8800415 	stw	r2,16(sp)
 b0002c4:	d8800215 	stw	r2,8(sp)
 b0002c8:	d8800304 	addi	r2,sp,12
 b0002cc:	d8800015 	stw	r2,0(sp)
 b0002d0:	00800044 	movi	r2,1
 b0002d4:	d8800115 	stw	r2,4(sp)
 b0002d8:	d9400b17 	ldw	r5,44(sp)
 b0002dc:	88000226 	beq	r17,zero,b0002e8 <_fwrite_r+0x60>
 b0002e0:	88800e17 	ldw	r2,56(r17)
 b0002e4:	10001a26 	beq	r2,zero,b000350 <_fwrite_r+0xc8>
 b0002e8:	2880030b 	ldhu	r2,12(r5)
 b0002ec:	10c8000c 	andi	r3,r2,8192
 b0002f0:	1800061e 	bne	r3,zero,b00030c <_fwrite_r+0x84>
 b0002f4:	29001917 	ldw	r4,100(r5)
 b0002f8:	00f7ffc4 	movi	r3,-8193
 b0002fc:	10880014 	ori	r2,r2,8192
 b000300:	20c6703a 	and	r3,r4,r3
 b000304:	2880030d 	sth	r2,12(r5)
 b000308:	28c01915 	stw	r3,100(r5)
 b00030c:	d80d883a 	mov	r6,sp
 b000310:	8809883a 	mov	r4,r17
 b000314:	b0007480 	call	b000748 <__sfvwrite_r>
 b000318:	10000b26 	beq	r2,zero,b000348 <_fwrite_r+0xc0>
 b00031c:	d9000217 	ldw	r4,8(sp)
 b000320:	980b883a 	mov	r5,r19
 b000324:	9109c83a 	sub	r4,r18,r4
 b000328:	b002f540 	call	b002f54 <__udivsi3>
 b00032c:	dfc00a17 	ldw	ra,40(sp)
 b000330:	dcc00917 	ldw	r19,36(sp)
 b000334:	dc800817 	ldw	r18,32(sp)
 b000338:	dc400717 	ldw	r17,28(sp)
 b00033c:	dc000617 	ldw	r16,24(sp)
 b000340:	dec00b04 	addi	sp,sp,44
 b000344:	f800283a 	ret
 b000348:	8005883a 	mov	r2,r16
 b00034c:	003ff706 	br	b00032c <__alt_mem_flash+0xfefff32c>
 b000350:	8809883a 	mov	r4,r17
 b000354:	d9400515 	stw	r5,20(sp)
 b000358:	b0006f80 	call	b0006f8 <__sinit>
 b00035c:	d9400517 	ldw	r5,20(sp)
 b000360:	003fe106 	br	b0002e8 <__alt_mem_flash+0xfefff2e8>

0b000364 <fwrite>:
 b000364:	defffe04 	addi	sp,sp,-8
 b000368:	0082c074 	movhi	r2,2817
 b00036c:	d9c00015 	stw	r7,0(sp)
 b000370:	10a48d04 	addi	r2,r2,-28108
 b000374:	300f883a 	mov	r7,r6
 b000378:	280d883a 	mov	r6,r5
 b00037c:	200b883a 	mov	r5,r4
 b000380:	11000017 	ldw	r4,0(r2)
 b000384:	dfc00115 	stw	ra,4(sp)
 b000388:	b0002880 	call	b000288 <_fwrite_r>
 b00038c:	dfc00117 	ldw	ra,4(sp)
 b000390:	dec00204 	addi	sp,sp,8
 b000394:	f800283a 	ret

0b000398 <__fp_unlock>:
 b000398:	0005883a 	mov	r2,zero
 b00039c:	f800283a 	ret

0b0003a0 <_cleanup_r>:
 b0003a0:	0142c034 	movhi	r5,2816
 b0003a4:	2948d404 	addi	r5,r5,9040
 b0003a8:	b000cd41 	jmpi	b000cd4 <_fwalk_reent>

0b0003ac <__sinit.part.1>:
 b0003ac:	defff704 	addi	sp,sp,-36
 b0003b0:	00c2c034 	movhi	r3,2816
 b0003b4:	dfc00815 	stw	ra,32(sp)
 b0003b8:	ddc00715 	stw	r23,28(sp)
 b0003bc:	dd800615 	stw	r22,24(sp)
 b0003c0:	dd400515 	stw	r21,20(sp)
 b0003c4:	dd000415 	stw	r20,16(sp)
 b0003c8:	dcc00315 	stw	r19,12(sp)
 b0003cc:	dc800215 	stw	r18,8(sp)
 b0003d0:	dc400115 	stw	r17,4(sp)
 b0003d4:	dc000015 	stw	r16,0(sp)
 b0003d8:	18c0e804 	addi	r3,r3,928
 b0003dc:	24000117 	ldw	r16,4(r4)
 b0003e0:	20c00f15 	stw	r3,60(r4)
 b0003e4:	2080bb04 	addi	r2,r4,748
 b0003e8:	00c000c4 	movi	r3,3
 b0003ec:	20c0b915 	stw	r3,740(r4)
 b0003f0:	2080ba15 	stw	r2,744(r4)
 b0003f4:	2000b815 	stw	zero,736(r4)
 b0003f8:	05c00204 	movi	r23,8
 b0003fc:	00800104 	movi	r2,4
 b000400:	2025883a 	mov	r18,r4
 b000404:	b80d883a 	mov	r6,r23
 b000408:	81001704 	addi	r4,r16,92
 b00040c:	000b883a 	mov	r5,zero
 b000410:	80000015 	stw	zero,0(r16)
 b000414:	80000115 	stw	zero,4(r16)
 b000418:	80000215 	stw	zero,8(r16)
 b00041c:	8080030d 	sth	r2,12(r16)
 b000420:	80001915 	stw	zero,100(r16)
 b000424:	8000038d 	sth	zero,14(r16)
 b000428:	80000415 	stw	zero,16(r16)
 b00042c:	80000515 	stw	zero,20(r16)
 b000430:	80000615 	stw	zero,24(r16)
 b000434:	b00192c0 	call	b00192c <memset>
 b000438:	0582c034 	movhi	r22,2816
 b00043c:	94400217 	ldw	r17,8(r18)
 b000440:	0542c034 	movhi	r21,2816
 b000444:	0502c034 	movhi	r20,2816
 b000448:	04c2c034 	movhi	r19,2816
 b00044c:	b5880304 	addi	r22,r22,8204
 b000450:	ad481a04 	addi	r21,r21,8296
 b000454:	a5083904 	addi	r20,r20,8420
 b000458:	9cc85004 	addi	r19,r19,8512
 b00045c:	85800815 	stw	r22,32(r16)
 b000460:	85400915 	stw	r21,36(r16)
 b000464:	85000a15 	stw	r20,40(r16)
 b000468:	84c00b15 	stw	r19,44(r16)
 b00046c:	84000715 	stw	r16,28(r16)
 b000470:	00800284 	movi	r2,10
 b000474:	8880030d 	sth	r2,12(r17)
 b000478:	00800044 	movi	r2,1
 b00047c:	b80d883a 	mov	r6,r23
 b000480:	89001704 	addi	r4,r17,92
 b000484:	000b883a 	mov	r5,zero
 b000488:	88000015 	stw	zero,0(r17)
 b00048c:	88000115 	stw	zero,4(r17)
 b000490:	88000215 	stw	zero,8(r17)
 b000494:	88001915 	stw	zero,100(r17)
 b000498:	8880038d 	sth	r2,14(r17)
 b00049c:	88000415 	stw	zero,16(r17)
 b0004a0:	88000515 	stw	zero,20(r17)
 b0004a4:	88000615 	stw	zero,24(r17)
 b0004a8:	b00192c0 	call	b00192c <memset>
 b0004ac:	94000317 	ldw	r16,12(r18)
 b0004b0:	00800484 	movi	r2,18
 b0004b4:	8c400715 	stw	r17,28(r17)
 b0004b8:	8d800815 	stw	r22,32(r17)
 b0004bc:	8d400915 	stw	r21,36(r17)
 b0004c0:	8d000a15 	stw	r20,40(r17)
 b0004c4:	8cc00b15 	stw	r19,44(r17)
 b0004c8:	8080030d 	sth	r2,12(r16)
 b0004cc:	00800084 	movi	r2,2
 b0004d0:	80000015 	stw	zero,0(r16)
 b0004d4:	80000115 	stw	zero,4(r16)
 b0004d8:	80000215 	stw	zero,8(r16)
 b0004dc:	80001915 	stw	zero,100(r16)
 b0004e0:	8080038d 	sth	r2,14(r16)
 b0004e4:	80000415 	stw	zero,16(r16)
 b0004e8:	80000515 	stw	zero,20(r16)
 b0004ec:	80000615 	stw	zero,24(r16)
 b0004f0:	b80d883a 	mov	r6,r23
 b0004f4:	000b883a 	mov	r5,zero
 b0004f8:	81001704 	addi	r4,r16,92
 b0004fc:	b00192c0 	call	b00192c <memset>
 b000500:	00800044 	movi	r2,1
 b000504:	84000715 	stw	r16,28(r16)
 b000508:	85800815 	stw	r22,32(r16)
 b00050c:	85400915 	stw	r21,36(r16)
 b000510:	85000a15 	stw	r20,40(r16)
 b000514:	84c00b15 	stw	r19,44(r16)
 b000518:	90800e15 	stw	r2,56(r18)
 b00051c:	dfc00817 	ldw	ra,32(sp)
 b000520:	ddc00717 	ldw	r23,28(sp)
 b000524:	dd800617 	ldw	r22,24(sp)
 b000528:	dd400517 	ldw	r21,20(sp)
 b00052c:	dd000417 	ldw	r20,16(sp)
 b000530:	dcc00317 	ldw	r19,12(sp)
 b000534:	dc800217 	ldw	r18,8(sp)
 b000538:	dc400117 	ldw	r17,4(sp)
 b00053c:	dc000017 	ldw	r16,0(sp)
 b000540:	dec00904 	addi	sp,sp,36
 b000544:	f800283a 	ret

0b000548 <__fp_lock>:
 b000548:	0005883a 	mov	r2,zero
 b00054c:	f800283a 	ret

0b000550 <__sfmoreglue>:
 b000550:	defffc04 	addi	sp,sp,-16
 b000554:	dc800215 	stw	r18,8(sp)
 b000558:	2825883a 	mov	r18,r5
 b00055c:	dc000015 	stw	r16,0(sp)
 b000560:	01401a04 	movi	r5,104
 b000564:	2021883a 	mov	r16,r4
 b000568:	913fffc4 	addi	r4,r18,-1
 b00056c:	dfc00315 	stw	ra,12(sp)
 b000570:	dc400115 	stw	r17,4(sp)
 b000574:	b0030100 	call	b003010 <__mulsi3>
 b000578:	8009883a 	mov	r4,r16
 b00057c:	11401d04 	addi	r5,r2,116
 b000580:	1023883a 	mov	r17,r2
 b000584:	b000d980 	call	b000d98 <_malloc_r>
 b000588:	1021883a 	mov	r16,r2
 b00058c:	10000726 	beq	r2,zero,b0005ac <__sfmoreglue+0x5c>
 b000590:	11000304 	addi	r4,r2,12
 b000594:	10000015 	stw	zero,0(r2)
 b000598:	14800115 	stw	r18,4(r2)
 b00059c:	11000215 	stw	r4,8(r2)
 b0005a0:	89801a04 	addi	r6,r17,104
 b0005a4:	000b883a 	mov	r5,zero
 b0005a8:	b00192c0 	call	b00192c <memset>
 b0005ac:	8005883a 	mov	r2,r16
 b0005b0:	dfc00317 	ldw	ra,12(sp)
 b0005b4:	dc800217 	ldw	r18,8(sp)
 b0005b8:	dc400117 	ldw	r17,4(sp)
 b0005bc:	dc000017 	ldw	r16,0(sp)
 b0005c0:	dec00404 	addi	sp,sp,16
 b0005c4:	f800283a 	ret

0b0005c8 <__sfp>:
 b0005c8:	defffb04 	addi	sp,sp,-20
 b0005cc:	dc000015 	stw	r16,0(sp)
 b0005d0:	0402c074 	movhi	r16,2817
 b0005d4:	84248c04 	addi	r16,r16,-28112
 b0005d8:	dcc00315 	stw	r19,12(sp)
 b0005dc:	2027883a 	mov	r19,r4
 b0005e0:	81000017 	ldw	r4,0(r16)
 b0005e4:	dfc00415 	stw	ra,16(sp)
 b0005e8:	dc800215 	stw	r18,8(sp)
 b0005ec:	20800e17 	ldw	r2,56(r4)
 b0005f0:	dc400115 	stw	r17,4(sp)
 b0005f4:	1000021e 	bne	r2,zero,b000600 <__sfp+0x38>
 b0005f8:	b0003ac0 	call	b0003ac <__sinit.part.1>
 b0005fc:	81000017 	ldw	r4,0(r16)
 b000600:	2480b804 	addi	r18,r4,736
 b000604:	047fffc4 	movi	r17,-1
 b000608:	91000117 	ldw	r4,4(r18)
 b00060c:	94000217 	ldw	r16,8(r18)
 b000610:	213fffc4 	addi	r4,r4,-1
 b000614:	20000a16 	blt	r4,zero,b000640 <__sfp+0x78>
 b000618:	8080030f 	ldh	r2,12(r16)
 b00061c:	10000c26 	beq	r2,zero,b000650 <__sfp+0x88>
 b000620:	80c01d04 	addi	r3,r16,116
 b000624:	00000206 	br	b000630 <__sfp+0x68>
 b000628:	18bfe60f 	ldh	r2,-104(r3)
 b00062c:	10000826 	beq	r2,zero,b000650 <__sfp+0x88>
 b000630:	213fffc4 	addi	r4,r4,-1
 b000634:	1c3ffd04 	addi	r16,r3,-12
 b000638:	18c01a04 	addi	r3,r3,104
 b00063c:	247ffa1e 	bne	r4,r17,b000628 <__alt_mem_flash+0xfefff628>
 b000640:	90800017 	ldw	r2,0(r18)
 b000644:	10001d26 	beq	r2,zero,b0006bc <__sfp+0xf4>
 b000648:	1025883a 	mov	r18,r2
 b00064c:	003fee06 	br	b000608 <__alt_mem_flash+0xfefff608>
 b000650:	00bfffc4 	movi	r2,-1
 b000654:	8080038d 	sth	r2,14(r16)
 b000658:	00800044 	movi	r2,1
 b00065c:	8080030d 	sth	r2,12(r16)
 b000660:	80001915 	stw	zero,100(r16)
 b000664:	80000015 	stw	zero,0(r16)
 b000668:	80000215 	stw	zero,8(r16)
 b00066c:	80000115 	stw	zero,4(r16)
 b000670:	80000415 	stw	zero,16(r16)
 b000674:	80000515 	stw	zero,20(r16)
 b000678:	80000615 	stw	zero,24(r16)
 b00067c:	01800204 	movi	r6,8
 b000680:	000b883a 	mov	r5,zero
 b000684:	81001704 	addi	r4,r16,92
 b000688:	b00192c0 	call	b00192c <memset>
 b00068c:	8005883a 	mov	r2,r16
 b000690:	80000c15 	stw	zero,48(r16)
 b000694:	80000d15 	stw	zero,52(r16)
 b000698:	80001115 	stw	zero,68(r16)
 b00069c:	80001215 	stw	zero,72(r16)
 b0006a0:	dfc00417 	ldw	ra,16(sp)
 b0006a4:	dcc00317 	ldw	r19,12(sp)
 b0006a8:	dc800217 	ldw	r18,8(sp)
 b0006ac:	dc400117 	ldw	r17,4(sp)
 b0006b0:	dc000017 	ldw	r16,0(sp)
 b0006b4:	dec00504 	addi	sp,sp,20
 b0006b8:	f800283a 	ret
 b0006bc:	01400104 	movi	r5,4
 b0006c0:	9809883a 	mov	r4,r19
 b0006c4:	b0005500 	call	b000550 <__sfmoreglue>
 b0006c8:	90800015 	stw	r2,0(r18)
 b0006cc:	103fde1e 	bne	r2,zero,b000648 <__alt_mem_flash+0xfefff648>
 b0006d0:	00800304 	movi	r2,12
 b0006d4:	98800015 	stw	r2,0(r19)
 b0006d8:	0005883a 	mov	r2,zero
 b0006dc:	003ff006 	br	b0006a0 <__alt_mem_flash+0xfefff6a0>

0b0006e0 <_cleanup>:
 b0006e0:	0082c074 	movhi	r2,2817
 b0006e4:	10a48c04 	addi	r2,r2,-28112
 b0006e8:	11000017 	ldw	r4,0(r2)
 b0006ec:	0142c034 	movhi	r5,2816
 b0006f0:	2948d404 	addi	r5,r5,9040
 b0006f4:	b000cd41 	jmpi	b000cd4 <_fwalk_reent>

0b0006f8 <__sinit>:
 b0006f8:	20800e17 	ldw	r2,56(r4)
 b0006fc:	10000126 	beq	r2,zero,b000704 <__sinit+0xc>
 b000700:	f800283a 	ret
 b000704:	b0003ac1 	jmpi	b0003ac <__sinit.part.1>

0b000708 <__sfp_lock_acquire>:
 b000708:	f800283a 	ret

0b00070c <__sfp_lock_release>:
 b00070c:	f800283a 	ret

0b000710 <__sinit_lock_acquire>:
 b000710:	f800283a 	ret

0b000714 <__sinit_lock_release>:
 b000714:	f800283a 	ret

0b000718 <__fp_lock_all>:
 b000718:	0082c074 	movhi	r2,2817
 b00071c:	10a48d04 	addi	r2,r2,-28108
 b000720:	11000017 	ldw	r4,0(r2)
 b000724:	0142c034 	movhi	r5,2816
 b000728:	29415204 	addi	r5,r5,1352
 b00072c:	b000c101 	jmpi	b000c10 <_fwalk>

0b000730 <__fp_unlock_all>:
 b000730:	0082c074 	movhi	r2,2817
 b000734:	10a48d04 	addi	r2,r2,-28108
 b000738:	11000017 	ldw	r4,0(r2)
 b00073c:	0142c034 	movhi	r5,2816
 b000740:	2940e604 	addi	r5,r5,920
 b000744:	b000c101 	jmpi	b000c10 <_fwalk>

0b000748 <__sfvwrite_r>:
 b000748:	30800217 	ldw	r2,8(r6)
 b00074c:	10006726 	beq	r2,zero,b0008ec <__sfvwrite_r+0x1a4>
 b000750:	28c0030b 	ldhu	r3,12(r5)
 b000754:	defff404 	addi	sp,sp,-48
 b000758:	dd400715 	stw	r21,28(sp)
 b00075c:	dd000615 	stw	r20,24(sp)
 b000760:	dc000215 	stw	r16,8(sp)
 b000764:	dfc00b15 	stw	ra,44(sp)
 b000768:	df000a15 	stw	fp,40(sp)
 b00076c:	ddc00915 	stw	r23,36(sp)
 b000770:	dd800815 	stw	r22,32(sp)
 b000774:	dcc00515 	stw	r19,20(sp)
 b000778:	dc800415 	stw	r18,16(sp)
 b00077c:	dc400315 	stw	r17,12(sp)
 b000780:	1880020c 	andi	r2,r3,8
 b000784:	2821883a 	mov	r16,r5
 b000788:	202b883a 	mov	r21,r4
 b00078c:	3029883a 	mov	r20,r6
 b000790:	10002726 	beq	r2,zero,b000830 <__sfvwrite_r+0xe8>
 b000794:	28800417 	ldw	r2,16(r5)
 b000798:	10002526 	beq	r2,zero,b000830 <__sfvwrite_r+0xe8>
 b00079c:	1880008c 	andi	r2,r3,2
 b0007a0:	a4400017 	ldw	r17,0(r20)
 b0007a4:	10002a26 	beq	r2,zero,b000850 <__sfvwrite_r+0x108>
 b0007a8:	05a00034 	movhi	r22,32768
 b0007ac:	0027883a 	mov	r19,zero
 b0007b0:	0025883a 	mov	r18,zero
 b0007b4:	b5bf0004 	addi	r22,r22,-1024
 b0007b8:	980d883a 	mov	r6,r19
 b0007bc:	a809883a 	mov	r4,r21
 b0007c0:	90004626 	beq	r18,zero,b0008dc <__sfvwrite_r+0x194>
 b0007c4:	900f883a 	mov	r7,r18
 b0007c8:	b480022e 	bgeu	r22,r18,b0007d4 <__sfvwrite_r+0x8c>
 b0007cc:	01e00034 	movhi	r7,32768
 b0007d0:	39ff0004 	addi	r7,r7,-1024
 b0007d4:	80800917 	ldw	r2,36(r16)
 b0007d8:	81400717 	ldw	r5,28(r16)
 b0007dc:	103ee83a 	callr	r2
 b0007e0:	00805a0e 	bge	zero,r2,b00094c <__sfvwrite_r+0x204>
 b0007e4:	a0c00217 	ldw	r3,8(r20)
 b0007e8:	98a7883a 	add	r19,r19,r2
 b0007ec:	90a5c83a 	sub	r18,r18,r2
 b0007f0:	1885c83a 	sub	r2,r3,r2
 b0007f4:	a0800215 	stw	r2,8(r20)
 b0007f8:	103fef1e 	bne	r2,zero,b0007b8 <__alt_mem_flash+0xfefff7b8>
 b0007fc:	0005883a 	mov	r2,zero
 b000800:	dfc00b17 	ldw	ra,44(sp)
 b000804:	df000a17 	ldw	fp,40(sp)
 b000808:	ddc00917 	ldw	r23,36(sp)
 b00080c:	dd800817 	ldw	r22,32(sp)
 b000810:	dd400717 	ldw	r21,28(sp)
 b000814:	dd000617 	ldw	r20,24(sp)
 b000818:	dcc00517 	ldw	r19,20(sp)
 b00081c:	dc800417 	ldw	r18,16(sp)
 b000820:	dc400317 	ldw	r17,12(sp)
 b000824:	dc000217 	ldw	r16,8(sp)
 b000828:	dec00c04 	addi	sp,sp,48
 b00082c:	f800283a 	ret
 b000830:	800b883a 	mov	r5,r16
 b000834:	a809883a 	mov	r4,r21
 b000838:	b0021a80 	call	b0021a8 <__swsetup_r>
 b00083c:	1000ee1e 	bne	r2,zero,b000bf8 <__sfvwrite_r+0x4b0>
 b000840:	80c0030b 	ldhu	r3,12(r16)
 b000844:	a4400017 	ldw	r17,0(r20)
 b000848:	1880008c 	andi	r2,r3,2
 b00084c:	103fd61e 	bne	r2,zero,b0007a8 <__alt_mem_flash+0xfefff7a8>
 b000850:	1880004c 	andi	r2,r3,1
 b000854:	1000421e 	bne	r2,zero,b000960 <__sfvwrite_r+0x218>
 b000858:	0039883a 	mov	fp,zero
 b00085c:	0025883a 	mov	r18,zero
 b000860:	90001a26 	beq	r18,zero,b0008cc <__sfvwrite_r+0x184>
 b000864:	1880800c 	andi	r2,r3,512
 b000868:	84c00217 	ldw	r19,8(r16)
 b00086c:	10002126 	beq	r2,zero,b0008f4 <__sfvwrite_r+0x1ac>
 b000870:	982f883a 	mov	r23,r19
 b000874:	94c09636 	bltu	r18,r19,b000ad0 <__sfvwrite_r+0x388>
 b000878:	1881200c 	andi	r2,r3,1152
 b00087c:	1000a11e 	bne	r2,zero,b000b04 <__sfvwrite_r+0x3bc>
 b000880:	81000017 	ldw	r4,0(r16)
 b000884:	b80d883a 	mov	r6,r23
 b000888:	e00b883a 	mov	r5,fp
 b00088c:	b0017d00 	call	b0017d0 <memmove>
 b000890:	80c00217 	ldw	r3,8(r16)
 b000894:	81000017 	ldw	r4,0(r16)
 b000898:	9005883a 	mov	r2,r18
 b00089c:	1ce7c83a 	sub	r19,r3,r19
 b0008a0:	25cf883a 	add	r7,r4,r23
 b0008a4:	84c00215 	stw	r19,8(r16)
 b0008a8:	81c00015 	stw	r7,0(r16)
 b0008ac:	a0c00217 	ldw	r3,8(r20)
 b0008b0:	e0b9883a 	add	fp,fp,r2
 b0008b4:	90a5c83a 	sub	r18,r18,r2
 b0008b8:	18a7c83a 	sub	r19,r3,r2
 b0008bc:	a4c00215 	stw	r19,8(r20)
 b0008c0:	983fce26 	beq	r19,zero,b0007fc <__alt_mem_flash+0xfefff7fc>
 b0008c4:	80c0030b 	ldhu	r3,12(r16)
 b0008c8:	903fe61e 	bne	r18,zero,b000864 <__alt_mem_flash+0xfefff864>
 b0008cc:	8f000017 	ldw	fp,0(r17)
 b0008d0:	8c800117 	ldw	r18,4(r17)
 b0008d4:	8c400204 	addi	r17,r17,8
 b0008d8:	003fe106 	br	b000860 <__alt_mem_flash+0xfefff860>
 b0008dc:	8cc00017 	ldw	r19,0(r17)
 b0008e0:	8c800117 	ldw	r18,4(r17)
 b0008e4:	8c400204 	addi	r17,r17,8
 b0008e8:	003fb306 	br	b0007b8 <__alt_mem_flash+0xfefff7b8>
 b0008ec:	0005883a 	mov	r2,zero
 b0008f0:	f800283a 	ret
 b0008f4:	81000017 	ldw	r4,0(r16)
 b0008f8:	80800417 	ldw	r2,16(r16)
 b0008fc:	11005a36 	bltu	r2,r4,b000a68 <__sfvwrite_r+0x320>
 b000900:	85c00517 	ldw	r23,20(r16)
 b000904:	95c05836 	bltu	r18,r23,b000a68 <__sfvwrite_r+0x320>
 b000908:	00a00034 	movhi	r2,32768
 b00090c:	10bfffc4 	addi	r2,r2,-1
 b000910:	9009883a 	mov	r4,r18
 b000914:	1480012e 	bgeu	r2,r18,b00091c <__sfvwrite_r+0x1d4>
 b000918:	1009883a 	mov	r4,r2
 b00091c:	b80b883a 	mov	r5,r23
 b000920:	b002e5c0 	call	b002e5c <__divsi3>
 b000924:	b80b883a 	mov	r5,r23
 b000928:	1009883a 	mov	r4,r2
 b00092c:	b0030100 	call	b003010 <__mulsi3>
 b000930:	81400717 	ldw	r5,28(r16)
 b000934:	80c00917 	ldw	r3,36(r16)
 b000938:	100f883a 	mov	r7,r2
 b00093c:	e00d883a 	mov	r6,fp
 b000940:	a809883a 	mov	r4,r21
 b000944:	183ee83a 	callr	r3
 b000948:	00bfd816 	blt	zero,r2,b0008ac <__alt_mem_flash+0xfefff8ac>
 b00094c:	8080030b 	ldhu	r2,12(r16)
 b000950:	10801014 	ori	r2,r2,64
 b000954:	8080030d 	sth	r2,12(r16)
 b000958:	00bfffc4 	movi	r2,-1
 b00095c:	003fa806 	br	b000800 <__alt_mem_flash+0xfefff800>
 b000960:	0027883a 	mov	r19,zero
 b000964:	0011883a 	mov	r8,zero
 b000968:	0039883a 	mov	fp,zero
 b00096c:	0025883a 	mov	r18,zero
 b000970:	90001f26 	beq	r18,zero,b0009f0 <__sfvwrite_r+0x2a8>
 b000974:	40005a26 	beq	r8,zero,b000ae0 <__sfvwrite_r+0x398>
 b000978:	982d883a 	mov	r22,r19
 b00097c:	94c0012e 	bgeu	r18,r19,b000984 <__sfvwrite_r+0x23c>
 b000980:	902d883a 	mov	r22,r18
 b000984:	81000017 	ldw	r4,0(r16)
 b000988:	80800417 	ldw	r2,16(r16)
 b00098c:	b02f883a 	mov	r23,r22
 b000990:	81c00517 	ldw	r7,20(r16)
 b000994:	1100032e 	bgeu	r2,r4,b0009a4 <__sfvwrite_r+0x25c>
 b000998:	80c00217 	ldw	r3,8(r16)
 b00099c:	38c7883a 	add	r3,r7,r3
 b0009a0:	1d801816 	blt	r3,r22,b000a04 <__sfvwrite_r+0x2bc>
 b0009a4:	b1c03e16 	blt	r22,r7,b000aa0 <__sfvwrite_r+0x358>
 b0009a8:	80800917 	ldw	r2,36(r16)
 b0009ac:	81400717 	ldw	r5,28(r16)
 b0009b0:	e00d883a 	mov	r6,fp
 b0009b4:	da000115 	stw	r8,4(sp)
 b0009b8:	a809883a 	mov	r4,r21
 b0009bc:	103ee83a 	callr	r2
 b0009c0:	102f883a 	mov	r23,r2
 b0009c4:	da000117 	ldw	r8,4(sp)
 b0009c8:	00bfe00e 	bge	zero,r2,b00094c <__alt_mem_flash+0xfefff94c>
 b0009cc:	9de7c83a 	sub	r19,r19,r23
 b0009d0:	98001f26 	beq	r19,zero,b000a50 <__sfvwrite_r+0x308>
 b0009d4:	a0800217 	ldw	r2,8(r20)
 b0009d8:	e5f9883a 	add	fp,fp,r23
 b0009dc:	95e5c83a 	sub	r18,r18,r23
 b0009e0:	15efc83a 	sub	r23,r2,r23
 b0009e4:	a5c00215 	stw	r23,8(r20)
 b0009e8:	b83f8426 	beq	r23,zero,b0007fc <__alt_mem_flash+0xfefff7fc>
 b0009ec:	903fe11e 	bne	r18,zero,b000974 <__alt_mem_flash+0xfefff974>
 b0009f0:	8f000017 	ldw	fp,0(r17)
 b0009f4:	8c800117 	ldw	r18,4(r17)
 b0009f8:	0011883a 	mov	r8,zero
 b0009fc:	8c400204 	addi	r17,r17,8
 b000a00:	003fdb06 	br	b000970 <__alt_mem_flash+0xfefff970>
 b000a04:	180d883a 	mov	r6,r3
 b000a08:	e00b883a 	mov	r5,fp
 b000a0c:	da000115 	stw	r8,4(sp)
 b000a10:	d8c00015 	stw	r3,0(sp)
 b000a14:	b0017d00 	call	b0017d0 <memmove>
 b000a18:	d8c00017 	ldw	r3,0(sp)
 b000a1c:	80800017 	ldw	r2,0(r16)
 b000a20:	800b883a 	mov	r5,r16
 b000a24:	a809883a 	mov	r4,r21
 b000a28:	10c5883a 	add	r2,r2,r3
 b000a2c:	80800015 	stw	r2,0(r16)
 b000a30:	d8c00015 	stw	r3,0(sp)
 b000a34:	b0026700 	call	b002670 <_fflush_r>
 b000a38:	d8c00017 	ldw	r3,0(sp)
 b000a3c:	da000117 	ldw	r8,4(sp)
 b000a40:	103fc21e 	bne	r2,zero,b00094c <__alt_mem_flash+0xfefff94c>
 b000a44:	182f883a 	mov	r23,r3
 b000a48:	9de7c83a 	sub	r19,r19,r23
 b000a4c:	983fe11e 	bne	r19,zero,b0009d4 <__alt_mem_flash+0xfefff9d4>
 b000a50:	800b883a 	mov	r5,r16
 b000a54:	a809883a 	mov	r4,r21
 b000a58:	b0026700 	call	b002670 <_fflush_r>
 b000a5c:	103fbb1e 	bne	r2,zero,b00094c <__alt_mem_flash+0xfefff94c>
 b000a60:	0011883a 	mov	r8,zero
 b000a64:	003fdb06 	br	b0009d4 <__alt_mem_flash+0xfefff9d4>
 b000a68:	94c0012e 	bgeu	r18,r19,b000a70 <__sfvwrite_r+0x328>
 b000a6c:	9027883a 	mov	r19,r18
 b000a70:	980d883a 	mov	r6,r19
 b000a74:	e00b883a 	mov	r5,fp
 b000a78:	b0017d00 	call	b0017d0 <memmove>
 b000a7c:	80800217 	ldw	r2,8(r16)
 b000a80:	80c00017 	ldw	r3,0(r16)
 b000a84:	14c5c83a 	sub	r2,r2,r19
 b000a88:	1cc7883a 	add	r3,r3,r19
 b000a8c:	80800215 	stw	r2,8(r16)
 b000a90:	80c00015 	stw	r3,0(r16)
 b000a94:	10004326 	beq	r2,zero,b000ba4 <__sfvwrite_r+0x45c>
 b000a98:	9805883a 	mov	r2,r19
 b000a9c:	003f8306 	br	b0008ac <__alt_mem_flash+0xfefff8ac>
 b000aa0:	b00d883a 	mov	r6,r22
 b000aa4:	e00b883a 	mov	r5,fp
 b000aa8:	da000115 	stw	r8,4(sp)
 b000aac:	b0017d00 	call	b0017d0 <memmove>
 b000ab0:	80800217 	ldw	r2,8(r16)
 b000ab4:	80c00017 	ldw	r3,0(r16)
 b000ab8:	da000117 	ldw	r8,4(sp)
 b000abc:	1585c83a 	sub	r2,r2,r22
 b000ac0:	1dad883a 	add	r22,r3,r22
 b000ac4:	80800215 	stw	r2,8(r16)
 b000ac8:	85800015 	stw	r22,0(r16)
 b000acc:	003fbf06 	br	b0009cc <__alt_mem_flash+0xfefff9cc>
 b000ad0:	81000017 	ldw	r4,0(r16)
 b000ad4:	9027883a 	mov	r19,r18
 b000ad8:	902f883a 	mov	r23,r18
 b000adc:	003f6906 	br	b000884 <__alt_mem_flash+0xfefff884>
 b000ae0:	900d883a 	mov	r6,r18
 b000ae4:	01400284 	movi	r5,10
 b000ae8:	e009883a 	mov	r4,fp
 b000aec:	b0015a40 	call	b0015a4 <memchr>
 b000af0:	10003e26 	beq	r2,zero,b000bec <__sfvwrite_r+0x4a4>
 b000af4:	10800044 	addi	r2,r2,1
 b000af8:	1727c83a 	sub	r19,r2,fp
 b000afc:	02000044 	movi	r8,1
 b000b00:	003f9d06 	br	b000978 <__alt_mem_flash+0xfefff978>
 b000b04:	80800517 	ldw	r2,20(r16)
 b000b08:	81400417 	ldw	r5,16(r16)
 b000b0c:	81c00017 	ldw	r7,0(r16)
 b000b10:	10a7883a 	add	r19,r2,r2
 b000b14:	9885883a 	add	r2,r19,r2
 b000b18:	1026d7fa 	srli	r19,r2,31
 b000b1c:	396dc83a 	sub	r22,r7,r5
 b000b20:	b1000044 	addi	r4,r22,1
 b000b24:	9885883a 	add	r2,r19,r2
 b000b28:	1027d07a 	srai	r19,r2,1
 b000b2c:	2485883a 	add	r2,r4,r18
 b000b30:	980d883a 	mov	r6,r19
 b000b34:	9880022e 	bgeu	r19,r2,b000b40 <__sfvwrite_r+0x3f8>
 b000b38:	1027883a 	mov	r19,r2
 b000b3c:	100d883a 	mov	r6,r2
 b000b40:	18c1000c 	andi	r3,r3,1024
 b000b44:	18001c26 	beq	r3,zero,b000bb8 <__sfvwrite_r+0x470>
 b000b48:	300b883a 	mov	r5,r6
 b000b4c:	a809883a 	mov	r4,r21
 b000b50:	b000d980 	call	b000d98 <_malloc_r>
 b000b54:	102f883a 	mov	r23,r2
 b000b58:	10002926 	beq	r2,zero,b000c00 <__sfvwrite_r+0x4b8>
 b000b5c:	81400417 	ldw	r5,16(r16)
 b000b60:	b00d883a 	mov	r6,r22
 b000b64:	1009883a 	mov	r4,r2
 b000b68:	b0016880 	call	b001688 <memcpy>
 b000b6c:	8080030b 	ldhu	r2,12(r16)
 b000b70:	00fedfc4 	movi	r3,-1153
 b000b74:	10c4703a 	and	r2,r2,r3
 b000b78:	10802014 	ori	r2,r2,128
 b000b7c:	8080030d 	sth	r2,12(r16)
 b000b80:	bd89883a 	add	r4,r23,r22
 b000b84:	9d8fc83a 	sub	r7,r19,r22
 b000b88:	85c00415 	stw	r23,16(r16)
 b000b8c:	84c00515 	stw	r19,20(r16)
 b000b90:	81000015 	stw	r4,0(r16)
 b000b94:	9027883a 	mov	r19,r18
 b000b98:	81c00215 	stw	r7,8(r16)
 b000b9c:	902f883a 	mov	r23,r18
 b000ba0:	003f3806 	br	b000884 <__alt_mem_flash+0xfefff884>
 b000ba4:	800b883a 	mov	r5,r16
 b000ba8:	a809883a 	mov	r4,r21
 b000bac:	b0026700 	call	b002670 <_fflush_r>
 b000bb0:	103fb926 	beq	r2,zero,b000a98 <__alt_mem_flash+0xfefffa98>
 b000bb4:	003f6506 	br	b00094c <__alt_mem_flash+0xfefff94c>
 b000bb8:	a809883a 	mov	r4,r21
 b000bbc:	b001a540 	call	b001a54 <_realloc_r>
 b000bc0:	102f883a 	mov	r23,r2
 b000bc4:	103fee1e 	bne	r2,zero,b000b80 <__alt_mem_flash+0xfefffb80>
 b000bc8:	81400417 	ldw	r5,16(r16)
 b000bcc:	a809883a 	mov	r4,r21
 b000bd0:	b0028200 	call	b002820 <_free_r>
 b000bd4:	8080030b 	ldhu	r2,12(r16)
 b000bd8:	00ffdfc4 	movi	r3,-129
 b000bdc:	1884703a 	and	r2,r3,r2
 b000be0:	00c00304 	movi	r3,12
 b000be4:	a8c00015 	stw	r3,0(r21)
 b000be8:	003f5906 	br	b000950 <__alt_mem_flash+0xfefff950>
 b000bec:	94c00044 	addi	r19,r18,1
 b000bf0:	02000044 	movi	r8,1
 b000bf4:	003f6006 	br	b000978 <__alt_mem_flash+0xfefff978>
 b000bf8:	00bfffc4 	movi	r2,-1
 b000bfc:	003f0006 	br	b000800 <__alt_mem_flash+0xfefff800>
 b000c00:	00800304 	movi	r2,12
 b000c04:	a8800015 	stw	r2,0(r21)
 b000c08:	8080030b 	ldhu	r2,12(r16)
 b000c0c:	003f5006 	br	b000950 <__alt_mem_flash+0xfefff950>

0b000c10 <_fwalk>:
 b000c10:	defff704 	addi	sp,sp,-36
 b000c14:	dd000415 	stw	r20,16(sp)
 b000c18:	dfc00815 	stw	ra,32(sp)
 b000c1c:	ddc00715 	stw	r23,28(sp)
 b000c20:	dd800615 	stw	r22,24(sp)
 b000c24:	dd400515 	stw	r21,20(sp)
 b000c28:	dcc00315 	stw	r19,12(sp)
 b000c2c:	dc800215 	stw	r18,8(sp)
 b000c30:	dc400115 	stw	r17,4(sp)
 b000c34:	dc000015 	stw	r16,0(sp)
 b000c38:	2500b804 	addi	r20,r4,736
 b000c3c:	a0002326 	beq	r20,zero,b000ccc <_fwalk+0xbc>
 b000c40:	282b883a 	mov	r21,r5
 b000c44:	002f883a 	mov	r23,zero
 b000c48:	05800044 	movi	r22,1
 b000c4c:	04ffffc4 	movi	r19,-1
 b000c50:	a4400117 	ldw	r17,4(r20)
 b000c54:	a4800217 	ldw	r18,8(r20)
 b000c58:	8c7fffc4 	addi	r17,r17,-1
 b000c5c:	88000d16 	blt	r17,zero,b000c94 <_fwalk+0x84>
 b000c60:	94000304 	addi	r16,r18,12
 b000c64:	94800384 	addi	r18,r18,14
 b000c68:	8080000b 	ldhu	r2,0(r16)
 b000c6c:	8c7fffc4 	addi	r17,r17,-1
 b000c70:	813ffd04 	addi	r4,r16,-12
 b000c74:	b080042e 	bgeu	r22,r2,b000c88 <_fwalk+0x78>
 b000c78:	9080000f 	ldh	r2,0(r18)
 b000c7c:	14c00226 	beq	r2,r19,b000c88 <_fwalk+0x78>
 b000c80:	a83ee83a 	callr	r21
 b000c84:	b8aeb03a 	or	r23,r23,r2
 b000c88:	84001a04 	addi	r16,r16,104
 b000c8c:	94801a04 	addi	r18,r18,104
 b000c90:	8cfff51e 	bne	r17,r19,b000c68 <__alt_mem_flash+0xfefffc68>
 b000c94:	a5000017 	ldw	r20,0(r20)
 b000c98:	a03fed1e 	bne	r20,zero,b000c50 <__alt_mem_flash+0xfefffc50>
 b000c9c:	b805883a 	mov	r2,r23
 b000ca0:	dfc00817 	ldw	ra,32(sp)
 b000ca4:	ddc00717 	ldw	r23,28(sp)
 b000ca8:	dd800617 	ldw	r22,24(sp)
 b000cac:	dd400517 	ldw	r21,20(sp)
 b000cb0:	dd000417 	ldw	r20,16(sp)
 b000cb4:	dcc00317 	ldw	r19,12(sp)
 b000cb8:	dc800217 	ldw	r18,8(sp)
 b000cbc:	dc400117 	ldw	r17,4(sp)
 b000cc0:	dc000017 	ldw	r16,0(sp)
 b000cc4:	dec00904 	addi	sp,sp,36
 b000cc8:	f800283a 	ret
 b000ccc:	002f883a 	mov	r23,zero
 b000cd0:	003ff206 	br	b000c9c <__alt_mem_flash+0xfefffc9c>

0b000cd4 <_fwalk_reent>:
 b000cd4:	defff704 	addi	sp,sp,-36
 b000cd8:	dd000415 	stw	r20,16(sp)
 b000cdc:	dfc00815 	stw	ra,32(sp)
 b000ce0:	ddc00715 	stw	r23,28(sp)
 b000ce4:	dd800615 	stw	r22,24(sp)
 b000ce8:	dd400515 	stw	r21,20(sp)
 b000cec:	dcc00315 	stw	r19,12(sp)
 b000cf0:	dc800215 	stw	r18,8(sp)
 b000cf4:	dc400115 	stw	r17,4(sp)
 b000cf8:	dc000015 	stw	r16,0(sp)
 b000cfc:	2500b804 	addi	r20,r4,736
 b000d00:	a0002326 	beq	r20,zero,b000d90 <_fwalk_reent+0xbc>
 b000d04:	282b883a 	mov	r21,r5
 b000d08:	2027883a 	mov	r19,r4
 b000d0c:	002f883a 	mov	r23,zero
 b000d10:	05800044 	movi	r22,1
 b000d14:	04bfffc4 	movi	r18,-1
 b000d18:	a4400117 	ldw	r17,4(r20)
 b000d1c:	a4000217 	ldw	r16,8(r20)
 b000d20:	8c7fffc4 	addi	r17,r17,-1
 b000d24:	88000c16 	blt	r17,zero,b000d58 <_fwalk_reent+0x84>
 b000d28:	84000304 	addi	r16,r16,12
 b000d2c:	8080000b 	ldhu	r2,0(r16)
 b000d30:	8c7fffc4 	addi	r17,r17,-1
 b000d34:	817ffd04 	addi	r5,r16,-12
 b000d38:	b080052e 	bgeu	r22,r2,b000d50 <_fwalk_reent+0x7c>
 b000d3c:	8080008f 	ldh	r2,2(r16)
 b000d40:	9809883a 	mov	r4,r19
 b000d44:	14800226 	beq	r2,r18,b000d50 <_fwalk_reent+0x7c>
 b000d48:	a83ee83a 	callr	r21
 b000d4c:	b8aeb03a 	or	r23,r23,r2
 b000d50:	84001a04 	addi	r16,r16,104
 b000d54:	8cbff51e 	bne	r17,r18,b000d2c <__alt_mem_flash+0xfefffd2c>
 b000d58:	a5000017 	ldw	r20,0(r20)
 b000d5c:	a03fee1e 	bne	r20,zero,b000d18 <__alt_mem_flash+0xfefffd18>
 b000d60:	b805883a 	mov	r2,r23
 b000d64:	dfc00817 	ldw	ra,32(sp)
 b000d68:	ddc00717 	ldw	r23,28(sp)
 b000d6c:	dd800617 	ldw	r22,24(sp)
 b000d70:	dd400517 	ldw	r21,20(sp)
 b000d74:	dd000417 	ldw	r20,16(sp)
 b000d78:	dcc00317 	ldw	r19,12(sp)
 b000d7c:	dc800217 	ldw	r18,8(sp)
 b000d80:	dc400117 	ldw	r17,4(sp)
 b000d84:	dc000017 	ldw	r16,0(sp)
 b000d88:	dec00904 	addi	sp,sp,36
 b000d8c:	f800283a 	ret
 b000d90:	002f883a 	mov	r23,zero
 b000d94:	003ff206 	br	b000d60 <__alt_mem_flash+0xfefffd60>

0b000d98 <_malloc_r>:
 b000d98:	defff504 	addi	sp,sp,-44
 b000d9c:	dc800315 	stw	r18,12(sp)
 b000da0:	dfc00a15 	stw	ra,40(sp)
 b000da4:	df000915 	stw	fp,36(sp)
 b000da8:	ddc00815 	stw	r23,32(sp)
 b000dac:	dd800715 	stw	r22,28(sp)
 b000db0:	dd400615 	stw	r21,24(sp)
 b000db4:	dd000515 	stw	r20,20(sp)
 b000db8:	dcc00415 	stw	r19,16(sp)
 b000dbc:	dc400215 	stw	r17,8(sp)
 b000dc0:	dc000115 	stw	r16,4(sp)
 b000dc4:	288002c4 	addi	r2,r5,11
 b000dc8:	00c00584 	movi	r3,22
 b000dcc:	2025883a 	mov	r18,r4
 b000dd0:	18807f2e 	bgeu	r3,r2,b000fd0 <_malloc_r+0x238>
 b000dd4:	047ffe04 	movi	r17,-8
 b000dd8:	1462703a 	and	r17,r2,r17
 b000ddc:	8800a316 	blt	r17,zero,b00106c <_malloc_r+0x2d4>
 b000de0:	8940a236 	bltu	r17,r5,b00106c <_malloc_r+0x2d4>
 b000de4:	b0035d40 	call	b0035d4 <__malloc_lock>
 b000de8:	00807dc4 	movi	r2,503
 b000dec:	1441e92e 	bgeu	r2,r17,b001594 <_malloc_r+0x7fc>
 b000df0:	8804d27a 	srli	r2,r17,9
 b000df4:	1000a126 	beq	r2,zero,b00107c <_malloc_r+0x2e4>
 b000df8:	00c00104 	movi	r3,4
 b000dfc:	18811e36 	bltu	r3,r2,b001278 <_malloc_r+0x4e0>
 b000e00:	8804d1ba 	srli	r2,r17,6
 b000e04:	12000e44 	addi	r8,r2,57
 b000e08:	11c00e04 	addi	r7,r2,56
 b000e0c:	4209883a 	add	r4,r8,r8
 b000e10:	04c2c034 	movhi	r19,2816
 b000e14:	2109883a 	add	r4,r4,r4
 b000e18:	9cde9904 	addi	r19,r19,31332
 b000e1c:	2109883a 	add	r4,r4,r4
 b000e20:	9909883a 	add	r4,r19,r4
 b000e24:	24000117 	ldw	r16,4(r4)
 b000e28:	213ffe04 	addi	r4,r4,-8
 b000e2c:	24009726 	beq	r4,r16,b00108c <_malloc_r+0x2f4>
 b000e30:	80800117 	ldw	r2,4(r16)
 b000e34:	01bfff04 	movi	r6,-4
 b000e38:	014003c4 	movi	r5,15
 b000e3c:	1184703a 	and	r2,r2,r6
 b000e40:	1447c83a 	sub	r3,r2,r17
 b000e44:	28c00716 	blt	r5,r3,b000e64 <_malloc_r+0xcc>
 b000e48:	1800920e 	bge	r3,zero,b001094 <_malloc_r+0x2fc>
 b000e4c:	84000317 	ldw	r16,12(r16)
 b000e50:	24008e26 	beq	r4,r16,b00108c <_malloc_r+0x2f4>
 b000e54:	80800117 	ldw	r2,4(r16)
 b000e58:	1184703a 	and	r2,r2,r6
 b000e5c:	1447c83a 	sub	r3,r2,r17
 b000e60:	28fff90e 	bge	r5,r3,b000e48 <__alt_mem_flash+0xfefffe48>
 b000e64:	3809883a 	mov	r4,r7
 b000e68:	0182c034 	movhi	r6,2816
 b000e6c:	9c000417 	ldw	r16,16(r19)
 b000e70:	319e9904 	addi	r6,r6,31332
 b000e74:	32000204 	addi	r8,r6,8
 b000e78:	82013426 	beq	r16,r8,b00134c <_malloc_r+0x5b4>
 b000e7c:	80c00117 	ldw	r3,4(r16)
 b000e80:	00bfff04 	movi	r2,-4
 b000e84:	188e703a 	and	r7,r3,r2
 b000e88:	3c45c83a 	sub	r2,r7,r17
 b000e8c:	00c003c4 	movi	r3,15
 b000e90:	18811f16 	blt	r3,r2,b001310 <_malloc_r+0x578>
 b000e94:	32000515 	stw	r8,20(r6)
 b000e98:	32000415 	stw	r8,16(r6)
 b000e9c:	10007f0e 	bge	r2,zero,b00109c <_malloc_r+0x304>
 b000ea0:	00807fc4 	movi	r2,511
 b000ea4:	11c0fd36 	bltu	r2,r7,b00129c <_malloc_r+0x504>
 b000ea8:	3806d0fa 	srli	r3,r7,3
 b000eac:	01c00044 	movi	r7,1
 b000eb0:	30800117 	ldw	r2,4(r6)
 b000eb4:	19400044 	addi	r5,r3,1
 b000eb8:	294b883a 	add	r5,r5,r5
 b000ebc:	1807d0ba 	srai	r3,r3,2
 b000ec0:	294b883a 	add	r5,r5,r5
 b000ec4:	294b883a 	add	r5,r5,r5
 b000ec8:	298b883a 	add	r5,r5,r6
 b000ecc:	38c6983a 	sll	r3,r7,r3
 b000ed0:	29c00017 	ldw	r7,0(r5)
 b000ed4:	2a7ffe04 	addi	r9,r5,-8
 b000ed8:	1886b03a 	or	r3,r3,r2
 b000edc:	82400315 	stw	r9,12(r16)
 b000ee0:	81c00215 	stw	r7,8(r16)
 b000ee4:	30c00115 	stw	r3,4(r6)
 b000ee8:	2c000015 	stw	r16,0(r5)
 b000eec:	3c000315 	stw	r16,12(r7)
 b000ef0:	2005d0ba 	srai	r2,r4,2
 b000ef4:	01400044 	movi	r5,1
 b000ef8:	288a983a 	sll	r5,r5,r2
 b000efc:	19406f36 	bltu	r3,r5,b0010bc <_malloc_r+0x324>
 b000f00:	28c4703a 	and	r2,r5,r3
 b000f04:	10000a1e 	bne	r2,zero,b000f30 <_malloc_r+0x198>
 b000f08:	00bfff04 	movi	r2,-4
 b000f0c:	294b883a 	add	r5,r5,r5
 b000f10:	2088703a 	and	r4,r4,r2
 b000f14:	28c4703a 	and	r2,r5,r3
 b000f18:	21000104 	addi	r4,r4,4
 b000f1c:	1000041e 	bne	r2,zero,b000f30 <_malloc_r+0x198>
 b000f20:	294b883a 	add	r5,r5,r5
 b000f24:	28c4703a 	and	r2,r5,r3
 b000f28:	21000104 	addi	r4,r4,4
 b000f2c:	103ffc26 	beq	r2,zero,b000f20 <__alt_mem_flash+0xfeffff20>
 b000f30:	02bfff04 	movi	r10,-4
 b000f34:	024003c4 	movi	r9,15
 b000f38:	21800044 	addi	r6,r4,1
 b000f3c:	318d883a 	add	r6,r6,r6
 b000f40:	318d883a 	add	r6,r6,r6
 b000f44:	318d883a 	add	r6,r6,r6
 b000f48:	998d883a 	add	r6,r19,r6
 b000f4c:	333ffe04 	addi	r12,r6,-8
 b000f50:	2017883a 	mov	r11,r4
 b000f54:	31800104 	addi	r6,r6,4
 b000f58:	34000017 	ldw	r16,0(r6)
 b000f5c:	31fffd04 	addi	r7,r6,-12
 b000f60:	81c0041e 	bne	r16,r7,b000f74 <_malloc_r+0x1dc>
 b000f64:	0000fb06 	br	b001354 <_malloc_r+0x5bc>
 b000f68:	1801030e 	bge	r3,zero,b001378 <_malloc_r+0x5e0>
 b000f6c:	84000317 	ldw	r16,12(r16)
 b000f70:	81c0f826 	beq	r16,r7,b001354 <_malloc_r+0x5bc>
 b000f74:	80800117 	ldw	r2,4(r16)
 b000f78:	1284703a 	and	r2,r2,r10
 b000f7c:	1447c83a 	sub	r3,r2,r17
 b000f80:	48fff90e 	bge	r9,r3,b000f68 <__alt_mem_flash+0xfeffff68>
 b000f84:	80800317 	ldw	r2,12(r16)
 b000f88:	81000217 	ldw	r4,8(r16)
 b000f8c:	89400054 	ori	r5,r17,1
 b000f90:	81400115 	stw	r5,4(r16)
 b000f94:	20800315 	stw	r2,12(r4)
 b000f98:	11000215 	stw	r4,8(r2)
 b000f9c:	8463883a 	add	r17,r16,r17
 b000fa0:	9c400515 	stw	r17,20(r19)
 b000fa4:	9c400415 	stw	r17,16(r19)
 b000fa8:	18800054 	ori	r2,r3,1
 b000fac:	88800115 	stw	r2,4(r17)
 b000fb0:	8a000315 	stw	r8,12(r17)
 b000fb4:	8a000215 	stw	r8,8(r17)
 b000fb8:	88e3883a 	add	r17,r17,r3
 b000fbc:	88c00015 	stw	r3,0(r17)
 b000fc0:	9009883a 	mov	r4,r18
 b000fc4:	b0035f80 	call	b0035f8 <__malloc_unlock>
 b000fc8:	80800204 	addi	r2,r16,8
 b000fcc:	00001b06 	br	b00103c <_malloc_r+0x2a4>
 b000fd0:	04400404 	movi	r17,16
 b000fd4:	89402536 	bltu	r17,r5,b00106c <_malloc_r+0x2d4>
 b000fd8:	b0035d40 	call	b0035d4 <__malloc_lock>
 b000fdc:	00800184 	movi	r2,6
 b000fe0:	01000084 	movi	r4,2
 b000fe4:	04c2c034 	movhi	r19,2816
 b000fe8:	1085883a 	add	r2,r2,r2
 b000fec:	9cde9904 	addi	r19,r19,31332
 b000ff0:	1085883a 	add	r2,r2,r2
 b000ff4:	9885883a 	add	r2,r19,r2
 b000ff8:	14000117 	ldw	r16,4(r2)
 b000ffc:	10fffe04 	addi	r3,r2,-8
 b001000:	80c0d926 	beq	r16,r3,b001368 <_malloc_r+0x5d0>
 b001004:	80c00117 	ldw	r3,4(r16)
 b001008:	81000317 	ldw	r4,12(r16)
 b00100c:	00bfff04 	movi	r2,-4
 b001010:	1884703a 	and	r2,r3,r2
 b001014:	81400217 	ldw	r5,8(r16)
 b001018:	8085883a 	add	r2,r16,r2
 b00101c:	10c00117 	ldw	r3,4(r2)
 b001020:	29000315 	stw	r4,12(r5)
 b001024:	21400215 	stw	r5,8(r4)
 b001028:	18c00054 	ori	r3,r3,1
 b00102c:	10c00115 	stw	r3,4(r2)
 b001030:	9009883a 	mov	r4,r18
 b001034:	b0035f80 	call	b0035f8 <__malloc_unlock>
 b001038:	80800204 	addi	r2,r16,8
 b00103c:	dfc00a17 	ldw	ra,40(sp)
 b001040:	df000917 	ldw	fp,36(sp)
 b001044:	ddc00817 	ldw	r23,32(sp)
 b001048:	dd800717 	ldw	r22,28(sp)
 b00104c:	dd400617 	ldw	r21,24(sp)
 b001050:	dd000517 	ldw	r20,20(sp)
 b001054:	dcc00417 	ldw	r19,16(sp)
 b001058:	dc800317 	ldw	r18,12(sp)
 b00105c:	dc400217 	ldw	r17,8(sp)
 b001060:	dc000117 	ldw	r16,4(sp)
 b001064:	dec00b04 	addi	sp,sp,44
 b001068:	f800283a 	ret
 b00106c:	00800304 	movi	r2,12
 b001070:	90800015 	stw	r2,0(r18)
 b001074:	0005883a 	mov	r2,zero
 b001078:	003ff006 	br	b00103c <__alt_mem_flash+0xff00003c>
 b00107c:	01002004 	movi	r4,128
 b001080:	02001004 	movi	r8,64
 b001084:	01c00fc4 	movi	r7,63
 b001088:	003f6106 	br	b000e10 <__alt_mem_flash+0xfefffe10>
 b00108c:	4009883a 	mov	r4,r8
 b001090:	003f7506 	br	b000e68 <__alt_mem_flash+0xfefffe68>
 b001094:	81000317 	ldw	r4,12(r16)
 b001098:	003fde06 	br	b001014 <__alt_mem_flash+0xff000014>
 b00109c:	81c5883a 	add	r2,r16,r7
 b0010a0:	11400117 	ldw	r5,4(r2)
 b0010a4:	9009883a 	mov	r4,r18
 b0010a8:	29400054 	ori	r5,r5,1
 b0010ac:	11400115 	stw	r5,4(r2)
 b0010b0:	b0035f80 	call	b0035f8 <__malloc_unlock>
 b0010b4:	80800204 	addi	r2,r16,8
 b0010b8:	003fe006 	br	b00103c <__alt_mem_flash+0xff00003c>
 b0010bc:	9c000217 	ldw	r16,8(r19)
 b0010c0:	00bfff04 	movi	r2,-4
 b0010c4:	85800117 	ldw	r22,4(r16)
 b0010c8:	b0ac703a 	and	r22,r22,r2
 b0010cc:	b4400336 	bltu	r22,r17,b0010dc <_malloc_r+0x344>
 b0010d0:	b445c83a 	sub	r2,r22,r17
 b0010d4:	00c003c4 	movi	r3,15
 b0010d8:	18805d16 	blt	r3,r2,b001250 <_malloc_r+0x4b8>
 b0010dc:	05c2c074 	movhi	r23,2817
 b0010e0:	0082c074 	movhi	r2,2817
 b0010e4:	10abaa04 	addi	r2,r2,-20824
 b0010e8:	bde48e04 	addi	r23,r23,-28104
 b0010ec:	15400017 	ldw	r21,0(r2)
 b0010f0:	b8c00017 	ldw	r3,0(r23)
 b0010f4:	00bfffc4 	movi	r2,-1
 b0010f8:	858d883a 	add	r6,r16,r22
 b0010fc:	8d6b883a 	add	r21,r17,r21
 b001100:	1880ea26 	beq	r3,r2,b0014ac <_malloc_r+0x714>
 b001104:	ad4403c4 	addi	r21,r21,4111
 b001108:	00bc0004 	movi	r2,-4096
 b00110c:	a8aa703a 	and	r21,r21,r2
 b001110:	a80b883a 	mov	r5,r21
 b001114:	9009883a 	mov	r4,r18
 b001118:	d9800015 	stw	r6,0(sp)
 b00111c:	b001fb80 	call	b001fb8 <_sbrk_r>
 b001120:	1029883a 	mov	r20,r2
 b001124:	00bfffc4 	movi	r2,-1
 b001128:	d9800017 	ldw	r6,0(sp)
 b00112c:	a080e826 	beq	r20,r2,b0014d0 <_malloc_r+0x738>
 b001130:	a180a636 	bltu	r20,r6,b0013cc <_malloc_r+0x634>
 b001134:	0702c074 	movhi	fp,2817
 b001138:	e72bb304 	addi	fp,fp,-20788
 b00113c:	e0800017 	ldw	r2,0(fp)
 b001140:	a887883a 	add	r3,r21,r2
 b001144:	e0c00015 	stw	r3,0(fp)
 b001148:	3500e626 	beq	r6,r20,b0014e4 <_malloc_r+0x74c>
 b00114c:	b9000017 	ldw	r4,0(r23)
 b001150:	00bfffc4 	movi	r2,-1
 b001154:	2080ee26 	beq	r4,r2,b001510 <_malloc_r+0x778>
 b001158:	a185c83a 	sub	r2,r20,r6
 b00115c:	10c5883a 	add	r2,r2,r3
 b001160:	e0800015 	stw	r2,0(fp)
 b001164:	a0c001cc 	andi	r3,r20,7
 b001168:	1800bc26 	beq	r3,zero,b00145c <_malloc_r+0x6c4>
 b00116c:	a0e9c83a 	sub	r20,r20,r3
 b001170:	00840204 	movi	r2,4104
 b001174:	a5000204 	addi	r20,r20,8
 b001178:	10c7c83a 	sub	r3,r2,r3
 b00117c:	a545883a 	add	r2,r20,r21
 b001180:	1083ffcc 	andi	r2,r2,4095
 b001184:	18abc83a 	sub	r21,r3,r2
 b001188:	a80b883a 	mov	r5,r21
 b00118c:	9009883a 	mov	r4,r18
 b001190:	b001fb80 	call	b001fb8 <_sbrk_r>
 b001194:	00ffffc4 	movi	r3,-1
 b001198:	10c0e126 	beq	r2,r3,b001520 <_malloc_r+0x788>
 b00119c:	1505c83a 	sub	r2,r2,r20
 b0011a0:	1545883a 	add	r2,r2,r21
 b0011a4:	10800054 	ori	r2,r2,1
 b0011a8:	e0c00017 	ldw	r3,0(fp)
 b0011ac:	9d000215 	stw	r20,8(r19)
 b0011b0:	a0800115 	stw	r2,4(r20)
 b0011b4:	a8c7883a 	add	r3,r21,r3
 b0011b8:	e0c00015 	stw	r3,0(fp)
 b0011bc:	84c00e26 	beq	r16,r19,b0011f8 <_malloc_r+0x460>
 b0011c0:	018003c4 	movi	r6,15
 b0011c4:	3580a72e 	bgeu	r6,r22,b001464 <_malloc_r+0x6cc>
 b0011c8:	81400117 	ldw	r5,4(r16)
 b0011cc:	013ffe04 	movi	r4,-8
 b0011d0:	b0bffd04 	addi	r2,r22,-12
 b0011d4:	1104703a 	and	r2,r2,r4
 b0011d8:	2900004c 	andi	r4,r5,1
 b0011dc:	2088b03a 	or	r4,r4,r2
 b0011e0:	81000115 	stw	r4,4(r16)
 b0011e4:	01400144 	movi	r5,5
 b0011e8:	8089883a 	add	r4,r16,r2
 b0011ec:	21400115 	stw	r5,4(r4)
 b0011f0:	21400215 	stw	r5,8(r4)
 b0011f4:	3080cd36 	bltu	r6,r2,b00152c <_malloc_r+0x794>
 b0011f8:	0082c074 	movhi	r2,2817
 b0011fc:	10aba904 	addi	r2,r2,-20828
 b001200:	11000017 	ldw	r4,0(r2)
 b001204:	20c0012e 	bgeu	r4,r3,b00120c <_malloc_r+0x474>
 b001208:	10c00015 	stw	r3,0(r2)
 b00120c:	0082c074 	movhi	r2,2817
 b001210:	10aba804 	addi	r2,r2,-20832
 b001214:	11000017 	ldw	r4,0(r2)
 b001218:	9c000217 	ldw	r16,8(r19)
 b00121c:	20c0012e 	bgeu	r4,r3,b001224 <_malloc_r+0x48c>
 b001220:	10c00015 	stw	r3,0(r2)
 b001224:	80c00117 	ldw	r3,4(r16)
 b001228:	00bfff04 	movi	r2,-4
 b00122c:	1886703a 	and	r3,r3,r2
 b001230:	1c45c83a 	sub	r2,r3,r17
 b001234:	1c400236 	bltu	r3,r17,b001240 <_malloc_r+0x4a8>
 b001238:	00c003c4 	movi	r3,15
 b00123c:	18800416 	blt	r3,r2,b001250 <_malloc_r+0x4b8>
 b001240:	9009883a 	mov	r4,r18
 b001244:	b0035f80 	call	b0035f8 <__malloc_unlock>
 b001248:	0005883a 	mov	r2,zero
 b00124c:	003f7b06 	br	b00103c <__alt_mem_flash+0xff00003c>
 b001250:	88c00054 	ori	r3,r17,1
 b001254:	80c00115 	stw	r3,4(r16)
 b001258:	8463883a 	add	r17,r16,r17
 b00125c:	10800054 	ori	r2,r2,1
 b001260:	9c400215 	stw	r17,8(r19)
 b001264:	88800115 	stw	r2,4(r17)
 b001268:	9009883a 	mov	r4,r18
 b00126c:	b0035f80 	call	b0035f8 <__malloc_unlock>
 b001270:	80800204 	addi	r2,r16,8
 b001274:	003f7106 	br	b00103c <__alt_mem_flash+0xff00003c>
 b001278:	00c00504 	movi	r3,20
 b00127c:	18804a2e 	bgeu	r3,r2,b0013a8 <_malloc_r+0x610>
 b001280:	00c01504 	movi	r3,84
 b001284:	18806e36 	bltu	r3,r2,b001440 <_malloc_r+0x6a8>
 b001288:	8804d33a 	srli	r2,r17,12
 b00128c:	12001bc4 	addi	r8,r2,111
 b001290:	11c01b84 	addi	r7,r2,110
 b001294:	4209883a 	add	r4,r8,r8
 b001298:	003edd06 	br	b000e10 <__alt_mem_flash+0xfefffe10>
 b00129c:	3804d27a 	srli	r2,r7,9
 b0012a0:	00c00104 	movi	r3,4
 b0012a4:	1880442e 	bgeu	r3,r2,b0013b8 <_malloc_r+0x620>
 b0012a8:	00c00504 	movi	r3,20
 b0012ac:	18808136 	bltu	r3,r2,b0014b4 <_malloc_r+0x71c>
 b0012b0:	11401704 	addi	r5,r2,92
 b0012b4:	10c016c4 	addi	r3,r2,91
 b0012b8:	294b883a 	add	r5,r5,r5
 b0012bc:	294b883a 	add	r5,r5,r5
 b0012c0:	294b883a 	add	r5,r5,r5
 b0012c4:	994b883a 	add	r5,r19,r5
 b0012c8:	28800017 	ldw	r2,0(r5)
 b0012cc:	0182c034 	movhi	r6,2816
 b0012d0:	297ffe04 	addi	r5,r5,-8
 b0012d4:	319e9904 	addi	r6,r6,31332
 b0012d8:	28806526 	beq	r5,r2,b001470 <_malloc_r+0x6d8>
 b0012dc:	01bfff04 	movi	r6,-4
 b0012e0:	10c00117 	ldw	r3,4(r2)
 b0012e4:	1986703a 	and	r3,r3,r6
 b0012e8:	38c0022e 	bgeu	r7,r3,b0012f4 <_malloc_r+0x55c>
 b0012ec:	10800217 	ldw	r2,8(r2)
 b0012f0:	28bffb1e 	bne	r5,r2,b0012e0 <__alt_mem_flash+0xff0002e0>
 b0012f4:	11400317 	ldw	r5,12(r2)
 b0012f8:	98c00117 	ldw	r3,4(r19)
 b0012fc:	81400315 	stw	r5,12(r16)
 b001300:	80800215 	stw	r2,8(r16)
 b001304:	2c000215 	stw	r16,8(r5)
 b001308:	14000315 	stw	r16,12(r2)
 b00130c:	003ef806 	br	b000ef0 <__alt_mem_flash+0xfefffef0>
 b001310:	88c00054 	ori	r3,r17,1
 b001314:	80c00115 	stw	r3,4(r16)
 b001318:	8463883a 	add	r17,r16,r17
 b00131c:	34400515 	stw	r17,20(r6)
 b001320:	34400415 	stw	r17,16(r6)
 b001324:	10c00054 	ori	r3,r2,1
 b001328:	8a000315 	stw	r8,12(r17)
 b00132c:	8a000215 	stw	r8,8(r17)
 b001330:	88c00115 	stw	r3,4(r17)
 b001334:	88a3883a 	add	r17,r17,r2
 b001338:	88800015 	stw	r2,0(r17)
 b00133c:	9009883a 	mov	r4,r18
 b001340:	b0035f80 	call	b0035f8 <__malloc_unlock>
 b001344:	80800204 	addi	r2,r16,8
 b001348:	003f3c06 	br	b00103c <__alt_mem_flash+0xff00003c>
 b00134c:	30c00117 	ldw	r3,4(r6)
 b001350:	003ee706 	br	b000ef0 <__alt_mem_flash+0xfefffef0>
 b001354:	5ac00044 	addi	r11,r11,1
 b001358:	588000cc 	andi	r2,r11,3
 b00135c:	31800204 	addi	r6,r6,8
 b001360:	103efd1e 	bne	r2,zero,b000f58 <__alt_mem_flash+0xfeffff58>
 b001364:	00002406 	br	b0013f8 <_malloc_r+0x660>
 b001368:	14000317 	ldw	r16,12(r2)
 b00136c:	143f251e 	bne	r2,r16,b001004 <__alt_mem_flash+0xff000004>
 b001370:	21000084 	addi	r4,r4,2
 b001374:	003ebc06 	br	b000e68 <__alt_mem_flash+0xfefffe68>
 b001378:	8085883a 	add	r2,r16,r2
 b00137c:	10c00117 	ldw	r3,4(r2)
 b001380:	81000317 	ldw	r4,12(r16)
 b001384:	81400217 	ldw	r5,8(r16)
 b001388:	18c00054 	ori	r3,r3,1
 b00138c:	10c00115 	stw	r3,4(r2)
 b001390:	29000315 	stw	r4,12(r5)
 b001394:	21400215 	stw	r5,8(r4)
 b001398:	9009883a 	mov	r4,r18
 b00139c:	b0035f80 	call	b0035f8 <__malloc_unlock>
 b0013a0:	80800204 	addi	r2,r16,8
 b0013a4:	003f2506 	br	b00103c <__alt_mem_flash+0xff00003c>
 b0013a8:	12001704 	addi	r8,r2,92
 b0013ac:	11c016c4 	addi	r7,r2,91
 b0013b0:	4209883a 	add	r4,r8,r8
 b0013b4:	003e9606 	br	b000e10 <__alt_mem_flash+0xfefffe10>
 b0013b8:	3804d1ba 	srli	r2,r7,6
 b0013bc:	11400e44 	addi	r5,r2,57
 b0013c0:	10c00e04 	addi	r3,r2,56
 b0013c4:	294b883a 	add	r5,r5,r5
 b0013c8:	003fbc06 	br	b0012bc <__alt_mem_flash+0xff0002bc>
 b0013cc:	84ff5926 	beq	r16,r19,b001134 <__alt_mem_flash+0xff000134>
 b0013d0:	0082c034 	movhi	r2,2816
 b0013d4:	109e9904 	addi	r2,r2,31332
 b0013d8:	14000217 	ldw	r16,8(r2)
 b0013dc:	00bfff04 	movi	r2,-4
 b0013e0:	80c00117 	ldw	r3,4(r16)
 b0013e4:	1886703a 	and	r3,r3,r2
 b0013e8:	003f9106 	br	b001230 <__alt_mem_flash+0xff000230>
 b0013ec:	60800217 	ldw	r2,8(r12)
 b0013f0:	213fffc4 	addi	r4,r4,-1
 b0013f4:	1300651e 	bne	r2,r12,b00158c <_malloc_r+0x7f4>
 b0013f8:	208000cc 	andi	r2,r4,3
 b0013fc:	633ffe04 	addi	r12,r12,-8
 b001400:	103ffa1e 	bne	r2,zero,b0013ec <__alt_mem_flash+0xff0003ec>
 b001404:	98800117 	ldw	r2,4(r19)
 b001408:	0146303a 	nor	r3,zero,r5
 b00140c:	1884703a 	and	r2,r3,r2
 b001410:	98800115 	stw	r2,4(r19)
 b001414:	294b883a 	add	r5,r5,r5
 b001418:	117f2836 	bltu	r2,r5,b0010bc <__alt_mem_flash+0xff0000bc>
 b00141c:	283f2726 	beq	r5,zero,b0010bc <__alt_mem_flash+0xff0000bc>
 b001420:	2886703a 	and	r3,r5,r2
 b001424:	5809883a 	mov	r4,r11
 b001428:	183ec31e 	bne	r3,zero,b000f38 <__alt_mem_flash+0xfeffff38>
 b00142c:	294b883a 	add	r5,r5,r5
 b001430:	2886703a 	and	r3,r5,r2
 b001434:	21000104 	addi	r4,r4,4
 b001438:	183ffc26 	beq	r3,zero,b00142c <__alt_mem_flash+0xff00042c>
 b00143c:	003ebe06 	br	b000f38 <__alt_mem_flash+0xfeffff38>
 b001440:	00c05504 	movi	r3,340
 b001444:	18801236 	bltu	r3,r2,b001490 <_malloc_r+0x6f8>
 b001448:	8804d3fa 	srli	r2,r17,15
 b00144c:	12001e04 	addi	r8,r2,120
 b001450:	11c01dc4 	addi	r7,r2,119
 b001454:	4209883a 	add	r4,r8,r8
 b001458:	003e6d06 	br	b000e10 <__alt_mem_flash+0xfefffe10>
 b00145c:	00c40004 	movi	r3,4096
 b001460:	003f4606 	br	b00117c <__alt_mem_flash+0xff00017c>
 b001464:	00800044 	movi	r2,1
 b001468:	a0800115 	stw	r2,4(r20)
 b00146c:	003f7406 	br	b001240 <__alt_mem_flash+0xff000240>
 b001470:	1805d0ba 	srai	r2,r3,2
 b001474:	01c00044 	movi	r7,1
 b001478:	30c00117 	ldw	r3,4(r6)
 b00147c:	388e983a 	sll	r7,r7,r2
 b001480:	2805883a 	mov	r2,r5
 b001484:	38c6b03a 	or	r3,r7,r3
 b001488:	30c00115 	stw	r3,4(r6)
 b00148c:	003f9b06 	br	b0012fc <__alt_mem_flash+0xff0002fc>
 b001490:	00c15504 	movi	r3,1364
 b001494:	18801a36 	bltu	r3,r2,b001500 <_malloc_r+0x768>
 b001498:	8804d4ba 	srli	r2,r17,18
 b00149c:	12001f44 	addi	r8,r2,125
 b0014a0:	11c01f04 	addi	r7,r2,124
 b0014a4:	4209883a 	add	r4,r8,r8
 b0014a8:	003e5906 	br	b000e10 <__alt_mem_flash+0xfefffe10>
 b0014ac:	ad400404 	addi	r21,r21,16
 b0014b0:	003f1706 	br	b001110 <__alt_mem_flash+0xff000110>
 b0014b4:	00c01504 	movi	r3,84
 b0014b8:	18802336 	bltu	r3,r2,b001548 <_malloc_r+0x7b0>
 b0014bc:	3804d33a 	srli	r2,r7,12
 b0014c0:	11401bc4 	addi	r5,r2,111
 b0014c4:	10c01b84 	addi	r3,r2,110
 b0014c8:	294b883a 	add	r5,r5,r5
 b0014cc:	003f7b06 	br	b0012bc <__alt_mem_flash+0xff0002bc>
 b0014d0:	9c000217 	ldw	r16,8(r19)
 b0014d4:	00bfff04 	movi	r2,-4
 b0014d8:	80c00117 	ldw	r3,4(r16)
 b0014dc:	1886703a 	and	r3,r3,r2
 b0014e0:	003f5306 	br	b001230 <__alt_mem_flash+0xff000230>
 b0014e4:	3083ffcc 	andi	r2,r6,4095
 b0014e8:	103f181e 	bne	r2,zero,b00114c <__alt_mem_flash+0xff00014c>
 b0014ec:	99000217 	ldw	r4,8(r19)
 b0014f0:	b545883a 	add	r2,r22,r21
 b0014f4:	10800054 	ori	r2,r2,1
 b0014f8:	20800115 	stw	r2,4(r4)
 b0014fc:	003f3e06 	br	b0011f8 <__alt_mem_flash+0xff0001f8>
 b001500:	01003f84 	movi	r4,254
 b001504:	02001fc4 	movi	r8,127
 b001508:	01c01f84 	movi	r7,126
 b00150c:	003e4006 	br	b000e10 <__alt_mem_flash+0xfefffe10>
 b001510:	0082c074 	movhi	r2,2817
 b001514:	10a48e04 	addi	r2,r2,-28104
 b001518:	15000015 	stw	r20,0(r2)
 b00151c:	003f1106 	br	b001164 <__alt_mem_flash+0xff000164>
 b001520:	00800044 	movi	r2,1
 b001524:	002b883a 	mov	r21,zero
 b001528:	003f1f06 	br	b0011a8 <__alt_mem_flash+0xff0001a8>
 b00152c:	81400204 	addi	r5,r16,8
 b001530:	9009883a 	mov	r4,r18
 b001534:	b0028200 	call	b002820 <_free_r>
 b001538:	0082c074 	movhi	r2,2817
 b00153c:	10abb304 	addi	r2,r2,-20788
 b001540:	10c00017 	ldw	r3,0(r2)
 b001544:	003f2c06 	br	b0011f8 <__alt_mem_flash+0xff0001f8>
 b001548:	00c05504 	movi	r3,340
 b00154c:	18800536 	bltu	r3,r2,b001564 <_malloc_r+0x7cc>
 b001550:	3804d3fa 	srli	r2,r7,15
 b001554:	11401e04 	addi	r5,r2,120
 b001558:	10c01dc4 	addi	r3,r2,119
 b00155c:	294b883a 	add	r5,r5,r5
 b001560:	003f5606 	br	b0012bc <__alt_mem_flash+0xff0002bc>
 b001564:	00c15504 	movi	r3,1364
 b001568:	18800536 	bltu	r3,r2,b001580 <_malloc_r+0x7e8>
 b00156c:	3804d4ba 	srli	r2,r7,18
 b001570:	11401f44 	addi	r5,r2,125
 b001574:	10c01f04 	addi	r3,r2,124
 b001578:	294b883a 	add	r5,r5,r5
 b00157c:	003f4f06 	br	b0012bc <__alt_mem_flash+0xff0002bc>
 b001580:	01403f84 	movi	r5,254
 b001584:	00c01f84 	movi	r3,126
 b001588:	003f4c06 	br	b0012bc <__alt_mem_flash+0xff0002bc>
 b00158c:	98800117 	ldw	r2,4(r19)
 b001590:	003fa006 	br	b001414 <__alt_mem_flash+0xff000414>
 b001594:	8808d0fa 	srli	r4,r17,3
 b001598:	20800044 	addi	r2,r4,1
 b00159c:	1085883a 	add	r2,r2,r2
 b0015a0:	003e9006 	br	b000fe4 <__alt_mem_flash+0xfeffffe4>

0b0015a4 <memchr>:
 b0015a4:	208000cc 	andi	r2,r4,3
 b0015a8:	280f883a 	mov	r7,r5
 b0015ac:	10003426 	beq	r2,zero,b001680 <memchr+0xdc>
 b0015b0:	30bfffc4 	addi	r2,r6,-1
 b0015b4:	30001a26 	beq	r6,zero,b001620 <memchr+0x7c>
 b0015b8:	20c00003 	ldbu	r3,0(r4)
 b0015bc:	29803fcc 	andi	r6,r5,255
 b0015c0:	30c0051e 	bne	r6,r3,b0015d8 <memchr+0x34>
 b0015c4:	00001806 	br	b001628 <memchr+0x84>
 b0015c8:	10001526 	beq	r2,zero,b001620 <memchr+0x7c>
 b0015cc:	20c00003 	ldbu	r3,0(r4)
 b0015d0:	10bfffc4 	addi	r2,r2,-1
 b0015d4:	30c01426 	beq	r6,r3,b001628 <memchr+0x84>
 b0015d8:	21000044 	addi	r4,r4,1
 b0015dc:	20c000cc 	andi	r3,r4,3
 b0015e0:	183ff91e 	bne	r3,zero,b0015c8 <__alt_mem_flash+0xff0005c8>
 b0015e4:	020000c4 	movi	r8,3
 b0015e8:	40801136 	bltu	r8,r2,b001630 <memchr+0x8c>
 b0015ec:	10000c26 	beq	r2,zero,b001620 <memchr+0x7c>
 b0015f0:	20c00003 	ldbu	r3,0(r4)
 b0015f4:	29403fcc 	andi	r5,r5,255
 b0015f8:	28c00b26 	beq	r5,r3,b001628 <memchr+0x84>
 b0015fc:	20c00044 	addi	r3,r4,1
 b001600:	39803fcc 	andi	r6,r7,255
 b001604:	2089883a 	add	r4,r4,r2
 b001608:	00000306 	br	b001618 <memchr+0x74>
 b00160c:	18c00044 	addi	r3,r3,1
 b001610:	197fffc3 	ldbu	r5,-1(r3)
 b001614:	31400526 	beq	r6,r5,b00162c <memchr+0x88>
 b001618:	1805883a 	mov	r2,r3
 b00161c:	20fffb1e 	bne	r4,r3,b00160c <__alt_mem_flash+0xff00060c>
 b001620:	0005883a 	mov	r2,zero
 b001624:	f800283a 	ret
 b001628:	2005883a 	mov	r2,r4
 b00162c:	f800283a 	ret
 b001630:	28c03fcc 	andi	r3,r5,255
 b001634:	1812923a 	slli	r9,r3,8
 b001638:	02ffbff4 	movhi	r11,65279
 b00163c:	02a02074 	movhi	r10,32897
 b001640:	48d2b03a 	or	r9,r9,r3
 b001644:	4806943a 	slli	r3,r9,16
 b001648:	5affbfc4 	addi	r11,r11,-257
 b00164c:	52a02004 	addi	r10,r10,-32640
 b001650:	48d2b03a 	or	r9,r9,r3
 b001654:	20c00017 	ldw	r3,0(r4)
 b001658:	48c6f03a 	xor	r3,r9,r3
 b00165c:	1acd883a 	add	r6,r3,r11
 b001660:	00c6303a 	nor	r3,zero,r3
 b001664:	30c6703a 	and	r3,r6,r3
 b001668:	1a86703a 	and	r3,r3,r10
 b00166c:	183fe01e 	bne	r3,zero,b0015f0 <__alt_mem_flash+0xff0005f0>
 b001670:	10bfff04 	addi	r2,r2,-4
 b001674:	21000104 	addi	r4,r4,4
 b001678:	40bff636 	bltu	r8,r2,b001654 <__alt_mem_flash+0xff000654>
 b00167c:	003fdb06 	br	b0015ec <__alt_mem_flash+0xff0005ec>
 b001680:	3005883a 	mov	r2,r6
 b001684:	003fd706 	br	b0015e4 <__alt_mem_flash+0xff0005e4>

0b001688 <memcpy>:
 b001688:	defffd04 	addi	sp,sp,-12
 b00168c:	dfc00215 	stw	ra,8(sp)
 b001690:	dc400115 	stw	r17,4(sp)
 b001694:	dc000015 	stw	r16,0(sp)
 b001698:	00c003c4 	movi	r3,15
 b00169c:	2005883a 	mov	r2,r4
 b0016a0:	1980452e 	bgeu	r3,r6,b0017b8 <memcpy+0x130>
 b0016a4:	2906b03a 	or	r3,r5,r4
 b0016a8:	18c000cc 	andi	r3,r3,3
 b0016ac:	1800441e 	bne	r3,zero,b0017c0 <memcpy+0x138>
 b0016b0:	347ffc04 	addi	r17,r6,-16
 b0016b4:	8822d13a 	srli	r17,r17,4
 b0016b8:	28c00104 	addi	r3,r5,4
 b0016bc:	23400104 	addi	r13,r4,4
 b0016c0:	8820913a 	slli	r16,r17,4
 b0016c4:	2b000204 	addi	r12,r5,8
 b0016c8:	22c00204 	addi	r11,r4,8
 b0016cc:	84000504 	addi	r16,r16,20
 b0016d0:	2a800304 	addi	r10,r5,12
 b0016d4:	22400304 	addi	r9,r4,12
 b0016d8:	2c21883a 	add	r16,r5,r16
 b0016dc:	2811883a 	mov	r8,r5
 b0016e0:	200f883a 	mov	r7,r4
 b0016e4:	41000017 	ldw	r4,0(r8)
 b0016e8:	1fc00017 	ldw	ra,0(r3)
 b0016ec:	63c00017 	ldw	r15,0(r12)
 b0016f0:	39000015 	stw	r4,0(r7)
 b0016f4:	53800017 	ldw	r14,0(r10)
 b0016f8:	6fc00015 	stw	ra,0(r13)
 b0016fc:	5bc00015 	stw	r15,0(r11)
 b001700:	4b800015 	stw	r14,0(r9)
 b001704:	18c00404 	addi	r3,r3,16
 b001708:	39c00404 	addi	r7,r7,16
 b00170c:	42000404 	addi	r8,r8,16
 b001710:	6b400404 	addi	r13,r13,16
 b001714:	63000404 	addi	r12,r12,16
 b001718:	5ac00404 	addi	r11,r11,16
 b00171c:	52800404 	addi	r10,r10,16
 b001720:	4a400404 	addi	r9,r9,16
 b001724:	1c3fef1e 	bne	r3,r16,b0016e4 <__alt_mem_flash+0xff0006e4>
 b001728:	89c00044 	addi	r7,r17,1
 b00172c:	380e913a 	slli	r7,r7,4
 b001730:	310003cc 	andi	r4,r6,15
 b001734:	02c000c4 	movi	r11,3
 b001738:	11c7883a 	add	r3,r2,r7
 b00173c:	29cb883a 	add	r5,r5,r7
 b001740:	5900212e 	bgeu	r11,r4,b0017c8 <memcpy+0x140>
 b001744:	1813883a 	mov	r9,r3
 b001748:	2811883a 	mov	r8,r5
 b00174c:	200f883a 	mov	r7,r4
 b001750:	42800017 	ldw	r10,0(r8)
 b001754:	4a400104 	addi	r9,r9,4
 b001758:	39ffff04 	addi	r7,r7,-4
 b00175c:	4abfff15 	stw	r10,-4(r9)
 b001760:	42000104 	addi	r8,r8,4
 b001764:	59fffa36 	bltu	r11,r7,b001750 <__alt_mem_flash+0xff000750>
 b001768:	213fff04 	addi	r4,r4,-4
 b00176c:	2008d0ba 	srli	r4,r4,2
 b001770:	318000cc 	andi	r6,r6,3
 b001774:	21000044 	addi	r4,r4,1
 b001778:	2109883a 	add	r4,r4,r4
 b00177c:	2109883a 	add	r4,r4,r4
 b001780:	1907883a 	add	r3,r3,r4
 b001784:	290b883a 	add	r5,r5,r4
 b001788:	30000626 	beq	r6,zero,b0017a4 <memcpy+0x11c>
 b00178c:	198d883a 	add	r6,r3,r6
 b001790:	29c00003 	ldbu	r7,0(r5)
 b001794:	18c00044 	addi	r3,r3,1
 b001798:	29400044 	addi	r5,r5,1
 b00179c:	19ffffc5 	stb	r7,-1(r3)
 b0017a0:	19bffb1e 	bne	r3,r6,b001790 <__alt_mem_flash+0xff000790>
 b0017a4:	dfc00217 	ldw	ra,8(sp)
 b0017a8:	dc400117 	ldw	r17,4(sp)
 b0017ac:	dc000017 	ldw	r16,0(sp)
 b0017b0:	dec00304 	addi	sp,sp,12
 b0017b4:	f800283a 	ret
 b0017b8:	2007883a 	mov	r3,r4
 b0017bc:	003ff206 	br	b001788 <__alt_mem_flash+0xff000788>
 b0017c0:	2007883a 	mov	r3,r4
 b0017c4:	003ff106 	br	b00178c <__alt_mem_flash+0xff00078c>
 b0017c8:	200d883a 	mov	r6,r4
 b0017cc:	003fee06 	br	b001788 <__alt_mem_flash+0xff000788>

0b0017d0 <memmove>:
 b0017d0:	2005883a 	mov	r2,r4
 b0017d4:	29000b2e 	bgeu	r5,r4,b001804 <memmove+0x34>
 b0017d8:	298f883a 	add	r7,r5,r6
 b0017dc:	21c0092e 	bgeu	r4,r7,b001804 <memmove+0x34>
 b0017e0:	2187883a 	add	r3,r4,r6
 b0017e4:	198bc83a 	sub	r5,r3,r6
 b0017e8:	30004826 	beq	r6,zero,b00190c <memmove+0x13c>
 b0017ec:	39ffffc4 	addi	r7,r7,-1
 b0017f0:	39000003 	ldbu	r4,0(r7)
 b0017f4:	18ffffc4 	addi	r3,r3,-1
 b0017f8:	19000005 	stb	r4,0(r3)
 b0017fc:	28fffb1e 	bne	r5,r3,b0017ec <__alt_mem_flash+0xff0007ec>
 b001800:	f800283a 	ret
 b001804:	00c003c4 	movi	r3,15
 b001808:	1980412e 	bgeu	r3,r6,b001910 <memmove+0x140>
 b00180c:	2886b03a 	or	r3,r5,r2
 b001810:	18c000cc 	andi	r3,r3,3
 b001814:	1800401e 	bne	r3,zero,b001918 <memmove+0x148>
 b001818:	33fffc04 	addi	r15,r6,-16
 b00181c:	781ed13a 	srli	r15,r15,4
 b001820:	28c00104 	addi	r3,r5,4
 b001824:	13400104 	addi	r13,r2,4
 b001828:	781c913a 	slli	r14,r15,4
 b00182c:	2b000204 	addi	r12,r5,8
 b001830:	12c00204 	addi	r11,r2,8
 b001834:	73800504 	addi	r14,r14,20
 b001838:	2a800304 	addi	r10,r5,12
 b00183c:	12400304 	addi	r9,r2,12
 b001840:	2b9d883a 	add	r14,r5,r14
 b001844:	2811883a 	mov	r8,r5
 b001848:	100f883a 	mov	r7,r2
 b00184c:	41000017 	ldw	r4,0(r8)
 b001850:	39c00404 	addi	r7,r7,16
 b001854:	18c00404 	addi	r3,r3,16
 b001858:	393ffc15 	stw	r4,-16(r7)
 b00185c:	193ffc17 	ldw	r4,-16(r3)
 b001860:	6b400404 	addi	r13,r13,16
 b001864:	5ac00404 	addi	r11,r11,16
 b001868:	693ffc15 	stw	r4,-16(r13)
 b00186c:	61000017 	ldw	r4,0(r12)
 b001870:	4a400404 	addi	r9,r9,16
 b001874:	42000404 	addi	r8,r8,16
 b001878:	593ffc15 	stw	r4,-16(r11)
 b00187c:	51000017 	ldw	r4,0(r10)
 b001880:	63000404 	addi	r12,r12,16
 b001884:	52800404 	addi	r10,r10,16
 b001888:	493ffc15 	stw	r4,-16(r9)
 b00188c:	1bbfef1e 	bne	r3,r14,b00184c <__alt_mem_flash+0xff00084c>
 b001890:	79000044 	addi	r4,r15,1
 b001894:	2008913a 	slli	r4,r4,4
 b001898:	328003cc 	andi	r10,r6,15
 b00189c:	02c000c4 	movi	r11,3
 b0018a0:	1107883a 	add	r3,r2,r4
 b0018a4:	290b883a 	add	r5,r5,r4
 b0018a8:	5a801e2e 	bgeu	r11,r10,b001924 <memmove+0x154>
 b0018ac:	1813883a 	mov	r9,r3
 b0018b0:	2811883a 	mov	r8,r5
 b0018b4:	500f883a 	mov	r7,r10
 b0018b8:	41000017 	ldw	r4,0(r8)
 b0018bc:	4a400104 	addi	r9,r9,4
 b0018c0:	39ffff04 	addi	r7,r7,-4
 b0018c4:	493fff15 	stw	r4,-4(r9)
 b0018c8:	42000104 	addi	r8,r8,4
 b0018cc:	59fffa36 	bltu	r11,r7,b0018b8 <__alt_mem_flash+0xff0008b8>
 b0018d0:	513fff04 	addi	r4,r10,-4
 b0018d4:	2008d0ba 	srli	r4,r4,2
 b0018d8:	318000cc 	andi	r6,r6,3
 b0018dc:	21000044 	addi	r4,r4,1
 b0018e0:	2109883a 	add	r4,r4,r4
 b0018e4:	2109883a 	add	r4,r4,r4
 b0018e8:	1907883a 	add	r3,r3,r4
 b0018ec:	290b883a 	add	r5,r5,r4
 b0018f0:	30000b26 	beq	r6,zero,b001920 <memmove+0x150>
 b0018f4:	198d883a 	add	r6,r3,r6
 b0018f8:	29c00003 	ldbu	r7,0(r5)
 b0018fc:	18c00044 	addi	r3,r3,1
 b001900:	29400044 	addi	r5,r5,1
 b001904:	19ffffc5 	stb	r7,-1(r3)
 b001908:	19bffb1e 	bne	r3,r6,b0018f8 <__alt_mem_flash+0xff0008f8>
 b00190c:	f800283a 	ret
 b001910:	1007883a 	mov	r3,r2
 b001914:	003ff606 	br	b0018f0 <__alt_mem_flash+0xff0008f0>
 b001918:	1007883a 	mov	r3,r2
 b00191c:	003ff506 	br	b0018f4 <__alt_mem_flash+0xff0008f4>
 b001920:	f800283a 	ret
 b001924:	500d883a 	mov	r6,r10
 b001928:	003ff106 	br	b0018f0 <__alt_mem_flash+0xff0008f0>

0b00192c <memset>:
 b00192c:	20c000cc 	andi	r3,r4,3
 b001930:	2005883a 	mov	r2,r4
 b001934:	18004426 	beq	r3,zero,b001a48 <memset+0x11c>
 b001938:	31ffffc4 	addi	r7,r6,-1
 b00193c:	30004026 	beq	r6,zero,b001a40 <memset+0x114>
 b001940:	2813883a 	mov	r9,r5
 b001944:	200d883a 	mov	r6,r4
 b001948:	2007883a 	mov	r3,r4
 b00194c:	00000406 	br	b001960 <memset+0x34>
 b001950:	3a3fffc4 	addi	r8,r7,-1
 b001954:	31800044 	addi	r6,r6,1
 b001958:	38003926 	beq	r7,zero,b001a40 <memset+0x114>
 b00195c:	400f883a 	mov	r7,r8
 b001960:	18c00044 	addi	r3,r3,1
 b001964:	32400005 	stb	r9,0(r6)
 b001968:	1a0000cc 	andi	r8,r3,3
 b00196c:	403ff81e 	bne	r8,zero,b001950 <__alt_mem_flash+0xff000950>
 b001970:	010000c4 	movi	r4,3
 b001974:	21c02d2e 	bgeu	r4,r7,b001a2c <memset+0x100>
 b001978:	29003fcc 	andi	r4,r5,255
 b00197c:	200c923a 	slli	r6,r4,8
 b001980:	3108b03a 	or	r4,r6,r4
 b001984:	200c943a 	slli	r6,r4,16
 b001988:	218cb03a 	or	r6,r4,r6
 b00198c:	010003c4 	movi	r4,15
 b001990:	21c0182e 	bgeu	r4,r7,b0019f4 <memset+0xc8>
 b001994:	3b3ffc04 	addi	r12,r7,-16
 b001998:	6018d13a 	srli	r12,r12,4
 b00199c:	1a000104 	addi	r8,r3,4
 b0019a0:	1ac00204 	addi	r11,r3,8
 b0019a4:	6008913a 	slli	r4,r12,4
 b0019a8:	1a800304 	addi	r10,r3,12
 b0019ac:	1813883a 	mov	r9,r3
 b0019b0:	21000504 	addi	r4,r4,20
 b0019b4:	1909883a 	add	r4,r3,r4
 b0019b8:	49800015 	stw	r6,0(r9)
 b0019bc:	41800015 	stw	r6,0(r8)
 b0019c0:	59800015 	stw	r6,0(r11)
 b0019c4:	51800015 	stw	r6,0(r10)
 b0019c8:	42000404 	addi	r8,r8,16
 b0019cc:	4a400404 	addi	r9,r9,16
 b0019d0:	5ac00404 	addi	r11,r11,16
 b0019d4:	52800404 	addi	r10,r10,16
 b0019d8:	413ff71e 	bne	r8,r4,b0019b8 <__alt_mem_flash+0xff0009b8>
 b0019dc:	63000044 	addi	r12,r12,1
 b0019e0:	6018913a 	slli	r12,r12,4
 b0019e4:	39c003cc 	andi	r7,r7,15
 b0019e8:	010000c4 	movi	r4,3
 b0019ec:	1b07883a 	add	r3,r3,r12
 b0019f0:	21c00e2e 	bgeu	r4,r7,b001a2c <memset+0x100>
 b0019f4:	1813883a 	mov	r9,r3
 b0019f8:	3811883a 	mov	r8,r7
 b0019fc:	010000c4 	movi	r4,3
 b001a00:	49800015 	stw	r6,0(r9)
 b001a04:	423fff04 	addi	r8,r8,-4
 b001a08:	4a400104 	addi	r9,r9,4
 b001a0c:	223ffc36 	bltu	r4,r8,b001a00 <__alt_mem_flash+0xff000a00>
 b001a10:	393fff04 	addi	r4,r7,-4
 b001a14:	2008d0ba 	srli	r4,r4,2
 b001a18:	39c000cc 	andi	r7,r7,3
 b001a1c:	21000044 	addi	r4,r4,1
 b001a20:	2109883a 	add	r4,r4,r4
 b001a24:	2109883a 	add	r4,r4,r4
 b001a28:	1907883a 	add	r3,r3,r4
 b001a2c:	38000526 	beq	r7,zero,b001a44 <memset+0x118>
 b001a30:	19cf883a 	add	r7,r3,r7
 b001a34:	19400005 	stb	r5,0(r3)
 b001a38:	18c00044 	addi	r3,r3,1
 b001a3c:	38fffd1e 	bne	r7,r3,b001a34 <__alt_mem_flash+0xff000a34>
 b001a40:	f800283a 	ret
 b001a44:	f800283a 	ret
 b001a48:	2007883a 	mov	r3,r4
 b001a4c:	300f883a 	mov	r7,r6
 b001a50:	003fc706 	br	b001970 <__alt_mem_flash+0xff000970>

0b001a54 <_realloc_r>:
 b001a54:	defff604 	addi	sp,sp,-40
 b001a58:	dc800215 	stw	r18,8(sp)
 b001a5c:	dfc00915 	stw	ra,36(sp)
 b001a60:	df000815 	stw	fp,32(sp)
 b001a64:	ddc00715 	stw	r23,28(sp)
 b001a68:	dd800615 	stw	r22,24(sp)
 b001a6c:	dd400515 	stw	r21,20(sp)
 b001a70:	dd000415 	stw	r20,16(sp)
 b001a74:	dcc00315 	stw	r19,12(sp)
 b001a78:	dc400115 	stw	r17,4(sp)
 b001a7c:	dc000015 	stw	r16,0(sp)
 b001a80:	3025883a 	mov	r18,r6
 b001a84:	2800b726 	beq	r5,zero,b001d64 <_realloc_r+0x310>
 b001a88:	282b883a 	mov	r21,r5
 b001a8c:	2029883a 	mov	r20,r4
 b001a90:	b0035d40 	call	b0035d4 <__malloc_lock>
 b001a94:	a8bfff17 	ldw	r2,-4(r21)
 b001a98:	043fff04 	movi	r16,-4
 b001a9c:	90c002c4 	addi	r3,r18,11
 b001aa0:	01000584 	movi	r4,22
 b001aa4:	acfffe04 	addi	r19,r21,-8
 b001aa8:	1420703a 	and	r16,r2,r16
 b001aac:	20c0332e 	bgeu	r4,r3,b001b7c <_realloc_r+0x128>
 b001ab0:	047ffe04 	movi	r17,-8
 b001ab4:	1c62703a 	and	r17,r3,r17
 b001ab8:	8807883a 	mov	r3,r17
 b001abc:	88005816 	blt	r17,zero,b001c20 <_realloc_r+0x1cc>
 b001ac0:	8c805736 	bltu	r17,r18,b001c20 <_realloc_r+0x1cc>
 b001ac4:	80c0300e 	bge	r16,r3,b001b88 <_realloc_r+0x134>
 b001ac8:	0702c034 	movhi	fp,2816
 b001acc:	e71e9904 	addi	fp,fp,31332
 b001ad0:	e1c00217 	ldw	r7,8(fp)
 b001ad4:	9c09883a 	add	r4,r19,r16
 b001ad8:	22000117 	ldw	r8,4(r4)
 b001adc:	21c06326 	beq	r4,r7,b001c6c <_realloc_r+0x218>
 b001ae0:	017fff84 	movi	r5,-2
 b001ae4:	414a703a 	and	r5,r8,r5
 b001ae8:	214b883a 	add	r5,r4,r5
 b001aec:	29800117 	ldw	r6,4(r5)
 b001af0:	3180004c 	andi	r6,r6,1
 b001af4:	30003f26 	beq	r6,zero,b001bf4 <_realloc_r+0x1a0>
 b001af8:	1080004c 	andi	r2,r2,1
 b001afc:	10008326 	beq	r2,zero,b001d0c <_realloc_r+0x2b8>
 b001b00:	900b883a 	mov	r5,r18
 b001b04:	a009883a 	mov	r4,r20
 b001b08:	b000d980 	call	b000d98 <_malloc_r>
 b001b0c:	1025883a 	mov	r18,r2
 b001b10:	10011e26 	beq	r2,zero,b001f8c <_realloc_r+0x538>
 b001b14:	a93fff17 	ldw	r4,-4(r21)
 b001b18:	10fffe04 	addi	r3,r2,-8
 b001b1c:	00bfff84 	movi	r2,-2
 b001b20:	2084703a 	and	r2,r4,r2
 b001b24:	9885883a 	add	r2,r19,r2
 b001b28:	1880ee26 	beq	r3,r2,b001ee4 <_realloc_r+0x490>
 b001b2c:	81bfff04 	addi	r6,r16,-4
 b001b30:	00800904 	movi	r2,36
 b001b34:	1180b836 	bltu	r2,r6,b001e18 <_realloc_r+0x3c4>
 b001b38:	00c004c4 	movi	r3,19
 b001b3c:	19809636 	bltu	r3,r6,b001d98 <_realloc_r+0x344>
 b001b40:	9005883a 	mov	r2,r18
 b001b44:	a807883a 	mov	r3,r21
 b001b48:	19000017 	ldw	r4,0(r3)
 b001b4c:	11000015 	stw	r4,0(r2)
 b001b50:	19000117 	ldw	r4,4(r3)
 b001b54:	11000115 	stw	r4,4(r2)
 b001b58:	18c00217 	ldw	r3,8(r3)
 b001b5c:	10c00215 	stw	r3,8(r2)
 b001b60:	a80b883a 	mov	r5,r21
 b001b64:	a009883a 	mov	r4,r20
 b001b68:	b0028200 	call	b002820 <_free_r>
 b001b6c:	a009883a 	mov	r4,r20
 b001b70:	b0035f80 	call	b0035f8 <__malloc_unlock>
 b001b74:	9005883a 	mov	r2,r18
 b001b78:	00001206 	br	b001bc4 <_realloc_r+0x170>
 b001b7c:	00c00404 	movi	r3,16
 b001b80:	1823883a 	mov	r17,r3
 b001b84:	003fce06 	br	b001ac0 <__alt_mem_flash+0xff000ac0>
 b001b88:	a825883a 	mov	r18,r21
 b001b8c:	8445c83a 	sub	r2,r16,r17
 b001b90:	00c003c4 	movi	r3,15
 b001b94:	18802636 	bltu	r3,r2,b001c30 <_realloc_r+0x1dc>
 b001b98:	99800117 	ldw	r6,4(r19)
 b001b9c:	9c07883a 	add	r3,r19,r16
 b001ba0:	3180004c 	andi	r6,r6,1
 b001ba4:	3420b03a 	or	r16,r6,r16
 b001ba8:	9c000115 	stw	r16,4(r19)
 b001bac:	18800117 	ldw	r2,4(r3)
 b001bb0:	10800054 	ori	r2,r2,1
 b001bb4:	18800115 	stw	r2,4(r3)
 b001bb8:	a009883a 	mov	r4,r20
 b001bbc:	b0035f80 	call	b0035f8 <__malloc_unlock>
 b001bc0:	9005883a 	mov	r2,r18
 b001bc4:	dfc00917 	ldw	ra,36(sp)
 b001bc8:	df000817 	ldw	fp,32(sp)
 b001bcc:	ddc00717 	ldw	r23,28(sp)
 b001bd0:	dd800617 	ldw	r22,24(sp)
 b001bd4:	dd400517 	ldw	r21,20(sp)
 b001bd8:	dd000417 	ldw	r20,16(sp)
 b001bdc:	dcc00317 	ldw	r19,12(sp)
 b001be0:	dc800217 	ldw	r18,8(sp)
 b001be4:	dc400117 	ldw	r17,4(sp)
 b001be8:	dc000017 	ldw	r16,0(sp)
 b001bec:	dec00a04 	addi	sp,sp,40
 b001bf0:	f800283a 	ret
 b001bf4:	017fff04 	movi	r5,-4
 b001bf8:	414a703a 	and	r5,r8,r5
 b001bfc:	814d883a 	add	r6,r16,r5
 b001c00:	30c01f16 	blt	r6,r3,b001c80 <_realloc_r+0x22c>
 b001c04:	20800317 	ldw	r2,12(r4)
 b001c08:	20c00217 	ldw	r3,8(r4)
 b001c0c:	a825883a 	mov	r18,r21
 b001c10:	3021883a 	mov	r16,r6
 b001c14:	18800315 	stw	r2,12(r3)
 b001c18:	10c00215 	stw	r3,8(r2)
 b001c1c:	003fdb06 	br	b001b8c <__alt_mem_flash+0xff000b8c>
 b001c20:	00800304 	movi	r2,12
 b001c24:	a0800015 	stw	r2,0(r20)
 b001c28:	0005883a 	mov	r2,zero
 b001c2c:	003fe506 	br	b001bc4 <__alt_mem_flash+0xff000bc4>
 b001c30:	98c00117 	ldw	r3,4(r19)
 b001c34:	9c4b883a 	add	r5,r19,r17
 b001c38:	11000054 	ori	r4,r2,1
 b001c3c:	18c0004c 	andi	r3,r3,1
 b001c40:	1c62b03a 	or	r17,r3,r17
 b001c44:	9c400115 	stw	r17,4(r19)
 b001c48:	29000115 	stw	r4,4(r5)
 b001c4c:	2885883a 	add	r2,r5,r2
 b001c50:	10c00117 	ldw	r3,4(r2)
 b001c54:	29400204 	addi	r5,r5,8
 b001c58:	a009883a 	mov	r4,r20
 b001c5c:	18c00054 	ori	r3,r3,1
 b001c60:	10c00115 	stw	r3,4(r2)
 b001c64:	b0028200 	call	b002820 <_free_r>
 b001c68:	003fd306 	br	b001bb8 <__alt_mem_flash+0xff000bb8>
 b001c6c:	017fff04 	movi	r5,-4
 b001c70:	414a703a 	and	r5,r8,r5
 b001c74:	89800404 	addi	r6,r17,16
 b001c78:	8151883a 	add	r8,r16,r5
 b001c7c:	4180590e 	bge	r8,r6,b001de4 <_realloc_r+0x390>
 b001c80:	1080004c 	andi	r2,r2,1
 b001c84:	103f9e1e 	bne	r2,zero,b001b00 <__alt_mem_flash+0xff000b00>
 b001c88:	adbffe17 	ldw	r22,-8(r21)
 b001c8c:	00bfff04 	movi	r2,-4
 b001c90:	9dadc83a 	sub	r22,r19,r22
 b001c94:	b1800117 	ldw	r6,4(r22)
 b001c98:	3084703a 	and	r2,r6,r2
 b001c9c:	20002026 	beq	r4,zero,b001d20 <_realloc_r+0x2cc>
 b001ca0:	80af883a 	add	r23,r16,r2
 b001ca4:	b96f883a 	add	r23,r23,r5
 b001ca8:	21c05f26 	beq	r4,r7,b001e28 <_realloc_r+0x3d4>
 b001cac:	b8c01c16 	blt	r23,r3,b001d20 <_realloc_r+0x2cc>
 b001cb0:	20800317 	ldw	r2,12(r4)
 b001cb4:	20c00217 	ldw	r3,8(r4)
 b001cb8:	81bfff04 	addi	r6,r16,-4
 b001cbc:	01000904 	movi	r4,36
 b001cc0:	18800315 	stw	r2,12(r3)
 b001cc4:	10c00215 	stw	r3,8(r2)
 b001cc8:	b0c00217 	ldw	r3,8(r22)
 b001ccc:	b0800317 	ldw	r2,12(r22)
 b001cd0:	b4800204 	addi	r18,r22,8
 b001cd4:	18800315 	stw	r2,12(r3)
 b001cd8:	10c00215 	stw	r3,8(r2)
 b001cdc:	21801b36 	bltu	r4,r6,b001d4c <_realloc_r+0x2f8>
 b001ce0:	008004c4 	movi	r2,19
 b001ce4:	1180352e 	bgeu	r2,r6,b001dbc <_realloc_r+0x368>
 b001ce8:	a8800017 	ldw	r2,0(r21)
 b001cec:	b0800215 	stw	r2,8(r22)
 b001cf0:	a8800117 	ldw	r2,4(r21)
 b001cf4:	b0800315 	stw	r2,12(r22)
 b001cf8:	008006c4 	movi	r2,27
 b001cfc:	11807f36 	bltu	r2,r6,b001efc <_realloc_r+0x4a8>
 b001d00:	b0800404 	addi	r2,r22,16
 b001d04:	ad400204 	addi	r21,r21,8
 b001d08:	00002d06 	br	b001dc0 <_realloc_r+0x36c>
 b001d0c:	adbffe17 	ldw	r22,-8(r21)
 b001d10:	00bfff04 	movi	r2,-4
 b001d14:	9dadc83a 	sub	r22,r19,r22
 b001d18:	b1000117 	ldw	r4,4(r22)
 b001d1c:	2084703a 	and	r2,r4,r2
 b001d20:	b03f7726 	beq	r22,zero,b001b00 <__alt_mem_flash+0xff000b00>
 b001d24:	80af883a 	add	r23,r16,r2
 b001d28:	b8ff7516 	blt	r23,r3,b001b00 <__alt_mem_flash+0xff000b00>
 b001d2c:	b0800317 	ldw	r2,12(r22)
 b001d30:	b0c00217 	ldw	r3,8(r22)
 b001d34:	81bfff04 	addi	r6,r16,-4
 b001d38:	01000904 	movi	r4,36
 b001d3c:	18800315 	stw	r2,12(r3)
 b001d40:	10c00215 	stw	r3,8(r2)
 b001d44:	b4800204 	addi	r18,r22,8
 b001d48:	21bfe52e 	bgeu	r4,r6,b001ce0 <__alt_mem_flash+0xff000ce0>
 b001d4c:	a80b883a 	mov	r5,r21
 b001d50:	9009883a 	mov	r4,r18
 b001d54:	b0017d00 	call	b0017d0 <memmove>
 b001d58:	b821883a 	mov	r16,r23
 b001d5c:	b027883a 	mov	r19,r22
 b001d60:	003f8a06 	br	b001b8c <__alt_mem_flash+0xff000b8c>
 b001d64:	300b883a 	mov	r5,r6
 b001d68:	dfc00917 	ldw	ra,36(sp)
 b001d6c:	df000817 	ldw	fp,32(sp)
 b001d70:	ddc00717 	ldw	r23,28(sp)
 b001d74:	dd800617 	ldw	r22,24(sp)
 b001d78:	dd400517 	ldw	r21,20(sp)
 b001d7c:	dd000417 	ldw	r20,16(sp)
 b001d80:	dcc00317 	ldw	r19,12(sp)
 b001d84:	dc800217 	ldw	r18,8(sp)
 b001d88:	dc400117 	ldw	r17,4(sp)
 b001d8c:	dc000017 	ldw	r16,0(sp)
 b001d90:	dec00a04 	addi	sp,sp,40
 b001d94:	b000d981 	jmpi	b000d98 <_malloc_r>
 b001d98:	a8c00017 	ldw	r3,0(r21)
 b001d9c:	90c00015 	stw	r3,0(r18)
 b001da0:	a8c00117 	ldw	r3,4(r21)
 b001da4:	90c00115 	stw	r3,4(r18)
 b001da8:	00c006c4 	movi	r3,27
 b001dac:	19804536 	bltu	r3,r6,b001ec4 <_realloc_r+0x470>
 b001db0:	90800204 	addi	r2,r18,8
 b001db4:	a8c00204 	addi	r3,r21,8
 b001db8:	003f6306 	br	b001b48 <__alt_mem_flash+0xff000b48>
 b001dbc:	9005883a 	mov	r2,r18
 b001dc0:	a8c00017 	ldw	r3,0(r21)
 b001dc4:	b821883a 	mov	r16,r23
 b001dc8:	b027883a 	mov	r19,r22
 b001dcc:	10c00015 	stw	r3,0(r2)
 b001dd0:	a8c00117 	ldw	r3,4(r21)
 b001dd4:	10c00115 	stw	r3,4(r2)
 b001dd8:	a8c00217 	ldw	r3,8(r21)
 b001ddc:	10c00215 	stw	r3,8(r2)
 b001de0:	003f6a06 	br	b001b8c <__alt_mem_flash+0xff000b8c>
 b001de4:	9c67883a 	add	r19,r19,r17
 b001de8:	4445c83a 	sub	r2,r8,r17
 b001dec:	e4c00215 	stw	r19,8(fp)
 b001df0:	10800054 	ori	r2,r2,1
 b001df4:	98800115 	stw	r2,4(r19)
 b001df8:	a8bfff17 	ldw	r2,-4(r21)
 b001dfc:	a009883a 	mov	r4,r20
 b001e00:	1080004c 	andi	r2,r2,1
 b001e04:	1462b03a 	or	r17,r2,r17
 b001e08:	ac7fff15 	stw	r17,-4(r21)
 b001e0c:	b0035f80 	call	b0035f8 <__malloc_unlock>
 b001e10:	a805883a 	mov	r2,r21
 b001e14:	003f6b06 	br	b001bc4 <__alt_mem_flash+0xff000bc4>
 b001e18:	a80b883a 	mov	r5,r21
 b001e1c:	9009883a 	mov	r4,r18
 b001e20:	b0017d00 	call	b0017d0 <memmove>
 b001e24:	003f4e06 	br	b001b60 <__alt_mem_flash+0xff000b60>
 b001e28:	89000404 	addi	r4,r17,16
 b001e2c:	b93fbc16 	blt	r23,r4,b001d20 <__alt_mem_flash+0xff000d20>
 b001e30:	b0800317 	ldw	r2,12(r22)
 b001e34:	b0c00217 	ldw	r3,8(r22)
 b001e38:	81bfff04 	addi	r6,r16,-4
 b001e3c:	01000904 	movi	r4,36
 b001e40:	18800315 	stw	r2,12(r3)
 b001e44:	10c00215 	stw	r3,8(r2)
 b001e48:	b4800204 	addi	r18,r22,8
 b001e4c:	21804336 	bltu	r4,r6,b001f5c <_realloc_r+0x508>
 b001e50:	008004c4 	movi	r2,19
 b001e54:	11803f2e 	bgeu	r2,r6,b001f54 <_realloc_r+0x500>
 b001e58:	a8800017 	ldw	r2,0(r21)
 b001e5c:	b0800215 	stw	r2,8(r22)
 b001e60:	a8800117 	ldw	r2,4(r21)
 b001e64:	b0800315 	stw	r2,12(r22)
 b001e68:	008006c4 	movi	r2,27
 b001e6c:	11803f36 	bltu	r2,r6,b001f6c <_realloc_r+0x518>
 b001e70:	b0800404 	addi	r2,r22,16
 b001e74:	ad400204 	addi	r21,r21,8
 b001e78:	a8c00017 	ldw	r3,0(r21)
 b001e7c:	10c00015 	stw	r3,0(r2)
 b001e80:	a8c00117 	ldw	r3,4(r21)
 b001e84:	10c00115 	stw	r3,4(r2)
 b001e88:	a8c00217 	ldw	r3,8(r21)
 b001e8c:	10c00215 	stw	r3,8(r2)
 b001e90:	b447883a 	add	r3,r22,r17
 b001e94:	bc45c83a 	sub	r2,r23,r17
 b001e98:	e0c00215 	stw	r3,8(fp)
 b001e9c:	10800054 	ori	r2,r2,1
 b001ea0:	18800115 	stw	r2,4(r3)
 b001ea4:	b0800117 	ldw	r2,4(r22)
 b001ea8:	a009883a 	mov	r4,r20
 b001eac:	1080004c 	andi	r2,r2,1
 b001eb0:	1462b03a 	or	r17,r2,r17
 b001eb4:	b4400115 	stw	r17,4(r22)
 b001eb8:	b0035f80 	call	b0035f8 <__malloc_unlock>
 b001ebc:	9005883a 	mov	r2,r18
 b001ec0:	003f4006 	br	b001bc4 <__alt_mem_flash+0xff000bc4>
 b001ec4:	a8c00217 	ldw	r3,8(r21)
 b001ec8:	90c00215 	stw	r3,8(r18)
 b001ecc:	a8c00317 	ldw	r3,12(r21)
 b001ed0:	90c00315 	stw	r3,12(r18)
 b001ed4:	30801126 	beq	r6,r2,b001f1c <_realloc_r+0x4c8>
 b001ed8:	90800404 	addi	r2,r18,16
 b001edc:	a8c00404 	addi	r3,r21,16
 b001ee0:	003f1906 	br	b001b48 <__alt_mem_flash+0xff000b48>
 b001ee4:	90ffff17 	ldw	r3,-4(r18)
 b001ee8:	00bfff04 	movi	r2,-4
 b001eec:	a825883a 	mov	r18,r21
 b001ef0:	1884703a 	and	r2,r3,r2
 b001ef4:	80a1883a 	add	r16,r16,r2
 b001ef8:	003f2406 	br	b001b8c <__alt_mem_flash+0xff000b8c>
 b001efc:	a8800217 	ldw	r2,8(r21)
 b001f00:	b0800415 	stw	r2,16(r22)
 b001f04:	a8800317 	ldw	r2,12(r21)
 b001f08:	b0800515 	stw	r2,20(r22)
 b001f0c:	31000a26 	beq	r6,r4,b001f38 <_realloc_r+0x4e4>
 b001f10:	b0800604 	addi	r2,r22,24
 b001f14:	ad400404 	addi	r21,r21,16
 b001f18:	003fa906 	br	b001dc0 <__alt_mem_flash+0xff000dc0>
 b001f1c:	a9000417 	ldw	r4,16(r21)
 b001f20:	90800604 	addi	r2,r18,24
 b001f24:	a8c00604 	addi	r3,r21,24
 b001f28:	91000415 	stw	r4,16(r18)
 b001f2c:	a9000517 	ldw	r4,20(r21)
 b001f30:	91000515 	stw	r4,20(r18)
 b001f34:	003f0406 	br	b001b48 <__alt_mem_flash+0xff000b48>
 b001f38:	a8c00417 	ldw	r3,16(r21)
 b001f3c:	ad400604 	addi	r21,r21,24
 b001f40:	b0800804 	addi	r2,r22,32
 b001f44:	b0c00615 	stw	r3,24(r22)
 b001f48:	a8ffff17 	ldw	r3,-4(r21)
 b001f4c:	b0c00715 	stw	r3,28(r22)
 b001f50:	003f9b06 	br	b001dc0 <__alt_mem_flash+0xff000dc0>
 b001f54:	9005883a 	mov	r2,r18
 b001f58:	003fc706 	br	b001e78 <__alt_mem_flash+0xff000e78>
 b001f5c:	a80b883a 	mov	r5,r21
 b001f60:	9009883a 	mov	r4,r18
 b001f64:	b0017d00 	call	b0017d0 <memmove>
 b001f68:	003fc906 	br	b001e90 <__alt_mem_flash+0xff000e90>
 b001f6c:	a8800217 	ldw	r2,8(r21)
 b001f70:	b0800415 	stw	r2,16(r22)
 b001f74:	a8800317 	ldw	r2,12(r21)
 b001f78:	b0800515 	stw	r2,20(r22)
 b001f7c:	31000726 	beq	r6,r4,b001f9c <_realloc_r+0x548>
 b001f80:	b0800604 	addi	r2,r22,24
 b001f84:	ad400404 	addi	r21,r21,16
 b001f88:	003fbb06 	br	b001e78 <__alt_mem_flash+0xff000e78>
 b001f8c:	a009883a 	mov	r4,r20
 b001f90:	b0035f80 	call	b0035f8 <__malloc_unlock>
 b001f94:	0005883a 	mov	r2,zero
 b001f98:	003f0a06 	br	b001bc4 <__alt_mem_flash+0xff000bc4>
 b001f9c:	a8c00417 	ldw	r3,16(r21)
 b001fa0:	ad400604 	addi	r21,r21,24
 b001fa4:	b0800804 	addi	r2,r22,32
 b001fa8:	b0c00615 	stw	r3,24(r22)
 b001fac:	a8ffff17 	ldw	r3,-4(r21)
 b001fb0:	b0c00715 	stw	r3,28(r22)
 b001fb4:	003fb006 	br	b001e78 <__alt_mem_flash+0xff000e78>

0b001fb8 <_sbrk_r>:
 b001fb8:	defffd04 	addi	sp,sp,-12
 b001fbc:	dc000015 	stw	r16,0(sp)
 b001fc0:	0402c074 	movhi	r16,2817
 b001fc4:	dc400115 	stw	r17,4(sp)
 b001fc8:	842bab04 	addi	r16,r16,-20820
 b001fcc:	2023883a 	mov	r17,r4
 b001fd0:	2809883a 	mov	r4,r5
 b001fd4:	dfc00215 	stw	ra,8(sp)
 b001fd8:	80000015 	stw	zero,0(r16)
 b001fdc:	b0037e00 	call	b0037e0 <sbrk>
 b001fe0:	00ffffc4 	movi	r3,-1
 b001fe4:	10c00526 	beq	r2,r3,b001ffc <_sbrk_r+0x44>
 b001fe8:	dfc00217 	ldw	ra,8(sp)
 b001fec:	dc400117 	ldw	r17,4(sp)
 b001ff0:	dc000017 	ldw	r16,0(sp)
 b001ff4:	dec00304 	addi	sp,sp,12
 b001ff8:	f800283a 	ret
 b001ffc:	80c00017 	ldw	r3,0(r16)
 b002000:	183ff926 	beq	r3,zero,b001fe8 <__alt_mem_flash+0xff000fe8>
 b002004:	88c00015 	stw	r3,0(r17)
 b002008:	003ff706 	br	b001fe8 <__alt_mem_flash+0xff000fe8>

0b00200c <__sread>:
 b00200c:	defffe04 	addi	sp,sp,-8
 b002010:	dc000015 	stw	r16,0(sp)
 b002014:	2821883a 	mov	r16,r5
 b002018:	2940038f 	ldh	r5,14(r5)
 b00201c:	dfc00115 	stw	ra,4(sp)
 b002020:	b002d4c0 	call	b002d4c <_read_r>
 b002024:	10000716 	blt	r2,zero,b002044 <__sread+0x38>
 b002028:	80c01417 	ldw	r3,80(r16)
 b00202c:	1887883a 	add	r3,r3,r2
 b002030:	80c01415 	stw	r3,80(r16)
 b002034:	dfc00117 	ldw	ra,4(sp)
 b002038:	dc000017 	ldw	r16,0(sp)
 b00203c:	dec00204 	addi	sp,sp,8
 b002040:	f800283a 	ret
 b002044:	80c0030b 	ldhu	r3,12(r16)
 b002048:	18fbffcc 	andi	r3,r3,61439
 b00204c:	80c0030d 	sth	r3,12(r16)
 b002050:	dfc00117 	ldw	ra,4(sp)
 b002054:	dc000017 	ldw	r16,0(sp)
 b002058:	dec00204 	addi	sp,sp,8
 b00205c:	f800283a 	ret

0b002060 <__seofread>:
 b002060:	0005883a 	mov	r2,zero
 b002064:	f800283a 	ret

0b002068 <__swrite>:
 b002068:	2880030b 	ldhu	r2,12(r5)
 b00206c:	defffb04 	addi	sp,sp,-20
 b002070:	dcc00315 	stw	r19,12(sp)
 b002074:	dc800215 	stw	r18,8(sp)
 b002078:	dc400115 	stw	r17,4(sp)
 b00207c:	dc000015 	stw	r16,0(sp)
 b002080:	dfc00415 	stw	ra,16(sp)
 b002084:	10c0400c 	andi	r3,r2,256
 b002088:	2821883a 	mov	r16,r5
 b00208c:	2023883a 	mov	r17,r4
 b002090:	3025883a 	mov	r18,r6
 b002094:	3827883a 	mov	r19,r7
 b002098:	18000526 	beq	r3,zero,b0020b0 <__swrite+0x48>
 b00209c:	2940038f 	ldh	r5,14(r5)
 b0020a0:	01c00084 	movi	r7,2
 b0020a4:	000d883a 	mov	r6,zero
 b0020a8:	b002b300 	call	b002b30 <_lseek_r>
 b0020ac:	8080030b 	ldhu	r2,12(r16)
 b0020b0:	8140038f 	ldh	r5,14(r16)
 b0020b4:	10bbffcc 	andi	r2,r2,61439
 b0020b8:	980f883a 	mov	r7,r19
 b0020bc:	900d883a 	mov	r6,r18
 b0020c0:	8809883a 	mov	r4,r17
 b0020c4:	8080030d 	sth	r2,12(r16)
 b0020c8:	dfc00417 	ldw	ra,16(sp)
 b0020cc:	dcc00317 	ldw	r19,12(sp)
 b0020d0:	dc800217 	ldw	r18,8(sp)
 b0020d4:	dc400117 	ldw	r17,4(sp)
 b0020d8:	dc000017 	ldw	r16,0(sp)
 b0020dc:	dec00504 	addi	sp,sp,20
 b0020e0:	b0021481 	jmpi	b002148 <_write_r>

0b0020e4 <__sseek>:
 b0020e4:	defffe04 	addi	sp,sp,-8
 b0020e8:	dc000015 	stw	r16,0(sp)
 b0020ec:	2821883a 	mov	r16,r5
 b0020f0:	2940038f 	ldh	r5,14(r5)
 b0020f4:	dfc00115 	stw	ra,4(sp)
 b0020f8:	b002b300 	call	b002b30 <_lseek_r>
 b0020fc:	00ffffc4 	movi	r3,-1
 b002100:	10c00826 	beq	r2,r3,b002124 <__sseek+0x40>
 b002104:	80c0030b 	ldhu	r3,12(r16)
 b002108:	80801415 	stw	r2,80(r16)
 b00210c:	18c40014 	ori	r3,r3,4096
 b002110:	80c0030d 	sth	r3,12(r16)
 b002114:	dfc00117 	ldw	ra,4(sp)
 b002118:	dc000017 	ldw	r16,0(sp)
 b00211c:	dec00204 	addi	sp,sp,8
 b002120:	f800283a 	ret
 b002124:	80c0030b 	ldhu	r3,12(r16)
 b002128:	18fbffcc 	andi	r3,r3,61439
 b00212c:	80c0030d 	sth	r3,12(r16)
 b002130:	dfc00117 	ldw	ra,4(sp)
 b002134:	dc000017 	ldw	r16,0(sp)
 b002138:	dec00204 	addi	sp,sp,8
 b00213c:	f800283a 	ret

0b002140 <__sclose>:
 b002140:	2940038f 	ldh	r5,14(r5)
 b002144:	b0022fc1 	jmpi	b0022fc <_close_r>

0b002148 <_write_r>:
 b002148:	defffd04 	addi	sp,sp,-12
 b00214c:	2805883a 	mov	r2,r5
 b002150:	dc000015 	stw	r16,0(sp)
 b002154:	0402c074 	movhi	r16,2817
 b002158:	dc400115 	stw	r17,4(sp)
 b00215c:	300b883a 	mov	r5,r6
 b002160:	842bab04 	addi	r16,r16,-20820
 b002164:	2023883a 	mov	r17,r4
 b002168:	380d883a 	mov	r6,r7
 b00216c:	1009883a 	mov	r4,r2
 b002170:	dfc00215 	stw	ra,8(sp)
 b002174:	80000015 	stw	zero,0(r16)
 b002178:	b0038fc0 	call	b0038fc <write>
 b00217c:	00ffffc4 	movi	r3,-1
 b002180:	10c00526 	beq	r2,r3,b002198 <_write_r+0x50>
 b002184:	dfc00217 	ldw	ra,8(sp)
 b002188:	dc400117 	ldw	r17,4(sp)
 b00218c:	dc000017 	ldw	r16,0(sp)
 b002190:	dec00304 	addi	sp,sp,12
 b002194:	f800283a 	ret
 b002198:	80c00017 	ldw	r3,0(r16)
 b00219c:	183ff926 	beq	r3,zero,b002184 <__alt_mem_flash+0xff001184>
 b0021a0:	88c00015 	stw	r3,0(r17)
 b0021a4:	003ff706 	br	b002184 <__alt_mem_flash+0xff001184>

0b0021a8 <__swsetup_r>:
 b0021a8:	0082c074 	movhi	r2,2817
 b0021ac:	defffd04 	addi	sp,sp,-12
 b0021b0:	10a48d04 	addi	r2,r2,-28108
 b0021b4:	dc400115 	stw	r17,4(sp)
 b0021b8:	2023883a 	mov	r17,r4
 b0021bc:	11000017 	ldw	r4,0(r2)
 b0021c0:	dc000015 	stw	r16,0(sp)
 b0021c4:	dfc00215 	stw	ra,8(sp)
 b0021c8:	2821883a 	mov	r16,r5
 b0021cc:	20000226 	beq	r4,zero,b0021d8 <__swsetup_r+0x30>
 b0021d0:	20800e17 	ldw	r2,56(r4)
 b0021d4:	10003126 	beq	r2,zero,b00229c <__swsetup_r+0xf4>
 b0021d8:	8080030b 	ldhu	r2,12(r16)
 b0021dc:	10c0020c 	andi	r3,r2,8
 b0021e0:	1009883a 	mov	r4,r2
 b0021e4:	18000f26 	beq	r3,zero,b002224 <__swsetup_r+0x7c>
 b0021e8:	80c00417 	ldw	r3,16(r16)
 b0021ec:	18001526 	beq	r3,zero,b002244 <__swsetup_r+0x9c>
 b0021f0:	1100004c 	andi	r4,r2,1
 b0021f4:	20001c1e 	bne	r4,zero,b002268 <__swsetup_r+0xc0>
 b0021f8:	1080008c 	andi	r2,r2,2
 b0021fc:	1000291e 	bne	r2,zero,b0022a4 <__swsetup_r+0xfc>
 b002200:	80800517 	ldw	r2,20(r16)
 b002204:	80800215 	stw	r2,8(r16)
 b002208:	18001c26 	beq	r3,zero,b00227c <__swsetup_r+0xd4>
 b00220c:	0005883a 	mov	r2,zero
 b002210:	dfc00217 	ldw	ra,8(sp)
 b002214:	dc400117 	ldw	r17,4(sp)
 b002218:	dc000017 	ldw	r16,0(sp)
 b00221c:	dec00304 	addi	sp,sp,12
 b002220:	f800283a 	ret
 b002224:	2080040c 	andi	r2,r4,16
 b002228:	10002e26 	beq	r2,zero,b0022e4 <__swsetup_r+0x13c>
 b00222c:	2080010c 	andi	r2,r4,4
 b002230:	10001e1e 	bne	r2,zero,b0022ac <__swsetup_r+0x104>
 b002234:	80c00417 	ldw	r3,16(r16)
 b002238:	20800214 	ori	r2,r4,8
 b00223c:	8080030d 	sth	r2,12(r16)
 b002240:	183feb1e 	bne	r3,zero,b0021f0 <__alt_mem_flash+0xff0011f0>
 b002244:	1100a00c 	andi	r4,r2,640
 b002248:	01408004 	movi	r5,512
 b00224c:	217fe826 	beq	r4,r5,b0021f0 <__alt_mem_flash+0xff0011f0>
 b002250:	800b883a 	mov	r5,r16
 b002254:	8809883a 	mov	r4,r17
 b002258:	b002b900 	call	b002b90 <__smakebuf_r>
 b00225c:	8080030b 	ldhu	r2,12(r16)
 b002260:	80c00417 	ldw	r3,16(r16)
 b002264:	003fe206 	br	b0021f0 <__alt_mem_flash+0xff0011f0>
 b002268:	80800517 	ldw	r2,20(r16)
 b00226c:	80000215 	stw	zero,8(r16)
 b002270:	0085c83a 	sub	r2,zero,r2
 b002274:	80800615 	stw	r2,24(r16)
 b002278:	183fe41e 	bne	r3,zero,b00220c <__alt_mem_flash+0xff00120c>
 b00227c:	80c0030b 	ldhu	r3,12(r16)
 b002280:	0005883a 	mov	r2,zero
 b002284:	1900200c 	andi	r4,r3,128
 b002288:	203fe126 	beq	r4,zero,b002210 <__alt_mem_flash+0xff001210>
 b00228c:	18c01014 	ori	r3,r3,64
 b002290:	80c0030d 	sth	r3,12(r16)
 b002294:	00bfffc4 	movi	r2,-1
 b002298:	003fdd06 	br	b002210 <__alt_mem_flash+0xff001210>
 b00229c:	b0006f80 	call	b0006f8 <__sinit>
 b0022a0:	003fcd06 	br	b0021d8 <__alt_mem_flash+0xff0011d8>
 b0022a4:	0005883a 	mov	r2,zero
 b0022a8:	003fd606 	br	b002204 <__alt_mem_flash+0xff001204>
 b0022ac:	81400c17 	ldw	r5,48(r16)
 b0022b0:	28000626 	beq	r5,zero,b0022cc <__swsetup_r+0x124>
 b0022b4:	80801004 	addi	r2,r16,64
 b0022b8:	28800326 	beq	r5,r2,b0022c8 <__swsetup_r+0x120>
 b0022bc:	8809883a 	mov	r4,r17
 b0022c0:	b0028200 	call	b002820 <_free_r>
 b0022c4:	8100030b 	ldhu	r4,12(r16)
 b0022c8:	80000c15 	stw	zero,48(r16)
 b0022cc:	80c00417 	ldw	r3,16(r16)
 b0022d0:	00bff6c4 	movi	r2,-37
 b0022d4:	1108703a 	and	r4,r2,r4
 b0022d8:	80000115 	stw	zero,4(r16)
 b0022dc:	80c00015 	stw	r3,0(r16)
 b0022e0:	003fd506 	br	b002238 <__alt_mem_flash+0xff001238>
 b0022e4:	00800244 	movi	r2,9
 b0022e8:	88800015 	stw	r2,0(r17)
 b0022ec:	20801014 	ori	r2,r4,64
 b0022f0:	8080030d 	sth	r2,12(r16)
 b0022f4:	00bfffc4 	movi	r2,-1
 b0022f8:	003fc506 	br	b002210 <__alt_mem_flash+0xff001210>

0b0022fc <_close_r>:
 b0022fc:	defffd04 	addi	sp,sp,-12
 b002300:	dc000015 	stw	r16,0(sp)
 b002304:	0402c074 	movhi	r16,2817
 b002308:	dc400115 	stw	r17,4(sp)
 b00230c:	842bab04 	addi	r16,r16,-20820
 b002310:	2023883a 	mov	r17,r4
 b002314:	2809883a 	mov	r4,r5
 b002318:	dfc00215 	stw	ra,8(sp)
 b00231c:	80000015 	stw	zero,0(r16)
 b002320:	b0030740 	call	b003074 <close>
 b002324:	00ffffc4 	movi	r3,-1
 b002328:	10c00526 	beq	r2,r3,b002340 <_close_r+0x44>
 b00232c:	dfc00217 	ldw	ra,8(sp)
 b002330:	dc400117 	ldw	r17,4(sp)
 b002334:	dc000017 	ldw	r16,0(sp)
 b002338:	dec00304 	addi	sp,sp,12
 b00233c:	f800283a 	ret
 b002340:	80c00017 	ldw	r3,0(r16)
 b002344:	183ff926 	beq	r3,zero,b00232c <__alt_mem_flash+0xff00132c>
 b002348:	88c00015 	stw	r3,0(r17)
 b00234c:	003ff706 	br	b00232c <__alt_mem_flash+0xff00132c>

0b002350 <_fclose_r>:
 b002350:	28003926 	beq	r5,zero,b002438 <_fclose_r+0xe8>
 b002354:	defffc04 	addi	sp,sp,-16
 b002358:	dc400115 	stw	r17,4(sp)
 b00235c:	dc000015 	stw	r16,0(sp)
 b002360:	dfc00315 	stw	ra,12(sp)
 b002364:	dc800215 	stw	r18,8(sp)
 b002368:	2023883a 	mov	r17,r4
 b00236c:	2821883a 	mov	r16,r5
 b002370:	20000226 	beq	r4,zero,b00237c <_fclose_r+0x2c>
 b002374:	20800e17 	ldw	r2,56(r4)
 b002378:	10002726 	beq	r2,zero,b002418 <_fclose_r+0xc8>
 b00237c:	8080030f 	ldh	r2,12(r16)
 b002380:	1000071e 	bne	r2,zero,b0023a0 <_fclose_r+0x50>
 b002384:	0005883a 	mov	r2,zero
 b002388:	dfc00317 	ldw	ra,12(sp)
 b00238c:	dc800217 	ldw	r18,8(sp)
 b002390:	dc400117 	ldw	r17,4(sp)
 b002394:	dc000017 	ldw	r16,0(sp)
 b002398:	dec00404 	addi	sp,sp,16
 b00239c:	f800283a 	ret
 b0023a0:	800b883a 	mov	r5,r16
 b0023a4:	8809883a 	mov	r4,r17
 b0023a8:	b0024540 	call	b002454 <__sflush_r>
 b0023ac:	1025883a 	mov	r18,r2
 b0023b0:	80800b17 	ldw	r2,44(r16)
 b0023b4:	10000426 	beq	r2,zero,b0023c8 <_fclose_r+0x78>
 b0023b8:	81400717 	ldw	r5,28(r16)
 b0023bc:	8809883a 	mov	r4,r17
 b0023c0:	103ee83a 	callr	r2
 b0023c4:	10001616 	blt	r2,zero,b002420 <_fclose_r+0xd0>
 b0023c8:	8080030b 	ldhu	r2,12(r16)
 b0023cc:	1080200c 	andi	r2,r2,128
 b0023d0:	1000151e 	bne	r2,zero,b002428 <_fclose_r+0xd8>
 b0023d4:	81400c17 	ldw	r5,48(r16)
 b0023d8:	28000526 	beq	r5,zero,b0023f0 <_fclose_r+0xa0>
 b0023dc:	80801004 	addi	r2,r16,64
 b0023e0:	28800226 	beq	r5,r2,b0023ec <_fclose_r+0x9c>
 b0023e4:	8809883a 	mov	r4,r17
 b0023e8:	b0028200 	call	b002820 <_free_r>
 b0023ec:	80000c15 	stw	zero,48(r16)
 b0023f0:	81401117 	ldw	r5,68(r16)
 b0023f4:	28000326 	beq	r5,zero,b002404 <_fclose_r+0xb4>
 b0023f8:	8809883a 	mov	r4,r17
 b0023fc:	b0028200 	call	b002820 <_free_r>
 b002400:	80001115 	stw	zero,68(r16)
 b002404:	b0007080 	call	b000708 <__sfp_lock_acquire>
 b002408:	8000030d 	sth	zero,12(r16)
 b00240c:	b00070c0 	call	b00070c <__sfp_lock_release>
 b002410:	9005883a 	mov	r2,r18
 b002414:	003fdc06 	br	b002388 <__alt_mem_flash+0xff001388>
 b002418:	b0006f80 	call	b0006f8 <__sinit>
 b00241c:	003fd706 	br	b00237c <__alt_mem_flash+0xff00137c>
 b002420:	04bfffc4 	movi	r18,-1
 b002424:	003fe806 	br	b0023c8 <__alt_mem_flash+0xff0013c8>
 b002428:	81400417 	ldw	r5,16(r16)
 b00242c:	8809883a 	mov	r4,r17
 b002430:	b0028200 	call	b002820 <_free_r>
 b002434:	003fe706 	br	b0023d4 <__alt_mem_flash+0xff0013d4>
 b002438:	0005883a 	mov	r2,zero
 b00243c:	f800283a 	ret

0b002440 <fclose>:
 b002440:	0082c074 	movhi	r2,2817
 b002444:	10a48d04 	addi	r2,r2,-28108
 b002448:	200b883a 	mov	r5,r4
 b00244c:	11000017 	ldw	r4,0(r2)
 b002450:	b0023501 	jmpi	b002350 <_fclose_r>

0b002454 <__sflush_r>:
 b002454:	2880030b 	ldhu	r2,12(r5)
 b002458:	defffb04 	addi	sp,sp,-20
 b00245c:	dcc00315 	stw	r19,12(sp)
 b002460:	dc400115 	stw	r17,4(sp)
 b002464:	dfc00415 	stw	ra,16(sp)
 b002468:	dc800215 	stw	r18,8(sp)
 b00246c:	dc000015 	stw	r16,0(sp)
 b002470:	10c0020c 	andi	r3,r2,8
 b002474:	2823883a 	mov	r17,r5
 b002478:	2027883a 	mov	r19,r4
 b00247c:	1800311e 	bne	r3,zero,b002544 <__sflush_r+0xf0>
 b002480:	28c00117 	ldw	r3,4(r5)
 b002484:	10820014 	ori	r2,r2,2048
 b002488:	2880030d 	sth	r2,12(r5)
 b00248c:	00c04b0e 	bge	zero,r3,b0025bc <__sflush_r+0x168>
 b002490:	8a000a17 	ldw	r8,40(r17)
 b002494:	40002326 	beq	r8,zero,b002524 <__sflush_r+0xd0>
 b002498:	9c000017 	ldw	r16,0(r19)
 b00249c:	10c4000c 	andi	r3,r2,4096
 b0024a0:	98000015 	stw	zero,0(r19)
 b0024a4:	18004826 	beq	r3,zero,b0025c8 <__sflush_r+0x174>
 b0024a8:	89801417 	ldw	r6,80(r17)
 b0024ac:	10c0010c 	andi	r3,r2,4
 b0024b0:	18000626 	beq	r3,zero,b0024cc <__sflush_r+0x78>
 b0024b4:	88c00117 	ldw	r3,4(r17)
 b0024b8:	88800c17 	ldw	r2,48(r17)
 b0024bc:	30cdc83a 	sub	r6,r6,r3
 b0024c0:	10000226 	beq	r2,zero,b0024cc <__sflush_r+0x78>
 b0024c4:	88800f17 	ldw	r2,60(r17)
 b0024c8:	308dc83a 	sub	r6,r6,r2
 b0024cc:	89400717 	ldw	r5,28(r17)
 b0024d0:	000f883a 	mov	r7,zero
 b0024d4:	9809883a 	mov	r4,r19
 b0024d8:	403ee83a 	callr	r8
 b0024dc:	00ffffc4 	movi	r3,-1
 b0024e0:	10c04426 	beq	r2,r3,b0025f4 <__sflush_r+0x1a0>
 b0024e4:	88c0030b 	ldhu	r3,12(r17)
 b0024e8:	89000417 	ldw	r4,16(r17)
 b0024ec:	88000115 	stw	zero,4(r17)
 b0024f0:	197dffcc 	andi	r5,r3,63487
 b0024f4:	8940030d 	sth	r5,12(r17)
 b0024f8:	89000015 	stw	r4,0(r17)
 b0024fc:	18c4000c 	andi	r3,r3,4096
 b002500:	18002c1e 	bne	r3,zero,b0025b4 <__sflush_r+0x160>
 b002504:	89400c17 	ldw	r5,48(r17)
 b002508:	9c000015 	stw	r16,0(r19)
 b00250c:	28000526 	beq	r5,zero,b002524 <__sflush_r+0xd0>
 b002510:	88801004 	addi	r2,r17,64
 b002514:	28800226 	beq	r5,r2,b002520 <__sflush_r+0xcc>
 b002518:	9809883a 	mov	r4,r19
 b00251c:	b0028200 	call	b002820 <_free_r>
 b002520:	88000c15 	stw	zero,48(r17)
 b002524:	0005883a 	mov	r2,zero
 b002528:	dfc00417 	ldw	ra,16(sp)
 b00252c:	dcc00317 	ldw	r19,12(sp)
 b002530:	dc800217 	ldw	r18,8(sp)
 b002534:	dc400117 	ldw	r17,4(sp)
 b002538:	dc000017 	ldw	r16,0(sp)
 b00253c:	dec00504 	addi	sp,sp,20
 b002540:	f800283a 	ret
 b002544:	2c800417 	ldw	r18,16(r5)
 b002548:	903ff626 	beq	r18,zero,b002524 <__alt_mem_flash+0xff001524>
 b00254c:	2c000017 	ldw	r16,0(r5)
 b002550:	108000cc 	andi	r2,r2,3
 b002554:	2c800015 	stw	r18,0(r5)
 b002558:	84a1c83a 	sub	r16,r16,r18
 b00255c:	1000131e 	bne	r2,zero,b0025ac <__sflush_r+0x158>
 b002560:	28800517 	ldw	r2,20(r5)
 b002564:	88800215 	stw	r2,8(r17)
 b002568:	04000316 	blt	zero,r16,b002578 <__sflush_r+0x124>
 b00256c:	003fed06 	br	b002524 <__alt_mem_flash+0xff001524>
 b002570:	90a5883a 	add	r18,r18,r2
 b002574:	043feb0e 	bge	zero,r16,b002524 <__alt_mem_flash+0xff001524>
 b002578:	88800917 	ldw	r2,36(r17)
 b00257c:	89400717 	ldw	r5,28(r17)
 b002580:	800f883a 	mov	r7,r16
 b002584:	900d883a 	mov	r6,r18
 b002588:	9809883a 	mov	r4,r19
 b00258c:	103ee83a 	callr	r2
 b002590:	80a1c83a 	sub	r16,r16,r2
 b002594:	00bff616 	blt	zero,r2,b002570 <__alt_mem_flash+0xff001570>
 b002598:	88c0030b 	ldhu	r3,12(r17)
 b00259c:	00bfffc4 	movi	r2,-1
 b0025a0:	18c01014 	ori	r3,r3,64
 b0025a4:	88c0030d 	sth	r3,12(r17)
 b0025a8:	003fdf06 	br	b002528 <__alt_mem_flash+0xff001528>
 b0025ac:	0005883a 	mov	r2,zero
 b0025b0:	003fec06 	br	b002564 <__alt_mem_flash+0xff001564>
 b0025b4:	88801415 	stw	r2,80(r17)
 b0025b8:	003fd206 	br	b002504 <__alt_mem_flash+0xff001504>
 b0025bc:	28c00f17 	ldw	r3,60(r5)
 b0025c0:	00ffb316 	blt	zero,r3,b002490 <__alt_mem_flash+0xff001490>
 b0025c4:	003fd706 	br	b002524 <__alt_mem_flash+0xff001524>
 b0025c8:	89400717 	ldw	r5,28(r17)
 b0025cc:	000d883a 	mov	r6,zero
 b0025d0:	01c00044 	movi	r7,1
 b0025d4:	9809883a 	mov	r4,r19
 b0025d8:	403ee83a 	callr	r8
 b0025dc:	100d883a 	mov	r6,r2
 b0025e0:	00bfffc4 	movi	r2,-1
 b0025e4:	30801426 	beq	r6,r2,b002638 <__sflush_r+0x1e4>
 b0025e8:	8880030b 	ldhu	r2,12(r17)
 b0025ec:	8a000a17 	ldw	r8,40(r17)
 b0025f0:	003fae06 	br	b0024ac <__alt_mem_flash+0xff0014ac>
 b0025f4:	98c00017 	ldw	r3,0(r19)
 b0025f8:	183fba26 	beq	r3,zero,b0024e4 <__alt_mem_flash+0xff0014e4>
 b0025fc:	01000744 	movi	r4,29
 b002600:	19000626 	beq	r3,r4,b00261c <__sflush_r+0x1c8>
 b002604:	01000584 	movi	r4,22
 b002608:	19000426 	beq	r3,r4,b00261c <__sflush_r+0x1c8>
 b00260c:	88c0030b 	ldhu	r3,12(r17)
 b002610:	18c01014 	ori	r3,r3,64
 b002614:	88c0030d 	sth	r3,12(r17)
 b002618:	003fc306 	br	b002528 <__alt_mem_flash+0xff001528>
 b00261c:	8880030b 	ldhu	r2,12(r17)
 b002620:	88c00417 	ldw	r3,16(r17)
 b002624:	88000115 	stw	zero,4(r17)
 b002628:	10bdffcc 	andi	r2,r2,63487
 b00262c:	8880030d 	sth	r2,12(r17)
 b002630:	88c00015 	stw	r3,0(r17)
 b002634:	003fb306 	br	b002504 <__alt_mem_flash+0xff001504>
 b002638:	98800017 	ldw	r2,0(r19)
 b00263c:	103fea26 	beq	r2,zero,b0025e8 <__alt_mem_flash+0xff0015e8>
 b002640:	00c00744 	movi	r3,29
 b002644:	10c00226 	beq	r2,r3,b002650 <__sflush_r+0x1fc>
 b002648:	00c00584 	movi	r3,22
 b00264c:	10c0031e 	bne	r2,r3,b00265c <__sflush_r+0x208>
 b002650:	9c000015 	stw	r16,0(r19)
 b002654:	0005883a 	mov	r2,zero
 b002658:	003fb306 	br	b002528 <__alt_mem_flash+0xff001528>
 b00265c:	88c0030b 	ldhu	r3,12(r17)
 b002660:	3005883a 	mov	r2,r6
 b002664:	18c01014 	ori	r3,r3,64
 b002668:	88c0030d 	sth	r3,12(r17)
 b00266c:	003fae06 	br	b002528 <__alt_mem_flash+0xff001528>

0b002670 <_fflush_r>:
 b002670:	defffd04 	addi	sp,sp,-12
 b002674:	dc000115 	stw	r16,4(sp)
 b002678:	dfc00215 	stw	ra,8(sp)
 b00267c:	2021883a 	mov	r16,r4
 b002680:	20000226 	beq	r4,zero,b00268c <_fflush_r+0x1c>
 b002684:	20800e17 	ldw	r2,56(r4)
 b002688:	10000c26 	beq	r2,zero,b0026bc <_fflush_r+0x4c>
 b00268c:	2880030f 	ldh	r2,12(r5)
 b002690:	1000051e 	bne	r2,zero,b0026a8 <_fflush_r+0x38>
 b002694:	0005883a 	mov	r2,zero
 b002698:	dfc00217 	ldw	ra,8(sp)
 b00269c:	dc000117 	ldw	r16,4(sp)
 b0026a0:	dec00304 	addi	sp,sp,12
 b0026a4:	f800283a 	ret
 b0026a8:	8009883a 	mov	r4,r16
 b0026ac:	dfc00217 	ldw	ra,8(sp)
 b0026b0:	dc000117 	ldw	r16,4(sp)
 b0026b4:	dec00304 	addi	sp,sp,12
 b0026b8:	b0024541 	jmpi	b002454 <__sflush_r>
 b0026bc:	d9400015 	stw	r5,0(sp)
 b0026c0:	b0006f80 	call	b0006f8 <__sinit>
 b0026c4:	d9400017 	ldw	r5,0(sp)
 b0026c8:	003ff006 	br	b00268c <__alt_mem_flash+0xff00168c>

0b0026cc <fflush>:
 b0026cc:	20000526 	beq	r4,zero,b0026e4 <fflush+0x18>
 b0026d0:	0082c074 	movhi	r2,2817
 b0026d4:	10a48d04 	addi	r2,r2,-28108
 b0026d8:	200b883a 	mov	r5,r4
 b0026dc:	11000017 	ldw	r4,0(r2)
 b0026e0:	b0026701 	jmpi	b002670 <_fflush_r>
 b0026e4:	0082c074 	movhi	r2,2817
 b0026e8:	10a48c04 	addi	r2,r2,-28112
 b0026ec:	11000017 	ldw	r4,0(r2)
 b0026f0:	0142c034 	movhi	r5,2816
 b0026f4:	29499c04 	addi	r5,r5,9840
 b0026f8:	b000cd41 	jmpi	b000cd4 <_fwalk_reent>

0b0026fc <_malloc_trim_r>:
 b0026fc:	defffb04 	addi	sp,sp,-20
 b002700:	dcc00315 	stw	r19,12(sp)
 b002704:	04c2c034 	movhi	r19,2816
 b002708:	dc800215 	stw	r18,8(sp)
 b00270c:	dc400115 	stw	r17,4(sp)
 b002710:	dc000015 	stw	r16,0(sp)
 b002714:	dfc00415 	stw	ra,16(sp)
 b002718:	2821883a 	mov	r16,r5
 b00271c:	9cde9904 	addi	r19,r19,31332
 b002720:	2025883a 	mov	r18,r4
 b002724:	b0035d40 	call	b0035d4 <__malloc_lock>
 b002728:	98800217 	ldw	r2,8(r19)
 b00272c:	14400117 	ldw	r17,4(r2)
 b002730:	00bfff04 	movi	r2,-4
 b002734:	88a2703a 	and	r17,r17,r2
 b002738:	8c21c83a 	sub	r16,r17,r16
 b00273c:	8403fbc4 	addi	r16,r16,4079
 b002740:	8020d33a 	srli	r16,r16,12
 b002744:	0083ffc4 	movi	r2,4095
 b002748:	843fffc4 	addi	r16,r16,-1
 b00274c:	8020933a 	slli	r16,r16,12
 b002750:	1400060e 	bge	r2,r16,b00276c <_malloc_trim_r+0x70>
 b002754:	000b883a 	mov	r5,zero
 b002758:	9009883a 	mov	r4,r18
 b00275c:	b001fb80 	call	b001fb8 <_sbrk_r>
 b002760:	98c00217 	ldw	r3,8(r19)
 b002764:	1c47883a 	add	r3,r3,r17
 b002768:	10c00a26 	beq	r2,r3,b002794 <_malloc_trim_r+0x98>
 b00276c:	9009883a 	mov	r4,r18
 b002770:	b0035f80 	call	b0035f8 <__malloc_unlock>
 b002774:	0005883a 	mov	r2,zero
 b002778:	dfc00417 	ldw	ra,16(sp)
 b00277c:	dcc00317 	ldw	r19,12(sp)
 b002780:	dc800217 	ldw	r18,8(sp)
 b002784:	dc400117 	ldw	r17,4(sp)
 b002788:	dc000017 	ldw	r16,0(sp)
 b00278c:	dec00504 	addi	sp,sp,20
 b002790:	f800283a 	ret
 b002794:	040bc83a 	sub	r5,zero,r16
 b002798:	9009883a 	mov	r4,r18
 b00279c:	b001fb80 	call	b001fb8 <_sbrk_r>
 b0027a0:	00ffffc4 	movi	r3,-1
 b0027a4:	10c00d26 	beq	r2,r3,b0027dc <_malloc_trim_r+0xe0>
 b0027a8:	00c2c074 	movhi	r3,2817
 b0027ac:	18ebb304 	addi	r3,r3,-20788
 b0027b0:	18800017 	ldw	r2,0(r3)
 b0027b4:	99000217 	ldw	r4,8(r19)
 b0027b8:	8c23c83a 	sub	r17,r17,r16
 b0027bc:	8c400054 	ori	r17,r17,1
 b0027c0:	1421c83a 	sub	r16,r2,r16
 b0027c4:	24400115 	stw	r17,4(r4)
 b0027c8:	9009883a 	mov	r4,r18
 b0027cc:	1c000015 	stw	r16,0(r3)
 b0027d0:	b0035f80 	call	b0035f8 <__malloc_unlock>
 b0027d4:	00800044 	movi	r2,1
 b0027d8:	003fe706 	br	b002778 <__alt_mem_flash+0xff001778>
 b0027dc:	000b883a 	mov	r5,zero
 b0027e0:	9009883a 	mov	r4,r18
 b0027e4:	b001fb80 	call	b001fb8 <_sbrk_r>
 b0027e8:	99000217 	ldw	r4,8(r19)
 b0027ec:	014003c4 	movi	r5,15
 b0027f0:	1107c83a 	sub	r3,r2,r4
 b0027f4:	28ffdd0e 	bge	r5,r3,b00276c <__alt_mem_flash+0xff00176c>
 b0027f8:	0142c074 	movhi	r5,2817
 b0027fc:	29648e04 	addi	r5,r5,-28104
 b002800:	29400017 	ldw	r5,0(r5)
 b002804:	18c00054 	ori	r3,r3,1
 b002808:	20c00115 	stw	r3,4(r4)
 b00280c:	00c2c074 	movhi	r3,2817
 b002810:	1145c83a 	sub	r2,r2,r5
 b002814:	18ebb304 	addi	r3,r3,-20788
 b002818:	18800015 	stw	r2,0(r3)
 b00281c:	003fd306 	br	b00276c <__alt_mem_flash+0xff00176c>

0b002820 <_free_r>:
 b002820:	28004126 	beq	r5,zero,b002928 <_free_r+0x108>
 b002824:	defffd04 	addi	sp,sp,-12
 b002828:	dc400115 	stw	r17,4(sp)
 b00282c:	dc000015 	stw	r16,0(sp)
 b002830:	2023883a 	mov	r17,r4
 b002834:	2821883a 	mov	r16,r5
 b002838:	dfc00215 	stw	ra,8(sp)
 b00283c:	b0035d40 	call	b0035d4 <__malloc_lock>
 b002840:	81ffff17 	ldw	r7,-4(r16)
 b002844:	00bfff84 	movi	r2,-2
 b002848:	0102c034 	movhi	r4,2816
 b00284c:	81bffe04 	addi	r6,r16,-8
 b002850:	3884703a 	and	r2,r7,r2
 b002854:	211e9904 	addi	r4,r4,31332
 b002858:	308b883a 	add	r5,r6,r2
 b00285c:	2a400117 	ldw	r9,4(r5)
 b002860:	22000217 	ldw	r8,8(r4)
 b002864:	00ffff04 	movi	r3,-4
 b002868:	48c6703a 	and	r3,r9,r3
 b00286c:	2a005726 	beq	r5,r8,b0029cc <_free_r+0x1ac>
 b002870:	28c00115 	stw	r3,4(r5)
 b002874:	39c0004c 	andi	r7,r7,1
 b002878:	3800091e 	bne	r7,zero,b0028a0 <_free_r+0x80>
 b00287c:	823ffe17 	ldw	r8,-8(r16)
 b002880:	22400204 	addi	r9,r4,8
 b002884:	320dc83a 	sub	r6,r6,r8
 b002888:	31c00217 	ldw	r7,8(r6)
 b00288c:	1205883a 	add	r2,r2,r8
 b002890:	3a406526 	beq	r7,r9,b002a28 <_free_r+0x208>
 b002894:	32000317 	ldw	r8,12(r6)
 b002898:	3a000315 	stw	r8,12(r7)
 b00289c:	41c00215 	stw	r7,8(r8)
 b0028a0:	28cf883a 	add	r7,r5,r3
 b0028a4:	39c00117 	ldw	r7,4(r7)
 b0028a8:	39c0004c 	andi	r7,r7,1
 b0028ac:	38003a26 	beq	r7,zero,b002998 <_free_r+0x178>
 b0028b0:	10c00054 	ori	r3,r2,1
 b0028b4:	30c00115 	stw	r3,4(r6)
 b0028b8:	3087883a 	add	r3,r6,r2
 b0028bc:	18800015 	stw	r2,0(r3)
 b0028c0:	00c07fc4 	movi	r3,511
 b0028c4:	18801936 	bltu	r3,r2,b00292c <_free_r+0x10c>
 b0028c8:	1004d0fa 	srli	r2,r2,3
 b0028cc:	01c00044 	movi	r7,1
 b0028d0:	21400117 	ldw	r5,4(r4)
 b0028d4:	10c00044 	addi	r3,r2,1
 b0028d8:	18c7883a 	add	r3,r3,r3
 b0028dc:	1005d0ba 	srai	r2,r2,2
 b0028e0:	18c7883a 	add	r3,r3,r3
 b0028e4:	18c7883a 	add	r3,r3,r3
 b0028e8:	1907883a 	add	r3,r3,r4
 b0028ec:	3884983a 	sll	r2,r7,r2
 b0028f0:	19c00017 	ldw	r7,0(r3)
 b0028f4:	1a3ffe04 	addi	r8,r3,-8
 b0028f8:	1144b03a 	or	r2,r2,r5
 b0028fc:	32000315 	stw	r8,12(r6)
 b002900:	31c00215 	stw	r7,8(r6)
 b002904:	20800115 	stw	r2,4(r4)
 b002908:	19800015 	stw	r6,0(r3)
 b00290c:	39800315 	stw	r6,12(r7)
 b002910:	8809883a 	mov	r4,r17
 b002914:	dfc00217 	ldw	ra,8(sp)
 b002918:	dc400117 	ldw	r17,4(sp)
 b00291c:	dc000017 	ldw	r16,0(sp)
 b002920:	dec00304 	addi	sp,sp,12
 b002924:	b0035f81 	jmpi	b0035f8 <__malloc_unlock>
 b002928:	f800283a 	ret
 b00292c:	100ad27a 	srli	r5,r2,9
 b002930:	00c00104 	movi	r3,4
 b002934:	19404a36 	bltu	r3,r5,b002a60 <_free_r+0x240>
 b002938:	100ad1ba 	srli	r5,r2,6
 b00293c:	28c00e44 	addi	r3,r5,57
 b002940:	18c7883a 	add	r3,r3,r3
 b002944:	29400e04 	addi	r5,r5,56
 b002948:	18c7883a 	add	r3,r3,r3
 b00294c:	18c7883a 	add	r3,r3,r3
 b002950:	1909883a 	add	r4,r3,r4
 b002954:	20c00017 	ldw	r3,0(r4)
 b002958:	01c2c034 	movhi	r7,2816
 b00295c:	213ffe04 	addi	r4,r4,-8
 b002960:	39de9904 	addi	r7,r7,31332
 b002964:	20c04426 	beq	r4,r3,b002a78 <_free_r+0x258>
 b002968:	01ffff04 	movi	r7,-4
 b00296c:	19400117 	ldw	r5,4(r3)
 b002970:	29ca703a 	and	r5,r5,r7
 b002974:	1140022e 	bgeu	r2,r5,b002980 <_free_r+0x160>
 b002978:	18c00217 	ldw	r3,8(r3)
 b00297c:	20fffb1e 	bne	r4,r3,b00296c <__alt_mem_flash+0xff00196c>
 b002980:	19000317 	ldw	r4,12(r3)
 b002984:	31000315 	stw	r4,12(r6)
 b002988:	30c00215 	stw	r3,8(r6)
 b00298c:	21800215 	stw	r6,8(r4)
 b002990:	19800315 	stw	r6,12(r3)
 b002994:	003fde06 	br	b002910 <__alt_mem_flash+0xff001910>
 b002998:	29c00217 	ldw	r7,8(r5)
 b00299c:	10c5883a 	add	r2,r2,r3
 b0029a0:	00c2c034 	movhi	r3,2816
 b0029a4:	18de9b04 	addi	r3,r3,31340
 b0029a8:	38c03b26 	beq	r7,r3,b002a98 <_free_r+0x278>
 b0029ac:	2a000317 	ldw	r8,12(r5)
 b0029b0:	11400054 	ori	r5,r2,1
 b0029b4:	3087883a 	add	r3,r6,r2
 b0029b8:	3a000315 	stw	r8,12(r7)
 b0029bc:	41c00215 	stw	r7,8(r8)
 b0029c0:	31400115 	stw	r5,4(r6)
 b0029c4:	18800015 	stw	r2,0(r3)
 b0029c8:	003fbd06 	br	b0028c0 <__alt_mem_flash+0xff0018c0>
 b0029cc:	39c0004c 	andi	r7,r7,1
 b0029d0:	10c5883a 	add	r2,r2,r3
 b0029d4:	3800071e 	bne	r7,zero,b0029f4 <_free_r+0x1d4>
 b0029d8:	81fffe17 	ldw	r7,-8(r16)
 b0029dc:	31cdc83a 	sub	r6,r6,r7
 b0029e0:	30c00317 	ldw	r3,12(r6)
 b0029e4:	31400217 	ldw	r5,8(r6)
 b0029e8:	11c5883a 	add	r2,r2,r7
 b0029ec:	28c00315 	stw	r3,12(r5)
 b0029f0:	19400215 	stw	r5,8(r3)
 b0029f4:	10c00054 	ori	r3,r2,1
 b0029f8:	30c00115 	stw	r3,4(r6)
 b0029fc:	00c2c074 	movhi	r3,2817
 b002a00:	18e48f04 	addi	r3,r3,-28100
 b002a04:	18c00017 	ldw	r3,0(r3)
 b002a08:	21800215 	stw	r6,8(r4)
 b002a0c:	10ffc036 	bltu	r2,r3,b002910 <__alt_mem_flash+0xff001910>
 b002a10:	0082c074 	movhi	r2,2817
 b002a14:	10abaa04 	addi	r2,r2,-20824
 b002a18:	11400017 	ldw	r5,0(r2)
 b002a1c:	8809883a 	mov	r4,r17
 b002a20:	b0026fc0 	call	b0026fc <_malloc_trim_r>
 b002a24:	003fba06 	br	b002910 <__alt_mem_flash+0xff001910>
 b002a28:	28c9883a 	add	r4,r5,r3
 b002a2c:	21000117 	ldw	r4,4(r4)
 b002a30:	2100004c 	andi	r4,r4,1
 b002a34:	2000391e 	bne	r4,zero,b002b1c <_free_r+0x2fc>
 b002a38:	29c00217 	ldw	r7,8(r5)
 b002a3c:	29000317 	ldw	r4,12(r5)
 b002a40:	1885883a 	add	r2,r3,r2
 b002a44:	10c00054 	ori	r3,r2,1
 b002a48:	39000315 	stw	r4,12(r7)
 b002a4c:	21c00215 	stw	r7,8(r4)
 b002a50:	30c00115 	stw	r3,4(r6)
 b002a54:	308d883a 	add	r6,r6,r2
 b002a58:	30800015 	stw	r2,0(r6)
 b002a5c:	003fac06 	br	b002910 <__alt_mem_flash+0xff001910>
 b002a60:	00c00504 	movi	r3,20
 b002a64:	19401536 	bltu	r3,r5,b002abc <_free_r+0x29c>
 b002a68:	28c01704 	addi	r3,r5,92
 b002a6c:	18c7883a 	add	r3,r3,r3
 b002a70:	294016c4 	addi	r5,r5,91
 b002a74:	003fb406 	br	b002948 <__alt_mem_flash+0xff001948>
 b002a78:	280bd0ba 	srai	r5,r5,2
 b002a7c:	00c00044 	movi	r3,1
 b002a80:	38800117 	ldw	r2,4(r7)
 b002a84:	194a983a 	sll	r5,r3,r5
 b002a88:	2007883a 	mov	r3,r4
 b002a8c:	2884b03a 	or	r2,r5,r2
 b002a90:	38800115 	stw	r2,4(r7)
 b002a94:	003fbb06 	br	b002984 <__alt_mem_flash+0xff001984>
 b002a98:	21800515 	stw	r6,20(r4)
 b002a9c:	21800415 	stw	r6,16(r4)
 b002aa0:	10c00054 	ori	r3,r2,1
 b002aa4:	31c00315 	stw	r7,12(r6)
 b002aa8:	31c00215 	stw	r7,8(r6)
 b002aac:	30c00115 	stw	r3,4(r6)
 b002ab0:	308d883a 	add	r6,r6,r2
 b002ab4:	30800015 	stw	r2,0(r6)
 b002ab8:	003f9506 	br	b002910 <__alt_mem_flash+0xff001910>
 b002abc:	00c01504 	movi	r3,84
 b002ac0:	19400536 	bltu	r3,r5,b002ad8 <_free_r+0x2b8>
 b002ac4:	100ad33a 	srli	r5,r2,12
 b002ac8:	28c01bc4 	addi	r3,r5,111
 b002acc:	18c7883a 	add	r3,r3,r3
 b002ad0:	29401b84 	addi	r5,r5,110
 b002ad4:	003f9c06 	br	b002948 <__alt_mem_flash+0xff001948>
 b002ad8:	00c05504 	movi	r3,340
 b002adc:	19400536 	bltu	r3,r5,b002af4 <_free_r+0x2d4>
 b002ae0:	100ad3fa 	srli	r5,r2,15
 b002ae4:	28c01e04 	addi	r3,r5,120
 b002ae8:	18c7883a 	add	r3,r3,r3
 b002aec:	29401dc4 	addi	r5,r5,119
 b002af0:	003f9506 	br	b002948 <__alt_mem_flash+0xff001948>
 b002af4:	00c15504 	movi	r3,1364
 b002af8:	19400536 	bltu	r3,r5,b002b10 <_free_r+0x2f0>
 b002afc:	100ad4ba 	srli	r5,r2,18
 b002b00:	28c01f44 	addi	r3,r5,125
 b002b04:	18c7883a 	add	r3,r3,r3
 b002b08:	29401f04 	addi	r5,r5,124
 b002b0c:	003f8e06 	br	b002948 <__alt_mem_flash+0xff001948>
 b002b10:	00c03f84 	movi	r3,254
 b002b14:	01401f84 	movi	r5,126
 b002b18:	003f8b06 	br	b002948 <__alt_mem_flash+0xff001948>
 b002b1c:	10c00054 	ori	r3,r2,1
 b002b20:	30c00115 	stw	r3,4(r6)
 b002b24:	308d883a 	add	r6,r6,r2
 b002b28:	30800015 	stw	r2,0(r6)
 b002b2c:	003f7806 	br	b002910 <__alt_mem_flash+0xff001910>

0b002b30 <_lseek_r>:
 b002b30:	defffd04 	addi	sp,sp,-12
 b002b34:	2805883a 	mov	r2,r5
 b002b38:	dc000015 	stw	r16,0(sp)
 b002b3c:	0402c074 	movhi	r16,2817
 b002b40:	dc400115 	stw	r17,4(sp)
 b002b44:	300b883a 	mov	r5,r6
 b002b48:	842bab04 	addi	r16,r16,-20820
 b002b4c:	2023883a 	mov	r17,r4
 b002b50:	380d883a 	mov	r6,r7
 b002b54:	1009883a 	mov	r4,r2
 b002b58:	dfc00215 	stw	ra,8(sp)
 b002b5c:	80000015 	stw	zero,0(r16)
 b002b60:	b00347c0 	call	b00347c <lseek>
 b002b64:	00ffffc4 	movi	r3,-1
 b002b68:	10c00526 	beq	r2,r3,b002b80 <_lseek_r+0x50>
 b002b6c:	dfc00217 	ldw	ra,8(sp)
 b002b70:	dc400117 	ldw	r17,4(sp)
 b002b74:	dc000017 	ldw	r16,0(sp)
 b002b78:	dec00304 	addi	sp,sp,12
 b002b7c:	f800283a 	ret
 b002b80:	80c00017 	ldw	r3,0(r16)
 b002b84:	183ff926 	beq	r3,zero,b002b6c <__alt_mem_flash+0xff001b6c>
 b002b88:	88c00015 	stw	r3,0(r17)
 b002b8c:	003ff706 	br	b002b6c <__alt_mem_flash+0xff001b6c>

0b002b90 <__smakebuf_r>:
 b002b90:	2880030b 	ldhu	r2,12(r5)
 b002b94:	10c0008c 	andi	r3,r2,2
 b002b98:	1800411e 	bne	r3,zero,b002ca0 <__smakebuf_r+0x110>
 b002b9c:	deffec04 	addi	sp,sp,-80
 b002ba0:	dc000f15 	stw	r16,60(sp)
 b002ba4:	2821883a 	mov	r16,r5
 b002ba8:	2940038f 	ldh	r5,14(r5)
 b002bac:	dc401015 	stw	r17,64(sp)
 b002bb0:	dfc01315 	stw	ra,76(sp)
 b002bb4:	dcc01215 	stw	r19,72(sp)
 b002bb8:	dc801115 	stw	r18,68(sp)
 b002bbc:	2023883a 	mov	r17,r4
 b002bc0:	28001c16 	blt	r5,zero,b002c34 <__smakebuf_r+0xa4>
 b002bc4:	d80d883a 	mov	r6,sp
 b002bc8:	b002dac0 	call	b002dac <_fstat_r>
 b002bcc:	10001816 	blt	r2,zero,b002c30 <__smakebuf_r+0xa0>
 b002bd0:	d8800117 	ldw	r2,4(sp)
 b002bd4:	00e00014 	movui	r3,32768
 b002bd8:	10bc000c 	andi	r2,r2,61440
 b002bdc:	14c80020 	cmpeqi	r19,r2,8192
 b002be0:	10c03726 	beq	r2,r3,b002cc0 <__smakebuf_r+0x130>
 b002be4:	80c0030b 	ldhu	r3,12(r16)
 b002be8:	18c20014 	ori	r3,r3,2048
 b002bec:	80c0030d 	sth	r3,12(r16)
 b002bf0:	00c80004 	movi	r3,8192
 b002bf4:	10c0521e 	bne	r2,r3,b002d40 <__smakebuf_r+0x1b0>
 b002bf8:	8140038f 	ldh	r5,14(r16)
 b002bfc:	8809883a 	mov	r4,r17
 b002c00:	b002e080 	call	b002e08 <_isatty_r>
 b002c04:	10004c26 	beq	r2,zero,b002d38 <__smakebuf_r+0x1a8>
 b002c08:	8080030b 	ldhu	r2,12(r16)
 b002c0c:	80c010c4 	addi	r3,r16,67
 b002c10:	80c00015 	stw	r3,0(r16)
 b002c14:	10800054 	ori	r2,r2,1
 b002c18:	8080030d 	sth	r2,12(r16)
 b002c1c:	00800044 	movi	r2,1
 b002c20:	80c00415 	stw	r3,16(r16)
 b002c24:	80800515 	stw	r2,20(r16)
 b002c28:	04810004 	movi	r18,1024
 b002c2c:	00000706 	br	b002c4c <__smakebuf_r+0xbc>
 b002c30:	8080030b 	ldhu	r2,12(r16)
 b002c34:	10c0200c 	andi	r3,r2,128
 b002c38:	18001f1e 	bne	r3,zero,b002cb8 <__smakebuf_r+0x128>
 b002c3c:	04810004 	movi	r18,1024
 b002c40:	10820014 	ori	r2,r2,2048
 b002c44:	8080030d 	sth	r2,12(r16)
 b002c48:	0027883a 	mov	r19,zero
 b002c4c:	900b883a 	mov	r5,r18
 b002c50:	8809883a 	mov	r4,r17
 b002c54:	b000d980 	call	b000d98 <_malloc_r>
 b002c58:	10002c26 	beq	r2,zero,b002d0c <__smakebuf_r+0x17c>
 b002c5c:	80c0030b 	ldhu	r3,12(r16)
 b002c60:	0102c034 	movhi	r4,2816
 b002c64:	2100e804 	addi	r4,r4,928
 b002c68:	89000f15 	stw	r4,60(r17)
 b002c6c:	18c02014 	ori	r3,r3,128
 b002c70:	80c0030d 	sth	r3,12(r16)
 b002c74:	80800015 	stw	r2,0(r16)
 b002c78:	80800415 	stw	r2,16(r16)
 b002c7c:	84800515 	stw	r18,20(r16)
 b002c80:	98001a1e 	bne	r19,zero,b002cec <__smakebuf_r+0x15c>
 b002c84:	dfc01317 	ldw	ra,76(sp)
 b002c88:	dcc01217 	ldw	r19,72(sp)
 b002c8c:	dc801117 	ldw	r18,68(sp)
 b002c90:	dc401017 	ldw	r17,64(sp)
 b002c94:	dc000f17 	ldw	r16,60(sp)
 b002c98:	dec01404 	addi	sp,sp,80
 b002c9c:	f800283a 	ret
 b002ca0:	288010c4 	addi	r2,r5,67
 b002ca4:	28800015 	stw	r2,0(r5)
 b002ca8:	28800415 	stw	r2,16(r5)
 b002cac:	00800044 	movi	r2,1
 b002cb0:	28800515 	stw	r2,20(r5)
 b002cb4:	f800283a 	ret
 b002cb8:	04801004 	movi	r18,64
 b002cbc:	003fe006 	br	b002c40 <__alt_mem_flash+0xff001c40>
 b002cc0:	81000a17 	ldw	r4,40(r16)
 b002cc4:	00c2c034 	movhi	r3,2816
 b002cc8:	18c83904 	addi	r3,r3,8420
 b002ccc:	20ffc51e 	bne	r4,r3,b002be4 <__alt_mem_flash+0xff001be4>
 b002cd0:	8080030b 	ldhu	r2,12(r16)
 b002cd4:	04810004 	movi	r18,1024
 b002cd8:	84801315 	stw	r18,76(r16)
 b002cdc:	1484b03a 	or	r2,r2,r18
 b002ce0:	8080030d 	sth	r2,12(r16)
 b002ce4:	0027883a 	mov	r19,zero
 b002ce8:	003fd806 	br	b002c4c <__alt_mem_flash+0xff001c4c>
 b002cec:	8140038f 	ldh	r5,14(r16)
 b002cf0:	8809883a 	mov	r4,r17
 b002cf4:	b002e080 	call	b002e08 <_isatty_r>
 b002cf8:	103fe226 	beq	r2,zero,b002c84 <__alt_mem_flash+0xff001c84>
 b002cfc:	8080030b 	ldhu	r2,12(r16)
 b002d00:	10800054 	ori	r2,r2,1
 b002d04:	8080030d 	sth	r2,12(r16)
 b002d08:	003fde06 	br	b002c84 <__alt_mem_flash+0xff001c84>
 b002d0c:	8080030b 	ldhu	r2,12(r16)
 b002d10:	10c0800c 	andi	r3,r2,512
 b002d14:	183fdb1e 	bne	r3,zero,b002c84 <__alt_mem_flash+0xff001c84>
 b002d18:	10800094 	ori	r2,r2,2
 b002d1c:	80c010c4 	addi	r3,r16,67
 b002d20:	8080030d 	sth	r2,12(r16)
 b002d24:	00800044 	movi	r2,1
 b002d28:	80c00015 	stw	r3,0(r16)
 b002d2c:	80c00415 	stw	r3,16(r16)
 b002d30:	80800515 	stw	r2,20(r16)
 b002d34:	003fd306 	br	b002c84 <__alt_mem_flash+0xff001c84>
 b002d38:	04810004 	movi	r18,1024
 b002d3c:	003fc306 	br	b002c4c <__alt_mem_flash+0xff001c4c>
 b002d40:	0027883a 	mov	r19,zero
 b002d44:	04810004 	movi	r18,1024
 b002d48:	003fc006 	br	b002c4c <__alt_mem_flash+0xff001c4c>

0b002d4c <_read_r>:
 b002d4c:	defffd04 	addi	sp,sp,-12
 b002d50:	2805883a 	mov	r2,r5
 b002d54:	dc000015 	stw	r16,0(sp)
 b002d58:	0402c074 	movhi	r16,2817
 b002d5c:	dc400115 	stw	r17,4(sp)
 b002d60:	300b883a 	mov	r5,r6
 b002d64:	842bab04 	addi	r16,r16,-20820
 b002d68:	2023883a 	mov	r17,r4
 b002d6c:	380d883a 	mov	r6,r7
 b002d70:	1009883a 	mov	r4,r2
 b002d74:	dfc00215 	stw	ra,8(sp)
 b002d78:	80000015 	stw	zero,0(r16)
 b002d7c:	b0036580 	call	b003658 <read>
 b002d80:	00ffffc4 	movi	r3,-1
 b002d84:	10c00526 	beq	r2,r3,b002d9c <_read_r+0x50>
 b002d88:	dfc00217 	ldw	ra,8(sp)
 b002d8c:	dc400117 	ldw	r17,4(sp)
 b002d90:	dc000017 	ldw	r16,0(sp)
 b002d94:	dec00304 	addi	sp,sp,12
 b002d98:	f800283a 	ret
 b002d9c:	80c00017 	ldw	r3,0(r16)
 b002da0:	183ff926 	beq	r3,zero,b002d88 <__alt_mem_flash+0xff001d88>
 b002da4:	88c00015 	stw	r3,0(r17)
 b002da8:	003ff706 	br	b002d88 <__alt_mem_flash+0xff001d88>

0b002dac <_fstat_r>:
 b002dac:	defffd04 	addi	sp,sp,-12
 b002db0:	2805883a 	mov	r2,r5
 b002db4:	dc000015 	stw	r16,0(sp)
 b002db8:	0402c074 	movhi	r16,2817
 b002dbc:	dc400115 	stw	r17,4(sp)
 b002dc0:	842bab04 	addi	r16,r16,-20820
 b002dc4:	2023883a 	mov	r17,r4
 b002dc8:	300b883a 	mov	r5,r6
 b002dcc:	1009883a 	mov	r4,r2
 b002dd0:	dfc00215 	stw	ra,8(sp)
 b002dd4:	80000015 	stw	zero,0(r16)
 b002dd8:	b0031b40 	call	b0031b4 <fstat>
 b002ddc:	00ffffc4 	movi	r3,-1
 b002de0:	10c00526 	beq	r2,r3,b002df8 <_fstat_r+0x4c>
 b002de4:	dfc00217 	ldw	ra,8(sp)
 b002de8:	dc400117 	ldw	r17,4(sp)
 b002dec:	dc000017 	ldw	r16,0(sp)
 b002df0:	dec00304 	addi	sp,sp,12
 b002df4:	f800283a 	ret
 b002df8:	80c00017 	ldw	r3,0(r16)
 b002dfc:	183ff926 	beq	r3,zero,b002de4 <__alt_mem_flash+0xff001de4>
 b002e00:	88c00015 	stw	r3,0(r17)
 b002e04:	003ff706 	br	b002de4 <__alt_mem_flash+0xff001de4>

0b002e08 <_isatty_r>:
 b002e08:	defffd04 	addi	sp,sp,-12
 b002e0c:	dc000015 	stw	r16,0(sp)
 b002e10:	0402c074 	movhi	r16,2817
 b002e14:	dc400115 	stw	r17,4(sp)
 b002e18:	842bab04 	addi	r16,r16,-20820
 b002e1c:	2023883a 	mov	r17,r4
 b002e20:	2809883a 	mov	r4,r5
 b002e24:	dfc00215 	stw	ra,8(sp)
 b002e28:	80000015 	stw	zero,0(r16)
 b002e2c:	b0032a80 	call	b0032a8 <isatty>
 b002e30:	00ffffc4 	movi	r3,-1
 b002e34:	10c00526 	beq	r2,r3,b002e4c <_isatty_r+0x44>
 b002e38:	dfc00217 	ldw	ra,8(sp)
 b002e3c:	dc400117 	ldw	r17,4(sp)
 b002e40:	dc000017 	ldw	r16,0(sp)
 b002e44:	dec00304 	addi	sp,sp,12
 b002e48:	f800283a 	ret
 b002e4c:	80c00017 	ldw	r3,0(r16)
 b002e50:	183ff926 	beq	r3,zero,b002e38 <__alt_mem_flash+0xff001e38>
 b002e54:	88c00015 	stw	r3,0(r17)
 b002e58:	003ff706 	br	b002e38 <__alt_mem_flash+0xff001e38>

0b002e5c <__divsi3>:
 b002e5c:	20001b16 	blt	r4,zero,b002ecc <__divsi3+0x70>
 b002e60:	000f883a 	mov	r7,zero
 b002e64:	28001616 	blt	r5,zero,b002ec0 <__divsi3+0x64>
 b002e68:	200d883a 	mov	r6,r4
 b002e6c:	29001a2e 	bgeu	r5,r4,b002ed8 <__divsi3+0x7c>
 b002e70:	00800804 	movi	r2,32
 b002e74:	00c00044 	movi	r3,1
 b002e78:	00000106 	br	b002e80 <__divsi3+0x24>
 b002e7c:	10000d26 	beq	r2,zero,b002eb4 <__divsi3+0x58>
 b002e80:	294b883a 	add	r5,r5,r5
 b002e84:	10bfffc4 	addi	r2,r2,-1
 b002e88:	18c7883a 	add	r3,r3,r3
 b002e8c:	293ffb36 	bltu	r5,r4,b002e7c <__alt_mem_flash+0xff001e7c>
 b002e90:	0005883a 	mov	r2,zero
 b002e94:	18000726 	beq	r3,zero,b002eb4 <__divsi3+0x58>
 b002e98:	0005883a 	mov	r2,zero
 b002e9c:	31400236 	bltu	r6,r5,b002ea8 <__divsi3+0x4c>
 b002ea0:	314dc83a 	sub	r6,r6,r5
 b002ea4:	10c4b03a 	or	r2,r2,r3
 b002ea8:	1806d07a 	srli	r3,r3,1
 b002eac:	280ad07a 	srli	r5,r5,1
 b002eb0:	183ffa1e 	bne	r3,zero,b002e9c <__alt_mem_flash+0xff001e9c>
 b002eb4:	38000126 	beq	r7,zero,b002ebc <__divsi3+0x60>
 b002eb8:	0085c83a 	sub	r2,zero,r2
 b002ebc:	f800283a 	ret
 b002ec0:	014bc83a 	sub	r5,zero,r5
 b002ec4:	39c0005c 	xori	r7,r7,1
 b002ec8:	003fe706 	br	b002e68 <__alt_mem_flash+0xff001e68>
 b002ecc:	0109c83a 	sub	r4,zero,r4
 b002ed0:	01c00044 	movi	r7,1
 b002ed4:	003fe306 	br	b002e64 <__alt_mem_flash+0xff001e64>
 b002ed8:	00c00044 	movi	r3,1
 b002edc:	003fee06 	br	b002e98 <__alt_mem_flash+0xff001e98>

0b002ee0 <__modsi3>:
 b002ee0:	20001716 	blt	r4,zero,b002f40 <__modsi3+0x60>
 b002ee4:	000f883a 	mov	r7,zero
 b002ee8:	2005883a 	mov	r2,r4
 b002eec:	28001216 	blt	r5,zero,b002f38 <__modsi3+0x58>
 b002ef0:	2900162e 	bgeu	r5,r4,b002f4c <__modsi3+0x6c>
 b002ef4:	01800804 	movi	r6,32
 b002ef8:	00c00044 	movi	r3,1
 b002efc:	00000106 	br	b002f04 <__modsi3+0x24>
 b002f00:	30000a26 	beq	r6,zero,b002f2c <__modsi3+0x4c>
 b002f04:	294b883a 	add	r5,r5,r5
 b002f08:	31bfffc4 	addi	r6,r6,-1
 b002f0c:	18c7883a 	add	r3,r3,r3
 b002f10:	293ffb36 	bltu	r5,r4,b002f00 <__alt_mem_flash+0xff001f00>
 b002f14:	18000526 	beq	r3,zero,b002f2c <__modsi3+0x4c>
 b002f18:	1806d07a 	srli	r3,r3,1
 b002f1c:	11400136 	bltu	r2,r5,b002f24 <__modsi3+0x44>
 b002f20:	1145c83a 	sub	r2,r2,r5
 b002f24:	280ad07a 	srli	r5,r5,1
 b002f28:	183ffb1e 	bne	r3,zero,b002f18 <__alt_mem_flash+0xff001f18>
 b002f2c:	38000126 	beq	r7,zero,b002f34 <__modsi3+0x54>
 b002f30:	0085c83a 	sub	r2,zero,r2
 b002f34:	f800283a 	ret
 b002f38:	014bc83a 	sub	r5,zero,r5
 b002f3c:	003fec06 	br	b002ef0 <__alt_mem_flash+0xff001ef0>
 b002f40:	0109c83a 	sub	r4,zero,r4
 b002f44:	01c00044 	movi	r7,1
 b002f48:	003fe706 	br	b002ee8 <__alt_mem_flash+0xff001ee8>
 b002f4c:	00c00044 	movi	r3,1
 b002f50:	003ff106 	br	b002f18 <__alt_mem_flash+0xff001f18>

0b002f54 <__udivsi3>:
 b002f54:	200d883a 	mov	r6,r4
 b002f58:	2900152e 	bgeu	r5,r4,b002fb0 <__udivsi3+0x5c>
 b002f5c:	28001416 	blt	r5,zero,b002fb0 <__udivsi3+0x5c>
 b002f60:	00800804 	movi	r2,32
 b002f64:	00c00044 	movi	r3,1
 b002f68:	00000206 	br	b002f74 <__udivsi3+0x20>
 b002f6c:	10000e26 	beq	r2,zero,b002fa8 <__udivsi3+0x54>
 b002f70:	28000516 	blt	r5,zero,b002f88 <__udivsi3+0x34>
 b002f74:	294b883a 	add	r5,r5,r5
 b002f78:	10bfffc4 	addi	r2,r2,-1
 b002f7c:	18c7883a 	add	r3,r3,r3
 b002f80:	293ffa36 	bltu	r5,r4,b002f6c <__alt_mem_flash+0xff001f6c>
 b002f84:	18000826 	beq	r3,zero,b002fa8 <__udivsi3+0x54>
 b002f88:	0005883a 	mov	r2,zero
 b002f8c:	31400236 	bltu	r6,r5,b002f98 <__udivsi3+0x44>
 b002f90:	314dc83a 	sub	r6,r6,r5
 b002f94:	10c4b03a 	or	r2,r2,r3
 b002f98:	1806d07a 	srli	r3,r3,1
 b002f9c:	280ad07a 	srli	r5,r5,1
 b002fa0:	183ffa1e 	bne	r3,zero,b002f8c <__alt_mem_flash+0xff001f8c>
 b002fa4:	f800283a 	ret
 b002fa8:	0005883a 	mov	r2,zero
 b002fac:	f800283a 	ret
 b002fb0:	00c00044 	movi	r3,1
 b002fb4:	003ff406 	br	b002f88 <__alt_mem_flash+0xff001f88>

0b002fb8 <__umodsi3>:
 b002fb8:	2005883a 	mov	r2,r4
 b002fbc:	2900122e 	bgeu	r5,r4,b003008 <__umodsi3+0x50>
 b002fc0:	28001116 	blt	r5,zero,b003008 <__umodsi3+0x50>
 b002fc4:	01800804 	movi	r6,32
 b002fc8:	00c00044 	movi	r3,1
 b002fcc:	00000206 	br	b002fd8 <__umodsi3+0x20>
 b002fd0:	30000c26 	beq	r6,zero,b003004 <__umodsi3+0x4c>
 b002fd4:	28000516 	blt	r5,zero,b002fec <__umodsi3+0x34>
 b002fd8:	294b883a 	add	r5,r5,r5
 b002fdc:	31bfffc4 	addi	r6,r6,-1
 b002fe0:	18c7883a 	add	r3,r3,r3
 b002fe4:	293ffa36 	bltu	r5,r4,b002fd0 <__alt_mem_flash+0xff001fd0>
 b002fe8:	18000626 	beq	r3,zero,b003004 <__umodsi3+0x4c>
 b002fec:	1806d07a 	srli	r3,r3,1
 b002ff0:	11400136 	bltu	r2,r5,b002ff8 <__umodsi3+0x40>
 b002ff4:	1145c83a 	sub	r2,r2,r5
 b002ff8:	280ad07a 	srli	r5,r5,1
 b002ffc:	183ffb1e 	bne	r3,zero,b002fec <__alt_mem_flash+0xff001fec>
 b003000:	f800283a 	ret
 b003004:	f800283a 	ret
 b003008:	00c00044 	movi	r3,1
 b00300c:	003ff706 	br	b002fec <__alt_mem_flash+0xff001fec>

0b003010 <__mulsi3>:
 b003010:	0005883a 	mov	r2,zero
 b003014:	20000726 	beq	r4,zero,b003034 <__mulsi3+0x24>
 b003018:	20c0004c 	andi	r3,r4,1
 b00301c:	2008d07a 	srli	r4,r4,1
 b003020:	18000126 	beq	r3,zero,b003028 <__mulsi3+0x18>
 b003024:	1145883a 	add	r2,r2,r5
 b003028:	294b883a 	add	r5,r5,r5
 b00302c:	203ffa1e 	bne	r4,zero,b003018 <__alt_mem_flash+0xff002018>
 b003030:	f800283a 	ret
 b003034:	f800283a 	ret

0b003038 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 b003038:	defffe04 	addi	sp,sp,-8
 b00303c:	dfc00115 	stw	ra,4(sp)
 b003040:	df000015 	stw	fp,0(sp)
 b003044:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 b003048:	d0a00917 	ldw	r2,-32732(gp)
 b00304c:	10000326 	beq	r2,zero,b00305c <alt_get_errno+0x24>
 b003050:	d0a00917 	ldw	r2,-32732(gp)
 b003054:	103ee83a 	callr	r2
 b003058:	00000106 	br	b003060 <alt_get_errno+0x28>
 b00305c:	d0a71f04 	addi	r2,gp,-25476
}
 b003060:	e037883a 	mov	sp,fp
 b003064:	dfc00117 	ldw	ra,4(sp)
 b003068:	df000017 	ldw	fp,0(sp)
 b00306c:	dec00204 	addi	sp,sp,8
 b003070:	f800283a 	ret

0b003074 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
 b003074:	defffb04 	addi	sp,sp,-20
 b003078:	dfc00415 	stw	ra,16(sp)
 b00307c:	df000315 	stw	fp,12(sp)
 b003080:	df000304 	addi	fp,sp,12
 b003084:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
 b003088:	e0bfff17 	ldw	r2,-4(fp)
 b00308c:	10000816 	blt	r2,zero,b0030b0 <close+0x3c>
 b003090:	01400304 	movi	r5,12
 b003094:	e13fff17 	ldw	r4,-4(fp)
 b003098:	b0030100 	call	b003010 <__mulsi3>
 b00309c:	1007883a 	mov	r3,r2
 b0030a0:	0082c034 	movhi	r2,2816
 b0030a4:	109fa504 	addi	r2,r2,32404
 b0030a8:	1885883a 	add	r2,r3,r2
 b0030ac:	00000106 	br	b0030b4 <close+0x40>
 b0030b0:	0005883a 	mov	r2,zero
 b0030b4:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
 b0030b8:	e0bffd17 	ldw	r2,-12(fp)
 b0030bc:	10001926 	beq	r2,zero,b003124 <close+0xb0>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
 b0030c0:	e0bffd17 	ldw	r2,-12(fp)
 b0030c4:	10800017 	ldw	r2,0(r2)
 b0030c8:	10800417 	ldw	r2,16(r2)
 b0030cc:	10000626 	beq	r2,zero,b0030e8 <close+0x74>
 b0030d0:	e0bffd17 	ldw	r2,-12(fp)
 b0030d4:	10800017 	ldw	r2,0(r2)
 b0030d8:	10800417 	ldw	r2,16(r2)
 b0030dc:	e13ffd17 	ldw	r4,-12(fp)
 b0030e0:	103ee83a 	callr	r2
 b0030e4:	00000106 	br	b0030ec <close+0x78>
 b0030e8:	0005883a 	mov	r2,zero
 b0030ec:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
 b0030f0:	e13fff17 	ldw	r4,-4(fp)
 b0030f4:	b00375c0 	call	b00375c <alt_release_fd>
    if (rval < 0)
 b0030f8:	e0bffe17 	ldw	r2,-8(fp)
 b0030fc:	1000070e 	bge	r2,zero,b00311c <close+0xa8>
    {
      ALT_ERRNO = -rval;
 b003100:	b0030380 	call	b003038 <alt_get_errno>
 b003104:	1007883a 	mov	r3,r2
 b003108:	e0bffe17 	ldw	r2,-8(fp)
 b00310c:	0085c83a 	sub	r2,zero,r2
 b003110:	18800015 	stw	r2,0(r3)
      return -1;
 b003114:	00bfffc4 	movi	r2,-1
 b003118:	00000706 	br	b003138 <close+0xc4>
    }
    return 0;
 b00311c:	0005883a 	mov	r2,zero
 b003120:	00000506 	br	b003138 <close+0xc4>
  }
  else
  {
    ALT_ERRNO = EBADFD;
 b003124:	b0030380 	call	b003038 <alt_get_errno>
 b003128:	1007883a 	mov	r3,r2
 b00312c:	00801444 	movi	r2,81
 b003130:	18800015 	stw	r2,0(r3)
    return -1;
 b003134:	00bfffc4 	movi	r2,-1
  }
}
 b003138:	e037883a 	mov	sp,fp
 b00313c:	dfc00117 	ldw	ra,4(sp)
 b003140:	df000017 	ldw	fp,0(sp)
 b003144:	dec00204 	addi	sp,sp,8
 b003148:	f800283a 	ret

0b00314c <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
 b00314c:	defffc04 	addi	sp,sp,-16
 b003150:	df000315 	stw	fp,12(sp)
 b003154:	df000304 	addi	fp,sp,12
 b003158:	e13ffd15 	stw	r4,-12(fp)
 b00315c:	e17ffe15 	stw	r5,-8(fp)
 b003160:	e1bfff15 	stw	r6,-4(fp)
  return len;
 b003164:	e0bfff17 	ldw	r2,-4(fp)
}
 b003168:	e037883a 	mov	sp,fp
 b00316c:	df000017 	ldw	fp,0(sp)
 b003170:	dec00104 	addi	sp,sp,4
 b003174:	f800283a 	ret

0b003178 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 b003178:	defffe04 	addi	sp,sp,-8
 b00317c:	dfc00115 	stw	ra,4(sp)
 b003180:	df000015 	stw	fp,0(sp)
 b003184:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 b003188:	d0a00917 	ldw	r2,-32732(gp)
 b00318c:	10000326 	beq	r2,zero,b00319c <alt_get_errno+0x24>
 b003190:	d0a00917 	ldw	r2,-32732(gp)
 b003194:	103ee83a 	callr	r2
 b003198:	00000106 	br	b0031a0 <alt_get_errno+0x28>
 b00319c:	d0a71f04 	addi	r2,gp,-25476
}
 b0031a0:	e037883a 	mov	sp,fp
 b0031a4:	dfc00117 	ldw	ra,4(sp)
 b0031a8:	df000017 	ldw	fp,0(sp)
 b0031ac:	dec00204 	addi	sp,sp,8
 b0031b0:	f800283a 	ret

0b0031b4 <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
 b0031b4:	defffb04 	addi	sp,sp,-20
 b0031b8:	dfc00415 	stw	ra,16(sp)
 b0031bc:	df000315 	stw	fp,12(sp)
 b0031c0:	df000304 	addi	fp,sp,12
 b0031c4:	e13ffe15 	stw	r4,-8(fp)
 b0031c8:	e17fff15 	stw	r5,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 b0031cc:	e0bffe17 	ldw	r2,-8(fp)
 b0031d0:	10000816 	blt	r2,zero,b0031f4 <fstat+0x40>
 b0031d4:	01400304 	movi	r5,12
 b0031d8:	e13ffe17 	ldw	r4,-8(fp)
 b0031dc:	b0030100 	call	b003010 <__mulsi3>
 b0031e0:	1007883a 	mov	r3,r2
 b0031e4:	0082c034 	movhi	r2,2816
 b0031e8:	109fa504 	addi	r2,r2,32404
 b0031ec:	1885883a 	add	r2,r3,r2
 b0031f0:	00000106 	br	b0031f8 <fstat+0x44>
 b0031f4:	0005883a 	mov	r2,zero
 b0031f8:	e0bffd15 	stw	r2,-12(fp)
  
  if (fd)
 b0031fc:	e0bffd17 	ldw	r2,-12(fp)
 b003200:	10001026 	beq	r2,zero,b003244 <fstat+0x90>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
 b003204:	e0bffd17 	ldw	r2,-12(fp)
 b003208:	10800017 	ldw	r2,0(r2)
 b00320c:	10800817 	ldw	r2,32(r2)
 b003210:	10000726 	beq	r2,zero,b003230 <fstat+0x7c>
    {
      return fd->dev->fstat(fd, st);
 b003214:	e0bffd17 	ldw	r2,-12(fp)
 b003218:	10800017 	ldw	r2,0(r2)
 b00321c:	10800817 	ldw	r2,32(r2)
 b003220:	e17fff17 	ldw	r5,-4(fp)
 b003224:	e13ffd17 	ldw	r4,-12(fp)
 b003228:	103ee83a 	callr	r2
 b00322c:	00000a06 	br	b003258 <fstat+0xa4>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
 b003230:	e0bfff17 	ldw	r2,-4(fp)
 b003234:	00c80004 	movi	r3,8192
 b003238:	10c00115 	stw	r3,4(r2)
      return 0;
 b00323c:	0005883a 	mov	r2,zero
 b003240:	00000506 	br	b003258 <fstat+0xa4>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 b003244:	b0031780 	call	b003178 <alt_get_errno>
 b003248:	1007883a 	mov	r3,r2
 b00324c:	00801444 	movi	r2,81
 b003250:	18800015 	stw	r2,0(r3)
    return -1;
 b003254:	00bfffc4 	movi	r2,-1
  }
}
 b003258:	e037883a 	mov	sp,fp
 b00325c:	dfc00117 	ldw	ra,4(sp)
 b003260:	df000017 	ldw	fp,0(sp)
 b003264:	dec00204 	addi	sp,sp,8
 b003268:	f800283a 	ret

0b00326c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 b00326c:	defffe04 	addi	sp,sp,-8
 b003270:	dfc00115 	stw	ra,4(sp)
 b003274:	df000015 	stw	fp,0(sp)
 b003278:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 b00327c:	d0a00917 	ldw	r2,-32732(gp)
 b003280:	10000326 	beq	r2,zero,b003290 <alt_get_errno+0x24>
 b003284:	d0a00917 	ldw	r2,-32732(gp)
 b003288:	103ee83a 	callr	r2
 b00328c:	00000106 	br	b003294 <alt_get_errno+0x28>
 b003290:	d0a71f04 	addi	r2,gp,-25476
}
 b003294:	e037883a 	mov	sp,fp
 b003298:	dfc00117 	ldw	ra,4(sp)
 b00329c:	df000017 	ldw	fp,0(sp)
 b0032a0:	dec00204 	addi	sp,sp,8
 b0032a4:	f800283a 	ret

0b0032a8 <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
 b0032a8:	deffed04 	addi	sp,sp,-76
 b0032ac:	dfc01215 	stw	ra,72(sp)
 b0032b0:	df001115 	stw	fp,68(sp)
 b0032b4:	df001104 	addi	fp,sp,68
 b0032b8:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 b0032bc:	e0bfff17 	ldw	r2,-4(fp)
 b0032c0:	10000816 	blt	r2,zero,b0032e4 <isatty+0x3c>
 b0032c4:	01400304 	movi	r5,12
 b0032c8:	e13fff17 	ldw	r4,-4(fp)
 b0032cc:	b0030100 	call	b003010 <__mulsi3>
 b0032d0:	1007883a 	mov	r3,r2
 b0032d4:	0082c034 	movhi	r2,2816
 b0032d8:	109fa504 	addi	r2,r2,32404
 b0032dc:	1885883a 	add	r2,r3,r2
 b0032e0:	00000106 	br	b0032e8 <isatty+0x40>
 b0032e4:	0005883a 	mov	r2,zero
 b0032e8:	e0bfef15 	stw	r2,-68(fp)
  
  if (fd)
 b0032ec:	e0bfef17 	ldw	r2,-68(fp)
 b0032f0:	10000e26 	beq	r2,zero,b00332c <isatty+0x84>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
 b0032f4:	e0bfef17 	ldw	r2,-68(fp)
 b0032f8:	10800017 	ldw	r2,0(r2)
 b0032fc:	10800817 	ldw	r2,32(r2)
 b003300:	1000021e 	bne	r2,zero,b00330c <isatty+0x64>
    {
      return 1;
 b003304:	00800044 	movi	r2,1
 b003308:	00000d06 	br	b003340 <isatty+0x98>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
 b00330c:	e0bff004 	addi	r2,fp,-64
 b003310:	100b883a 	mov	r5,r2
 b003314:	e13fff17 	ldw	r4,-4(fp)
 b003318:	b0031b40 	call	b0031b4 <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
 b00331c:	e0bff117 	ldw	r2,-60(fp)
 b003320:	10880020 	cmpeqi	r2,r2,8192
 b003324:	10803fcc 	andi	r2,r2,255
 b003328:	00000506 	br	b003340 <isatty+0x98>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 b00332c:	b00326c0 	call	b00326c <alt_get_errno>
 b003330:	1007883a 	mov	r3,r2
 b003334:	00801444 	movi	r2,81
 b003338:	18800015 	stw	r2,0(r3)
    return 0;
 b00333c:	0005883a 	mov	r2,zero
  }
}
 b003340:	e037883a 	mov	sp,fp
 b003344:	dfc00117 	ldw	ra,4(sp)
 b003348:	df000017 	ldw	fp,0(sp)
 b00334c:	dec00204 	addi	sp,sp,8
 b003350:	f800283a 	ret

0b003354 <alt_load_section>:
 */

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
 b003354:	defffc04 	addi	sp,sp,-16
 b003358:	df000315 	stw	fp,12(sp)
 b00335c:	df000304 	addi	fp,sp,12
 b003360:	e13ffd15 	stw	r4,-12(fp)
 b003364:	e17ffe15 	stw	r5,-8(fp)
 b003368:	e1bfff15 	stw	r6,-4(fp)
  if (to != from)
 b00336c:	e0fffe17 	ldw	r3,-8(fp)
 b003370:	e0bffd17 	ldw	r2,-12(fp)
 b003374:	18800c26 	beq	r3,r2,b0033a8 <alt_load_section+0x54>
  {
    while( to != end )
 b003378:	00000806 	br	b00339c <alt_load_section+0x48>
    {
      *to++ = *from++;
 b00337c:	e0bffe17 	ldw	r2,-8(fp)
 b003380:	10c00104 	addi	r3,r2,4
 b003384:	e0fffe15 	stw	r3,-8(fp)
 b003388:	e0fffd17 	ldw	r3,-12(fp)
 b00338c:	19000104 	addi	r4,r3,4
 b003390:	e13ffd15 	stw	r4,-12(fp)
 b003394:	18c00017 	ldw	r3,0(r3)
 b003398:	10c00015 	stw	r3,0(r2)
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
 b00339c:	e0fffe17 	ldw	r3,-8(fp)
 b0033a0:	e0bfff17 	ldw	r2,-4(fp)
 b0033a4:	18bff51e 	bne	r3,r2,b00337c <__alt_mem_flash+0xff00237c>
    {
      *to++ = *from++;
    }
  }
}
 b0033a8:	0001883a 	nop
 b0033ac:	e037883a 	mov	sp,fp
 b0033b0:	df000017 	ldw	fp,0(sp)
 b0033b4:	dec00104 	addi	sp,sp,4
 b0033b8:	f800283a 	ret

0b0033bc <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
 b0033bc:	defffe04 	addi	sp,sp,-8
 b0033c0:	dfc00115 	stw	ra,4(sp)
 b0033c4:	df000015 	stw	fp,0(sp)
 b0033c8:	d839883a 	mov	fp,sp
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
 b0033cc:	0182c074 	movhi	r6,2817
 b0033d0:	31a49c04 	addi	r6,r6,-28048
 b0033d4:	0142c034 	movhi	r5,2816
 b0033d8:	295d9004 	addi	r5,r5,30272
 b0033dc:	0102c074 	movhi	r4,2817
 b0033e0:	21249c04 	addi	r4,r4,-28048
 b0033e4:	b0033540 	call	b003354 <alt_load_section>

  /*
   * Copy the exception handler.
   */

  alt_load_section (&__flash_exceptions_start, 
 b0033e8:	0182c034 	movhi	r6,2816
 b0033ec:	31808404 	addi	r6,r6,528
 b0033f0:	0142c034 	movhi	r5,2816
 b0033f4:	29400004 	addi	r5,r5,0
 b0033f8:	0102c034 	movhi	r4,2816
 b0033fc:	21000004 	addi	r4,r4,0
 b003400:	b0033540 	call	b003354 <alt_load_section>

  /*
   * Copy the .rodata section.
   */

  alt_load_section (&__flash_rodata_start, 
 b003404:	0182c034 	movhi	r6,2816
 b003408:	319d9004 	addi	r6,r6,30272
 b00340c:	0142c034 	movhi	r5,2816
 b003410:	295d7504 	addi	r5,r5,30164
 b003414:	0102c034 	movhi	r4,2816
 b003418:	211d7504 	addi	r4,r4,30164
 b00341c:	b0033540 	call	b003354 <alt_load_section>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
 b003420:	b0061cc0 	call	b0061cc <alt_dcache_flush_all>
  alt_icache_flush_all();
 b003424:	b0064480 	call	b006448 <alt_icache_flush_all>
}
 b003428:	0001883a 	nop
 b00342c:	e037883a 	mov	sp,fp
 b003430:	dfc00117 	ldw	ra,4(sp)
 b003434:	df000017 	ldw	fp,0(sp)
 b003438:	dec00204 	addi	sp,sp,8
 b00343c:	f800283a 	ret

0b003440 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 b003440:	defffe04 	addi	sp,sp,-8
 b003444:	dfc00115 	stw	ra,4(sp)
 b003448:	df000015 	stw	fp,0(sp)
 b00344c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 b003450:	d0a00917 	ldw	r2,-32732(gp)
 b003454:	10000326 	beq	r2,zero,b003464 <alt_get_errno+0x24>
 b003458:	d0a00917 	ldw	r2,-32732(gp)
 b00345c:	103ee83a 	callr	r2
 b003460:	00000106 	br	b003468 <alt_get_errno+0x28>
 b003464:	d0a71f04 	addi	r2,gp,-25476
}
 b003468:	e037883a 	mov	sp,fp
 b00346c:	dfc00117 	ldw	ra,4(sp)
 b003470:	df000017 	ldw	fp,0(sp)
 b003474:	dec00204 	addi	sp,sp,8
 b003478:	f800283a 	ret

0b00347c <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
 b00347c:	defff904 	addi	sp,sp,-28
 b003480:	dfc00615 	stw	ra,24(sp)
 b003484:	df000515 	stw	fp,20(sp)
 b003488:	df000504 	addi	fp,sp,20
 b00348c:	e13ffd15 	stw	r4,-12(fp)
 b003490:	e17ffe15 	stw	r5,-8(fp)
 b003494:	e1bfff15 	stw	r6,-4(fp)
  alt_fd* fd;
  off_t   rc = 0; 
 b003498:	e03ffb15 	stw	zero,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 b00349c:	e0bffd17 	ldw	r2,-12(fp)
 b0034a0:	10000816 	blt	r2,zero,b0034c4 <lseek+0x48>
 b0034a4:	01400304 	movi	r5,12
 b0034a8:	e13ffd17 	ldw	r4,-12(fp)
 b0034ac:	b0030100 	call	b003010 <__mulsi3>
 b0034b0:	1007883a 	mov	r3,r2
 b0034b4:	0082c034 	movhi	r2,2816
 b0034b8:	109fa504 	addi	r2,r2,32404
 b0034bc:	1885883a 	add	r2,r3,r2
 b0034c0:	00000106 	br	b0034c8 <lseek+0x4c>
 b0034c4:	0005883a 	mov	r2,zero
 b0034c8:	e0bffc15 	stw	r2,-16(fp)
  
  if (fd) 
 b0034cc:	e0bffc17 	ldw	r2,-16(fp)
 b0034d0:	10001026 	beq	r2,zero,b003514 <lseek+0x98>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
 b0034d4:	e0bffc17 	ldw	r2,-16(fp)
 b0034d8:	10800017 	ldw	r2,0(r2)
 b0034dc:	10800717 	ldw	r2,28(r2)
 b0034e0:	10000926 	beq	r2,zero,b003508 <lseek+0x8c>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
 b0034e4:	e0bffc17 	ldw	r2,-16(fp)
 b0034e8:	10800017 	ldw	r2,0(r2)
 b0034ec:	10800717 	ldw	r2,28(r2)
 b0034f0:	e1bfff17 	ldw	r6,-4(fp)
 b0034f4:	e17ffe17 	ldw	r5,-8(fp)
 b0034f8:	e13ffc17 	ldw	r4,-16(fp)
 b0034fc:	103ee83a 	callr	r2
 b003500:	e0bffb15 	stw	r2,-20(fp)
 b003504:	00000506 	br	b00351c <lseek+0xa0>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
 b003508:	00bfde84 	movi	r2,-134
 b00350c:	e0bffb15 	stw	r2,-20(fp)
 b003510:	00000206 	br	b00351c <lseek+0xa0>
    }
  }
  else  
  {
    rc = -EBADFD;
 b003514:	00bfebc4 	movi	r2,-81
 b003518:	e0bffb15 	stw	r2,-20(fp)
  }

  if (rc < 0)
 b00351c:	e0bffb17 	ldw	r2,-20(fp)
 b003520:	1000070e 	bge	r2,zero,b003540 <lseek+0xc4>
  {
    ALT_ERRNO = -rc;
 b003524:	b0034400 	call	b003440 <alt_get_errno>
 b003528:	1007883a 	mov	r3,r2
 b00352c:	e0bffb17 	ldw	r2,-20(fp)
 b003530:	0085c83a 	sub	r2,zero,r2
 b003534:	18800015 	stw	r2,0(r3)
    rc = -1;
 b003538:	00bfffc4 	movi	r2,-1
 b00353c:	e0bffb15 	stw	r2,-20(fp)
  }

  return rc;
 b003540:	e0bffb17 	ldw	r2,-20(fp)
}
 b003544:	e037883a 	mov	sp,fp
 b003548:	dfc00117 	ldw	ra,4(sp)
 b00354c:	df000017 	ldw	fp,0(sp)
 b003550:	dec00204 	addi	sp,sp,8
 b003554:	f800283a 	ret

0b003558 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
 b003558:	defffd04 	addi	sp,sp,-12
 b00355c:	dfc00215 	stw	ra,8(sp)
 b003560:	df000115 	stw	fp,4(sp)
 b003564:	df000104 	addi	fp,sp,4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
 b003568:	0009883a 	mov	r4,zero
 b00356c:	b003a300 	call	b003a30 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
 b003570:	0001883a 	nop
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
 b003574:	b003a680 	call	b003a68 <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
 b003578:	0182c034 	movhi	r6,2816
 b00357c:	319d7d04 	addi	r6,r6,30196
 b003580:	0142c034 	movhi	r5,2816
 b003584:	295d7d04 	addi	r5,r5,30196
 b003588:	0102c034 	movhi	r4,2816
 b00358c:	211d7d04 	addi	r4,r4,30196
 b003590:	b0067ec0 	call	b0067ec <alt_io_redirect>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
 b003594:	b0062cc0 	call	b0062cc <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
 b003598:	0102c034 	movhi	r4,2816
 b00359c:	2118cb04 	addi	r4,r4,25388
 b0035a0:	b0071a80 	call	b0071a8 <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
 b0035a4:	d0a72017 	ldw	r2,-25472(gp)
 b0035a8:	d0e72117 	ldw	r3,-25468(gp)
 b0035ac:	d1272217 	ldw	r4,-25464(gp)
 b0035b0:	200d883a 	mov	r6,r4
 b0035b4:	180b883a 	mov	r5,r3
 b0035b8:	1009883a 	mov	r4,r2
 b0035bc:	b00024c0 	call	b00024c <main>
 b0035c0:	e0bfff15 	stw	r2,-4(fp)
  close(STDOUT_FILENO);
 b0035c4:	01000044 	movi	r4,1
 b0035c8:	b0030740 	call	b003074 <close>
  exit (result);
 b0035cc:	e13fff17 	ldw	r4,-4(fp)
 b0035d0:	b0071bc0 	call	b0071bc <exit>

0b0035d4 <__malloc_lock>:
 * configuration is single threaded, so there is nothing to do here. Note that 
 * this requires that malloc is never called by an interrupt service routine.
 */

void __malloc_lock ( struct _reent *_r )
{
 b0035d4:	defffe04 	addi	sp,sp,-8
 b0035d8:	df000115 	stw	fp,4(sp)
 b0035dc:	df000104 	addi	fp,sp,4
 b0035e0:	e13fff15 	stw	r4,-4(fp)
}
 b0035e4:	0001883a 	nop
 b0035e8:	e037883a 	mov	sp,fp
 b0035ec:	df000017 	ldw	fp,0(sp)
 b0035f0:	dec00104 	addi	sp,sp,4
 b0035f4:	f800283a 	ret

0b0035f8 <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
 b0035f8:	defffe04 	addi	sp,sp,-8
 b0035fc:	df000115 	stw	fp,4(sp)
 b003600:	df000104 	addi	fp,sp,4
 b003604:	e13fff15 	stw	r4,-4(fp)
}
 b003608:	0001883a 	nop
 b00360c:	e037883a 	mov	sp,fp
 b003610:	df000017 	ldw	fp,0(sp)
 b003614:	dec00104 	addi	sp,sp,4
 b003618:	f800283a 	ret

0b00361c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 b00361c:	defffe04 	addi	sp,sp,-8
 b003620:	dfc00115 	stw	ra,4(sp)
 b003624:	df000015 	stw	fp,0(sp)
 b003628:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 b00362c:	d0a00917 	ldw	r2,-32732(gp)
 b003630:	10000326 	beq	r2,zero,b003640 <alt_get_errno+0x24>
 b003634:	d0a00917 	ldw	r2,-32732(gp)
 b003638:	103ee83a 	callr	r2
 b00363c:	00000106 	br	b003644 <alt_get_errno+0x28>
 b003640:	d0a71f04 	addi	r2,gp,-25476
}
 b003644:	e037883a 	mov	sp,fp
 b003648:	dfc00117 	ldw	ra,4(sp)
 b00364c:	df000017 	ldw	fp,0(sp)
 b003650:	dec00204 	addi	sp,sp,8
 b003654:	f800283a 	ret

0b003658 <read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
 b003658:	defff904 	addi	sp,sp,-28
 b00365c:	dfc00615 	stw	ra,24(sp)
 b003660:	df000515 	stw	fp,20(sp)
 b003664:	df000504 	addi	fp,sp,20
 b003668:	e13ffd15 	stw	r4,-12(fp)
 b00366c:	e17ffe15 	stw	r5,-8(fp)
 b003670:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 b003674:	e0bffd17 	ldw	r2,-12(fp)
 b003678:	10000816 	blt	r2,zero,b00369c <read+0x44>
 b00367c:	01400304 	movi	r5,12
 b003680:	e13ffd17 	ldw	r4,-12(fp)
 b003684:	b0030100 	call	b003010 <__mulsi3>
 b003688:	1007883a 	mov	r3,r2
 b00368c:	0082c034 	movhi	r2,2816
 b003690:	109fa504 	addi	r2,r2,32404
 b003694:	1885883a 	add	r2,r3,r2
 b003698:	00000106 	br	b0036a0 <read+0x48>
 b00369c:	0005883a 	mov	r2,zero
 b0036a0:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
 b0036a4:	e0bffb17 	ldw	r2,-20(fp)
 b0036a8:	10002226 	beq	r2,zero,b003734 <read+0xdc>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
 b0036ac:	e0bffb17 	ldw	r2,-20(fp)
 b0036b0:	10800217 	ldw	r2,8(r2)
 b0036b4:	108000cc 	andi	r2,r2,3
 b0036b8:	10800060 	cmpeqi	r2,r2,1
 b0036bc:	1000181e 	bne	r2,zero,b003720 <read+0xc8>
        (fd->dev->read))
 b0036c0:	e0bffb17 	ldw	r2,-20(fp)
 b0036c4:	10800017 	ldw	r2,0(r2)
 b0036c8:	10800517 	ldw	r2,20(r2)
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
 b0036cc:	10001426 	beq	r2,zero,b003720 <read+0xc8>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
 b0036d0:	e0bffb17 	ldw	r2,-20(fp)
 b0036d4:	10800017 	ldw	r2,0(r2)
 b0036d8:	10800517 	ldw	r2,20(r2)
 b0036dc:	e0ffff17 	ldw	r3,-4(fp)
 b0036e0:	180d883a 	mov	r6,r3
 b0036e4:	e17ffe17 	ldw	r5,-8(fp)
 b0036e8:	e13ffb17 	ldw	r4,-20(fp)
 b0036ec:	103ee83a 	callr	r2
 b0036f0:	e0bffc15 	stw	r2,-16(fp)
 b0036f4:	e0bffc17 	ldw	r2,-16(fp)
 b0036f8:	1000070e 	bge	r2,zero,b003718 <read+0xc0>
        {
          ALT_ERRNO = -rval;
 b0036fc:	b00361c0 	call	b00361c <alt_get_errno>
 b003700:	1007883a 	mov	r3,r2
 b003704:	e0bffc17 	ldw	r2,-16(fp)
 b003708:	0085c83a 	sub	r2,zero,r2
 b00370c:	18800015 	stw	r2,0(r3)
          return -1;
 b003710:	00bfffc4 	movi	r2,-1
 b003714:	00000c06 	br	b003748 <read+0xf0>
        }
        return rval;
 b003718:	e0bffc17 	ldw	r2,-16(fp)
 b00371c:	00000a06 	br	b003748 <read+0xf0>
      }
      else
      {
        ALT_ERRNO = EACCES;
 b003720:	b00361c0 	call	b00361c <alt_get_errno>
 b003724:	1007883a 	mov	r3,r2
 b003728:	00800344 	movi	r2,13
 b00372c:	18800015 	stw	r2,0(r3)
 b003730:	00000406 	br	b003744 <read+0xec>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
 b003734:	b00361c0 	call	b00361c <alt_get_errno>
 b003738:	1007883a 	mov	r3,r2
 b00373c:	00801444 	movi	r2,81
 b003740:	18800015 	stw	r2,0(r3)
  }
  return -1;
 b003744:	00bfffc4 	movi	r2,-1
}
 b003748:	e037883a 	mov	sp,fp
 b00374c:	dfc00117 	ldw	ra,4(sp)
 b003750:	df000017 	ldw	fp,0(sp)
 b003754:	dec00204 	addi	sp,sp,8
 b003758:	f800283a 	ret

0b00375c <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
 b00375c:	defffc04 	addi	sp,sp,-16
 b003760:	dfc00315 	stw	ra,12(sp)
 b003764:	df000215 	stw	fp,8(sp)
 b003768:	dc000115 	stw	r16,4(sp)
 b00376c:	df000204 	addi	fp,sp,8
 b003770:	e13ffe15 	stw	r4,-8(fp)
  if (fd > 2)
 b003774:	e0bffe17 	ldw	r2,-8(fp)
 b003778:	108000d0 	cmplti	r2,r2,3
 b00377c:	1000111e 	bne	r2,zero,b0037c4 <alt_release_fd+0x68>
  {
    alt_fd_list[fd].fd_flags = 0;
 b003780:	0402c034 	movhi	r16,2816
 b003784:	841fa504 	addi	r16,r16,32404
 b003788:	e0bffe17 	ldw	r2,-8(fp)
 b00378c:	01400304 	movi	r5,12
 b003790:	1009883a 	mov	r4,r2
 b003794:	b0030100 	call	b003010 <__mulsi3>
 b003798:	8085883a 	add	r2,r16,r2
 b00379c:	10800204 	addi	r2,r2,8
 b0037a0:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
 b0037a4:	0402c034 	movhi	r16,2816
 b0037a8:	841fa504 	addi	r16,r16,32404
 b0037ac:	e0bffe17 	ldw	r2,-8(fp)
 b0037b0:	01400304 	movi	r5,12
 b0037b4:	1009883a 	mov	r4,r2
 b0037b8:	b0030100 	call	b003010 <__mulsi3>
 b0037bc:	8085883a 	add	r2,r16,r2
 b0037c0:	10000015 	stw	zero,0(r2)
  }
}
 b0037c4:	0001883a 	nop
 b0037c8:	e6ffff04 	addi	sp,fp,-4
 b0037cc:	dfc00217 	ldw	ra,8(sp)
 b0037d0:	df000117 	ldw	fp,4(sp)
 b0037d4:	dc000017 	ldw	r16,0(sp)
 b0037d8:	dec00304 	addi	sp,sp,12
 b0037dc:	f800283a 	ret

0b0037e0 <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
 b0037e0:	defff904 	addi	sp,sp,-28
 b0037e4:	df000615 	stw	fp,24(sp)
 b0037e8:	df000604 	addi	fp,sp,24
 b0037ec:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 b0037f0:	0005303a 	rdctl	r2,status
 b0037f4:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 b0037f8:	e0fffe17 	ldw	r3,-8(fp)
 b0037fc:	00bfff84 	movi	r2,-2
 b003800:	1884703a 	and	r2,r3,r2
 b003804:	1001703a 	wrctl	status,r2
  
  return context;
 b003808:	e0bffe17 	ldw	r2,-8(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
 b00380c:	e0bffb15 	stw	r2,-20(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
 b003810:	d0a00a17 	ldw	r2,-32728(gp)
 b003814:	10c000c4 	addi	r3,r2,3
 b003818:	00bfff04 	movi	r2,-4
 b00381c:	1884703a 	and	r2,r3,r2
 b003820:	d0a00a15 	stw	r2,-32728(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
 b003824:	d0e00a17 	ldw	r3,-32728(gp)
 b003828:	e0bfff17 	ldw	r2,-4(fp)
 b00382c:	1887883a 	add	r3,r3,r2
 b003830:	00830034 	movhi	r2,3072
 b003834:	10800004 	addi	r2,r2,0
 b003838:	10c0062e 	bgeu	r2,r3,b003854 <sbrk+0x74>
 b00383c:	e0bffb17 	ldw	r2,-20(fp)
 b003840:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 b003844:	e0bffa17 	ldw	r2,-24(fp)
 b003848:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
 b00384c:	00bfffc4 	movi	r2,-1
 b003850:	00000b06 	br	b003880 <sbrk+0xa0>
  }
#endif

  prev_heap_end = heap_end; 
 b003854:	d0a00a17 	ldw	r2,-32728(gp)
 b003858:	e0bffd15 	stw	r2,-12(fp)
  heap_end += incr; 
 b00385c:	d0e00a17 	ldw	r3,-32728(gp)
 b003860:	e0bfff17 	ldw	r2,-4(fp)
 b003864:	1885883a 	add	r2,r3,r2
 b003868:	d0a00a15 	stw	r2,-32728(gp)
 b00386c:	e0bffb17 	ldw	r2,-20(fp)
 b003870:	e0bffc15 	stw	r2,-16(fp)
 b003874:	e0bffc17 	ldw	r2,-16(fp)
 b003878:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
 b00387c:	e0bffd17 	ldw	r2,-12(fp)
} 
 b003880:	e037883a 	mov	sp,fp
 b003884:	df000017 	ldw	fp,0(sp)
 b003888:	dec00104 	addi	sp,sp,4
 b00388c:	f800283a 	ret

0b003890 <usleep>:
#if defined (__GNUC__) && __GNUC__ >= 4
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
 b003890:	defffd04 	addi	sp,sp,-12
 b003894:	dfc00215 	stw	ra,8(sp)
 b003898:	df000115 	stw	fp,4(sp)
 b00389c:	df000104 	addi	fp,sp,4
 b0038a0:	e13fff15 	stw	r4,-4(fp)
  return alt_busy_sleep(us);
 b0038a4:	e13fff17 	ldw	r4,-4(fp)
 b0038a8:	b0060740 	call	b006074 <alt_busy_sleep>
}
 b0038ac:	e037883a 	mov	sp,fp
 b0038b0:	dfc00117 	ldw	ra,4(sp)
 b0038b4:	df000017 	ldw	fp,0(sp)
 b0038b8:	dec00204 	addi	sp,sp,8
 b0038bc:	f800283a 	ret

0b0038c0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 b0038c0:	defffe04 	addi	sp,sp,-8
 b0038c4:	dfc00115 	stw	ra,4(sp)
 b0038c8:	df000015 	stw	fp,0(sp)
 b0038cc:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 b0038d0:	d0a00917 	ldw	r2,-32732(gp)
 b0038d4:	10000326 	beq	r2,zero,b0038e4 <alt_get_errno+0x24>
 b0038d8:	d0a00917 	ldw	r2,-32732(gp)
 b0038dc:	103ee83a 	callr	r2
 b0038e0:	00000106 	br	b0038e8 <alt_get_errno+0x28>
 b0038e4:	d0a71f04 	addi	r2,gp,-25476
}
 b0038e8:	e037883a 	mov	sp,fp
 b0038ec:	dfc00117 	ldw	ra,4(sp)
 b0038f0:	df000017 	ldw	fp,0(sp)
 b0038f4:	dec00204 	addi	sp,sp,8
 b0038f8:	f800283a 	ret

0b0038fc <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
 b0038fc:	defff904 	addi	sp,sp,-28
 b003900:	dfc00615 	stw	ra,24(sp)
 b003904:	df000515 	stw	fp,20(sp)
 b003908:	df000504 	addi	fp,sp,20
 b00390c:	e13ffd15 	stw	r4,-12(fp)
 b003910:	e17ffe15 	stw	r5,-8(fp)
 b003914:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 b003918:	e0bffd17 	ldw	r2,-12(fp)
 b00391c:	10000816 	blt	r2,zero,b003940 <write+0x44>
 b003920:	01400304 	movi	r5,12
 b003924:	e13ffd17 	ldw	r4,-12(fp)
 b003928:	b0030100 	call	b003010 <__mulsi3>
 b00392c:	1007883a 	mov	r3,r2
 b003930:	0082c034 	movhi	r2,2816
 b003934:	109fa504 	addi	r2,r2,32404
 b003938:	1885883a 	add	r2,r3,r2
 b00393c:	00000106 	br	b003944 <write+0x48>
 b003940:	0005883a 	mov	r2,zero
 b003944:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
 b003948:	e0bffb17 	ldw	r2,-20(fp)
 b00394c:	10002126 	beq	r2,zero,b0039d4 <write+0xd8>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
 b003950:	e0bffb17 	ldw	r2,-20(fp)
 b003954:	10800217 	ldw	r2,8(r2)
 b003958:	108000cc 	andi	r2,r2,3
 b00395c:	10001826 	beq	r2,zero,b0039c0 <write+0xc4>
 b003960:	e0bffb17 	ldw	r2,-20(fp)
 b003964:	10800017 	ldw	r2,0(r2)
 b003968:	10800617 	ldw	r2,24(r2)
 b00396c:	10001426 	beq	r2,zero,b0039c0 <write+0xc4>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
 b003970:	e0bffb17 	ldw	r2,-20(fp)
 b003974:	10800017 	ldw	r2,0(r2)
 b003978:	10800617 	ldw	r2,24(r2)
 b00397c:	e0ffff17 	ldw	r3,-4(fp)
 b003980:	180d883a 	mov	r6,r3
 b003984:	e17ffe17 	ldw	r5,-8(fp)
 b003988:	e13ffb17 	ldw	r4,-20(fp)
 b00398c:	103ee83a 	callr	r2
 b003990:	e0bffc15 	stw	r2,-16(fp)
 b003994:	e0bffc17 	ldw	r2,-16(fp)
 b003998:	1000070e 	bge	r2,zero,b0039b8 <write+0xbc>
      {
        ALT_ERRNO = -rval;
 b00399c:	b0038c00 	call	b0038c0 <alt_get_errno>
 b0039a0:	1007883a 	mov	r3,r2
 b0039a4:	e0bffc17 	ldw	r2,-16(fp)
 b0039a8:	0085c83a 	sub	r2,zero,r2
 b0039ac:	18800015 	stw	r2,0(r3)
        return -1;
 b0039b0:	00bfffc4 	movi	r2,-1
 b0039b4:	00000c06 	br	b0039e8 <write+0xec>
      }
      return rval;
 b0039b8:	e0bffc17 	ldw	r2,-16(fp)
 b0039bc:	00000a06 	br	b0039e8 <write+0xec>
    }
    else
    {
      ALT_ERRNO = EACCES;
 b0039c0:	b0038c00 	call	b0038c0 <alt_get_errno>
 b0039c4:	1007883a 	mov	r3,r2
 b0039c8:	00800344 	movi	r2,13
 b0039cc:	18800015 	stw	r2,0(r3)
 b0039d0:	00000406 	br	b0039e4 <write+0xe8>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
 b0039d4:	b0038c00 	call	b0038c0 <alt_get_errno>
 b0039d8:	1007883a 	mov	r3,r2
 b0039dc:	00801444 	movi	r2,81
 b0039e0:	18800015 	stw	r2,0(r3)
  }
  return -1;
 b0039e4:	00bfffc4 	movi	r2,-1
}
 b0039e8:	e037883a 	mov	sp,fp
 b0039ec:	dfc00117 	ldw	ra,4(sp)
 b0039f0:	df000017 	ldw	fp,0(sp)
 b0039f4:	dec00204 	addi	sp,sp,8
 b0039f8:	f800283a 	ret

0b0039fc <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
 b0039fc:	defffd04 	addi	sp,sp,-12
 b003a00:	dfc00215 	stw	ra,8(sp)
 b003a04:	df000115 	stw	fp,4(sp)
 b003a08:	df000104 	addi	fp,sp,4
 b003a0c:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
 b003a10:	d1600604 	addi	r5,gp,-32744
 b003a14:	e13fff17 	ldw	r4,-4(fp)
 b003a18:	b0062280 	call	b006228 <alt_dev_llist_insert>
}
 b003a1c:	e037883a 	mov	sp,fp
 b003a20:	dfc00117 	ldw	ra,4(sp)
 b003a24:	df000017 	ldw	fp,0(sp)
 b003a28:	dec00204 	addi	sp,sp,8
 b003a2c:	f800283a 	ret

0b003a30 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
 b003a30:	defffd04 	addi	sp,sp,-12
 b003a34:	dfc00215 	stw	ra,8(sp)
 b003a38:	df000115 	stw	fp,4(sp)
 b003a3c:	df000104 	addi	fp,sp,4
 b003a40:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS_2, nios_2);
 b003a44:	b006c900 	call	b006c90 <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
 b003a48:	00800044 	movi	r2,1
 b003a4c:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
 b003a50:	0001883a 	nop
 b003a54:	e037883a 	mov	sp,fp
 b003a58:	dfc00117 	ldw	ra,4(sp)
 b003a5c:	df000017 	ldw	fp,0(sp)
 b003a60:	dec00204 	addi	sp,sp,8
 b003a64:	f800283a 	ret

0b003a68 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
 b003a68:	defffe04 	addi	sp,sp,-8
 b003a6c:	dfc00115 	stw	ra,4(sp)
 b003a70:	df000015 	stw	fp,0(sp)
 b003a74:	d839883a 	mov	fp,sp
    ALTERA_AVALON_EPCS_FLASH_CONTROLLER_INIT ( FLASH, flash);
 b003a78:	0102c074 	movhi	r4,2817
 b003a7c:	21200504 	addi	r4,r4,-32748
 b003a80:	b003b040 	call	b003b04 <alt_epcs_flash_init>
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
 b003a84:	000d883a 	mov	r6,zero
 b003a88:	000b883a 	mov	r5,zero
 b003a8c:	0102c074 	movhi	r4,2817
 b003a90:	21204204 	addi	r4,r4,-32504
 b003a94:	b0047300 	call	b004730 <altera_avalon_jtag_uart_init>
 b003a98:	0102c074 	movhi	r4,2817
 b003a9c:	21203804 	addi	r4,r4,-32544
 b003aa0:	b0039fc0 	call	b0039fc <alt_dev_reg>
    ALTERA_AVALON_SPI_INIT ( SPI_0, spi_0);
 b003aa4:	0001883a 	nop
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID_QSYS_1, sysid_qsys_1);
 b003aa8:	0001883a 	nop
//    ALTERA_AVALON_UART_INIT ( UART, uart);
    ALTERA_UP_AVALON_ADC_INIT ( ADC, adc);
 b003aac:	0102c074 	movhi	r4,2817
 b003ab0:	21248104 	addi	r4,r4,-28156
 b003ab4:	b0039fc0 	call	b0039fc <alt_dev_reg>
}
 b003ab8:	0001883a 	nop
 b003abc:	e037883a 	mov	sp,fp
 b003ac0:	dfc00117 	ldw	ra,4(sp)
 b003ac4:	df000017 	ldw	fp,0(sp)
 b003ac8:	dec00204 	addi	sp,sp,8
 b003acc:	f800283a 	ret

0b003ad0 <alt_flash_device_register>:

typedef struct alt_flash_dev alt_flash_dev; 
typedef alt_flash_dev alt_flash_fd;

static ALT_INLINE int alt_flash_device_register( alt_flash_fd* fd)
{
 b003ad0:	defffd04 	addi	sp,sp,-12
 b003ad4:	dfc00215 	stw	ra,8(sp)
 b003ad8:	df000115 	stw	fp,4(sp)
 b003adc:	df000104 	addi	fp,sp,4
 b003ae0:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_flash_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) fd, &alt_flash_dev_list);
 b003ae4:	d1600b04 	addi	r5,gp,-32724
 b003ae8:	e13fff17 	ldw	r4,-4(fp)
 b003aec:	b0062280 	call	b006228 <alt_dev_llist_insert>
}
 b003af0:	e037883a 	mov	sp,fp
 b003af4:	dfc00117 	ldw	ra,4(sp)
 b003af8:	df000017 	ldw	fp,0(sp)
 b003afc:	dec00204 	addi	sp,sp,8
 b003b00:	f800283a 	ret

0b003b04 <alt_epcs_flash_init>:
/*
 * alt_epcs_flash_init
 *
 */
int alt_epcs_flash_init(alt_flash_epcs_dev* flash)
{
 b003b04:	defffc04 	addi	sp,sp,-16
 b003b08:	dfc00315 	stw	ra,12(sp)
 b003b0c:	df000215 	stw	fp,8(sp)
 b003b10:	df000204 	addi	fp,sp,8
 b003b14:	e13fff15 	stw	r4,-4(fp)
  int ret_code = 0;
 b003b18:	e03ffe15 	stw	zero,-8(fp)

  /* Set up function pointers and/or data structures as needed. */
  ret_code = alt_epcs_flash_query(flash);
 b003b1c:	e13fff17 	ldw	r4,-4(fp)
 b003b20:	b003b580 	call	b003b58 <alt_epcs_flash_query>
 b003b24:	e0bffe15 	stw	r2,-8(fp)
  */

  /*
  *  Register this device as a valid flash device type
  */
  if (!ret_code)
 b003b28:	e0bffe17 	ldw	r2,-8(fp)
 b003b2c:	1000041e 	bne	r2,zero,b003b40 <alt_epcs_flash_init+0x3c>
    ret_code = alt_flash_device_register(&(flash->dev));
 b003b30:	e0bfff17 	ldw	r2,-4(fp)
 b003b34:	1009883a 	mov	r4,r2
 b003b38:	b003ad00 	call	b003ad0 <alt_flash_device_register>
 b003b3c:	e0bffe15 	stw	r2,-8(fp)

  return ret_code;
 b003b40:	e0bffe17 	ldw	r2,-8(fp)
}
 b003b44:	e037883a 	mov	sp,fp
 b003b48:	dfc00117 	ldw	ra,4(sp)
 b003b4c:	df000017 	ldw	fp,0(sp)
 b003b50:	dec00204 	addi	sp,sp,8
 b003b54:	f800283a 	ret

0b003b58 <alt_epcs_flash_query>:


static int alt_epcs_flash_query(alt_flash_epcs_dev* flash)
{
 b003b58:	defffc04 	addi	sp,sp,-16
 b003b5c:	dfc00315 	stw	ra,12(sp)
 b003b60:	df000215 	stw	fp,8(sp)
 b003b64:	df000204 	addi	fp,sp,8
 b003b68:	e13fff15 	stw	r4,-4(fp)
  int ret_code = 0;
 b003b6c:	e03ffe15 	stw	zero,-8(fp)
   * reset the device, or whatever, to ensure that
   * it's in a known working state.
  */
  
  /* Disable 4-bytes address mode. */
  flash->four_bytes_mode = 0;
 b003b70:	e0bfff17 	ldw	r2,-4(fp)
 b003b74:	10003215 	stw	zero,200(r2)
  
  /* Send the RES command sequence */
  flash->silicon_id =
    epcs_read_electronic_signature(flash->register_base);
 b003b78:	e0bfff17 	ldw	r2,-4(fp)
 b003b7c:	10802e17 	ldw	r2,184(r2)
 b003b80:	1009883a 	mov	r4,r2
 b003b84:	b005da80 	call	b005da8 <epcs_read_electronic_signature>
  
  /* Disable 4-bytes address mode. */
  flash->four_bytes_mode = 0;
  
  /* Send the RES command sequence */
  flash->silicon_id =
 b003b88:	10c03fcc 	andi	r3,r2,255
 b003b8c:	e0bfff17 	ldw	r2,-4(fp)
 b003b90:	10c03015 	stw	r3,192(r2)
    epcs_read_electronic_signature(flash->register_base);

  /* Fill in all device-specific parameters. */
  if (flash->silicon_id == 0x16) /* EPCS64 */
 b003b94:	e0bfff17 	ldw	r2,-4(fp)
 b003b98:	10803017 	ldw	r2,192(r2)
 b003b9c:	10800598 	cmpnei	r2,r2,22
 b003ba0:	10000a1e 	bne	r2,zero,b003bcc <alt_epcs_flash_query+0x74>
  {
    flash->dev.region_info[0].region_size = 64 * 1024 * 1024 / 8;
 b003ba4:	e0bfff17 	ldw	r2,-4(fp)
 b003ba8:	00c02034 	movhi	r3,128
 b003bac:	10c00e15 	stw	r3,56(r2)
    flash->dev.region_info[0].number_of_blocks = 128;
 b003bb0:	e0bfff17 	ldw	r2,-4(fp)
 b003bb4:	00c02004 	movi	r3,128
 b003bb8:	10c00f15 	stw	r3,60(r2)
    flash->dev.region_info[0].block_size = 65536;
 b003bbc:	e0bfff17 	ldw	r2,-4(fp)
 b003bc0:	00c00074 	movhi	r3,1
 b003bc4:	10c01015 	stw	r3,64(r2)
 b003bc8:	0000ce06 	br	b003f04 <alt_epcs_flash_query+0x3ac>
  }
  else if (flash->silicon_id == 0x14) /* EPCS16 */
 b003bcc:	e0bfff17 	ldw	r2,-4(fp)
 b003bd0:	10803017 	ldw	r2,192(r2)
 b003bd4:	10800518 	cmpnei	r2,r2,20
 b003bd8:	10000a1e 	bne	r2,zero,b003c04 <alt_epcs_flash_query+0xac>
  {
    flash->dev.region_info[0].region_size = 16 * 1024 * 1024 / 8;
 b003bdc:	e0bfff17 	ldw	r2,-4(fp)
 b003be0:	00c00834 	movhi	r3,32
 b003be4:	10c00e15 	stw	r3,56(r2)
    flash->dev.region_info[0].number_of_blocks = 32;
 b003be8:	e0bfff17 	ldw	r2,-4(fp)
 b003bec:	00c00804 	movi	r3,32
 b003bf0:	10c00f15 	stw	r3,60(r2)
    flash->dev.region_info[0].block_size = 65536;
 b003bf4:	e0bfff17 	ldw	r2,-4(fp)
 b003bf8:	00c00074 	movhi	r3,1
 b003bfc:	10c01015 	stw	r3,64(r2)
 b003c00:	0000c006 	br	b003f04 <alt_epcs_flash_query+0x3ac>
  }
  else if (flash->silicon_id == 0x13) /* EPCS8 */
 b003c04:	e0bfff17 	ldw	r2,-4(fp)
 b003c08:	10803017 	ldw	r2,192(r2)
 b003c0c:	108004d8 	cmpnei	r2,r2,19
 b003c10:	10000a1e 	bne	r2,zero,b003c3c <alt_epcs_flash_query+0xe4>
  {
    flash->dev.region_info[0].region_size = 8 * 1024 * 1024 / 8;
 b003c14:	e0bfff17 	ldw	r2,-4(fp)
 b003c18:	00c00434 	movhi	r3,16
 b003c1c:	10c00e15 	stw	r3,56(r2)
    flash->dev.region_info[0].number_of_blocks = 16;
 b003c20:	e0bfff17 	ldw	r2,-4(fp)
 b003c24:	00c00404 	movi	r3,16
 b003c28:	10c00f15 	stw	r3,60(r2)
    flash->dev.region_info[0].block_size = 65536;
 b003c2c:	e0bfff17 	ldw	r2,-4(fp)
 b003c30:	00c00074 	movhi	r3,1
 b003c34:	10c01015 	stw	r3,64(r2)
 b003c38:	0000b206 	br	b003f04 <alt_epcs_flash_query+0x3ac>
  }
  else if (flash->silicon_id == 0x12) /* EPCS4 */
 b003c3c:	e0bfff17 	ldw	r2,-4(fp)
 b003c40:	10803017 	ldw	r2,192(r2)
 b003c44:	10800498 	cmpnei	r2,r2,18
 b003c48:	10000a1e 	bne	r2,zero,b003c74 <alt_epcs_flash_query+0x11c>
  {
    flash->dev.region_info[0].region_size = 4 * 1024 * 1024 / 8;
 b003c4c:	e0bfff17 	ldw	r2,-4(fp)
 b003c50:	00c00234 	movhi	r3,8
 b003c54:	10c00e15 	stw	r3,56(r2)
    flash->dev.region_info[0].number_of_blocks = 8;
 b003c58:	e0bfff17 	ldw	r2,-4(fp)
 b003c5c:	00c00204 	movi	r3,8
 b003c60:	10c00f15 	stw	r3,60(r2)
    flash->dev.region_info[0].block_size = 65536;
 b003c64:	e0bfff17 	ldw	r2,-4(fp)
 b003c68:	00c00074 	movhi	r3,1
 b003c6c:	10c01015 	stw	r3,64(r2)
 b003c70:	0000a406 	br	b003f04 <alt_epcs_flash_query+0x3ac>
  }
  else if (flash->silicon_id == 0x10) /* EPCS1 */
 b003c74:	e0bfff17 	ldw	r2,-4(fp)
 b003c78:	10803017 	ldw	r2,192(r2)
 b003c7c:	10800418 	cmpnei	r2,r2,16
 b003c80:	10000a1e 	bne	r2,zero,b003cac <alt_epcs_flash_query+0x154>
  {
    flash->dev.region_info[0].region_size = 1 * 1024 * 1024 / 8;
 b003c84:	e0bfff17 	ldw	r2,-4(fp)
 b003c88:	00c000b4 	movhi	r3,2
 b003c8c:	10c00e15 	stw	r3,56(r2)
    flash->dev.region_info[0].number_of_blocks = 4;
 b003c90:	e0bfff17 	ldw	r2,-4(fp)
 b003c94:	00c00104 	movi	r3,4
 b003c98:	10c00f15 	stw	r3,60(r2)
    flash->dev.region_info[0].block_size = 32768;
 b003c9c:	e0bfff17 	ldw	r2,-4(fp)
 b003ca0:	00e00014 	movui	r3,32768
 b003ca4:	10c01015 	stw	r3,64(r2)
 b003ca8:	00009606 	br	b003f04 <alt_epcs_flash_query+0x3ac>
  {
    /* 
     * Read electronic signature doesn't work for newer devices; try 
     * the "Read Device ID" command" before giving up.
     */
    flash->silicon_id = epcs_read_device_id(flash->register_base);
 b003cac:	e0bfff17 	ldw	r2,-4(fp)
 b003cb0:	10802e17 	ldw	r2,184(r2)
 b003cb4:	1009883a 	mov	r4,r2
 b003cb8:	b005e100 	call	b005e10 <epcs_read_device_id>
 b003cbc:	1007883a 	mov	r3,r2
 b003cc0:	e0bfff17 	ldw	r2,-4(fp)
 b003cc4:	10c03015 	stw	r3,192(r2)
    /*
     * Last byte is the density ID. Note the difference between
     * EPCS128 and EPCQ128 -- arranged differently, though the 
     * least significant byte of each is '0x18'.
     */
    if((flash->silicon_id & 0xFFFFFF) == 0x20BA15) /* EPCQ16 */
 b003cc8:	e0bfff17 	ldw	r2,-4(fp)
 b003ccc:	10c03017 	ldw	r3,192(r2)
 b003cd0:	00804034 	movhi	r2,256
 b003cd4:	10bfffc4 	addi	r2,r2,-1
 b003cd8:	1886703a 	and	r3,r3,r2
 b003cdc:	00800874 	movhi	r2,33
 b003ce0:	10ae8544 	addi	r2,r2,-17899
 b003ce4:	18800a1e 	bne	r3,r2,b003d10 <alt_epcs_flash_query+0x1b8>
    {
      flash->dev.region_info[0].region_size = 16 * 1024 * 1024 / 8;
 b003ce8:	e0bfff17 	ldw	r2,-4(fp)
 b003cec:	00c00834 	movhi	r3,32
 b003cf0:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 32; /* number of sectors */
 b003cf4:	e0bfff17 	ldw	r2,-4(fp)
 b003cf8:	00c00804 	movi	r3,32
 b003cfc:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
 b003d00:	e0bfff17 	ldw	r2,-4(fp)
 b003d04:	00c00074 	movhi	r3,1
 b003d08:	10c01015 	stw	r3,64(r2)
 b003d0c:	00007d06 	br	b003f04 <alt_epcs_flash_query+0x3ac>
    }
    else if((flash->silicon_id & 0xFFFFFF) == 0x20BA16) /* EPCQ32 */
 b003d10:	e0bfff17 	ldw	r2,-4(fp)
 b003d14:	10c03017 	ldw	r3,192(r2)
 b003d18:	00804034 	movhi	r2,256
 b003d1c:	10bfffc4 	addi	r2,r2,-1
 b003d20:	1886703a 	and	r3,r3,r2
 b003d24:	00800874 	movhi	r2,33
 b003d28:	10ae8584 	addi	r2,r2,-17898
 b003d2c:	18800a1e 	bne	r3,r2,b003d58 <alt_epcs_flash_query+0x200>
    {
      flash->dev.region_info[0].region_size = 32 * 1024 * 1024 / 8;
 b003d30:	e0bfff17 	ldw	r2,-4(fp)
 b003d34:	00c01034 	movhi	r3,64
 b003d38:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 64; /* number of sectors */
 b003d3c:	e0bfff17 	ldw	r2,-4(fp)
 b003d40:	00c01004 	movi	r3,64
 b003d44:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
 b003d48:	e0bfff17 	ldw	r2,-4(fp)
 b003d4c:	00c00074 	movhi	r3,1
 b003d50:	10c01015 	stw	r3,64(r2)
 b003d54:	00006b06 	br	b003f04 <alt_epcs_flash_query+0x3ac>
    }
    else if((flash->silicon_id & 0xFFFFFF) == 0x20BA17) /* EPCQ64 */
 b003d58:	e0bfff17 	ldw	r2,-4(fp)
 b003d5c:	10c03017 	ldw	r3,192(r2)
 b003d60:	00804034 	movhi	r2,256
 b003d64:	10bfffc4 	addi	r2,r2,-1
 b003d68:	1886703a 	and	r3,r3,r2
 b003d6c:	00800874 	movhi	r2,33
 b003d70:	10ae85c4 	addi	r2,r2,-17897
 b003d74:	18800a1e 	bne	r3,r2,b003da0 <alt_epcs_flash_query+0x248>
    {
      flash->dev.region_info[0].region_size = 64 * 1024 * 1024 / 8;
 b003d78:	e0bfff17 	ldw	r2,-4(fp)
 b003d7c:	00c02034 	movhi	r3,128
 b003d80:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 128; /* number of sectors */
 b003d84:	e0bfff17 	ldw	r2,-4(fp)
 b003d88:	00c02004 	movi	r3,128
 b003d8c:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
 b003d90:	e0bfff17 	ldw	r2,-4(fp)
 b003d94:	00c00074 	movhi	r3,1
 b003d98:	10c01015 	stw	r3,64(r2)
 b003d9c:	00005906 	br	b003f04 <alt_epcs_flash_query+0x3ac>
    }
    else if((flash->silicon_id & 0xFFFFFF) == 0x20BA18) /* EPCQ128 */
 b003da0:	e0bfff17 	ldw	r2,-4(fp)
 b003da4:	10c03017 	ldw	r3,192(r2)
 b003da8:	00804034 	movhi	r2,256
 b003dac:	10bfffc4 	addi	r2,r2,-1
 b003db0:	1886703a 	and	r3,r3,r2
 b003db4:	00800874 	movhi	r2,33
 b003db8:	10ae8604 	addi	r2,r2,-17896
 b003dbc:	18800a1e 	bne	r3,r2,b003de8 <alt_epcs_flash_query+0x290>
    {
      flash->dev.region_info[0].region_size = 128 * 1024 * 1024 / 8;
 b003dc0:	e0bfff17 	ldw	r2,-4(fp)
 b003dc4:	00c04034 	movhi	r3,256
 b003dc8:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 256; /* number of sectors */
 b003dcc:	e0bfff17 	ldw	r2,-4(fp)
 b003dd0:	00c04004 	movi	r3,256
 b003dd4:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
 b003dd8:	e0bfff17 	ldw	r2,-4(fp)
 b003ddc:	00c00074 	movhi	r3,1
 b003de0:	10c01015 	stw	r3,64(r2)
 b003de4:	00004706 	br	b003f04 <alt_epcs_flash_query+0x3ac>
    }
    else if((flash->silicon_id & 0xFF) == 0x18) /* EPCS128 */
 b003de8:	e0bfff17 	ldw	r2,-4(fp)
 b003dec:	10803017 	ldw	r2,192(r2)
 b003df0:	10803fcc 	andi	r2,r2,255
 b003df4:	10800618 	cmpnei	r2,r2,24
 b003df8:	10000a1e 	bne	r2,zero,b003e24 <alt_epcs_flash_query+0x2cc>
    {
      flash->dev.region_info[0].region_size = 128 * 1024 * 1024 / 8;
 b003dfc:	e0bfff17 	ldw	r2,-4(fp)
 b003e00:	00c04034 	movhi	r3,256
 b003e04:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 64;
 b003e08:	e0bfff17 	ldw	r2,-4(fp)
 b003e0c:	00c01004 	movi	r3,64
 b003e10:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 262144;
 b003e14:	e0bfff17 	ldw	r2,-4(fp)
 b003e18:	00c00134 	movhi	r3,4
 b003e1c:	10c01015 	stw	r3,64(r2)
 b003e20:	00003806 	br	b003f04 <alt_epcs_flash_query+0x3ac>
    }
    else if((flash->silicon_id & 0xFF ) == 0x19) /* EPCQ256 */
 b003e24:	e0bfff17 	ldw	r2,-4(fp)
 b003e28:	10803017 	ldw	r2,192(r2)
 b003e2c:	10803fcc 	andi	r2,r2,255
 b003e30:	10800658 	cmpnei	r2,r2,25
 b003e34:	10000d1e 	bne	r2,zero,b003e6c <alt_epcs_flash_query+0x314>
    {
      flash->dev.region_info[0].region_size = 256 * 1024 * 1024 / 8;
 b003e38:	e0bfff17 	ldw	r2,-4(fp)
 b003e3c:	00c08034 	movhi	r3,512
 b003e40:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 512; /* number of sectors */
 b003e44:	e0bfff17 	ldw	r2,-4(fp)
 b003e48:	00c08004 	movi	r3,512
 b003e4c:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
 b003e50:	e0bfff17 	ldw	r2,-4(fp)
 b003e54:	00c00074 	movhi	r3,1
 b003e58:	10c01015 	stw	r3,64(r2)
       * must first be programmed into the device, though. To complicate things, 
       * other Altera IP expects the chip to be in 3 byte address mode when they 
       * start using it. To be nice, we'll place the device into 4-byte address mode
       * when we need to, and take it back out when we're done.
       */
      flash->four_bytes_mode = 1;
 b003e5c:	e0bfff17 	ldw	r2,-4(fp)
 b003e60:	00c00044 	movi	r3,1
 b003e64:	10c03215 	stw	r3,200(r2)
 b003e68:	00002606 	br	b003f04 <alt_epcs_flash_query+0x3ac>
    }
    else if((flash->silicon_id & 0xFF ) == 0x20) /* EPCQ512 */
 b003e6c:	e0bfff17 	ldw	r2,-4(fp)
 b003e70:	10803017 	ldw	r2,192(r2)
 b003e74:	10803fcc 	andi	r2,r2,255
 b003e78:	10800818 	cmpnei	r2,r2,32
 b003e7c:	10000d1e 	bne	r2,zero,b003eb4 <alt_epcs_flash_query+0x35c>
    {
      flash->dev.region_info[0].region_size = 512 * 1024 * 1024 / 8;
 b003e80:	e0bfff17 	ldw	r2,-4(fp)
 b003e84:	00c10034 	movhi	r3,1024
 b003e88:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 1024; /* number of sectors */
 b003e8c:	e0bfff17 	ldw	r2,-4(fp)
 b003e90:	00c10004 	movi	r3,1024
 b003e94:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
 b003e98:	e0bfff17 	ldw	r2,-4(fp)
 b003e9c:	00c00074 	movhi	r3,1
 b003ea0:	10c01015 	stw	r3,64(r2)

      /* Enable 4-bytes address mode if the device density is greater than 256Mbit. */
      flash->four_bytes_mode = 1;
 b003ea4:	e0bfff17 	ldw	r2,-4(fp)
 b003ea8:	00c00044 	movi	r3,1
 b003eac:	10c03215 	stw	r3,200(r2)
 b003eb0:	00001406 	br	b003f04 <alt_epcs_flash_query+0x3ac>
    }
    else if((flash->silicon_id & 0xFF ) == 0x21) /* EPCQ1024 */
 b003eb4:	e0bfff17 	ldw	r2,-4(fp)
 b003eb8:	10803017 	ldw	r2,192(r2)
 b003ebc:	10803fcc 	andi	r2,r2,255
 b003ec0:	10800858 	cmpnei	r2,r2,33
 b003ec4:	10000d1e 	bne	r2,zero,b003efc <alt_epcs_flash_query+0x3a4>
    {
      flash->dev.region_info[0].region_size = 1024 * 1024 * 1024 / 8;
 b003ec8:	e0bfff17 	ldw	r2,-4(fp)
 b003ecc:	00c20034 	movhi	r3,2048
 b003ed0:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 2048; /* number of sectors */
 b003ed4:	e0bfff17 	ldw	r2,-4(fp)
 b003ed8:	00c20004 	movi	r3,2048
 b003edc:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
 b003ee0:	e0bfff17 	ldw	r2,-4(fp)
 b003ee4:	00c00074 	movhi	r3,1
 b003ee8:	10c01015 	stw	r3,64(r2)

      /* Enable 4-bytes address mode if the device density is greater than 256Mbit. */
      flash->four_bytes_mode = 1;
 b003eec:	e0bfff17 	ldw	r2,-4(fp)
 b003ef0:	00c00044 	movi	r3,1
 b003ef4:	10c03215 	stw	r3,200(r2)
 b003ef8:	00000206 	br	b003f04 <alt_epcs_flash_query+0x3ac>
    }
    else 
    {
      ret_code = -ENODEV; /* No known device found! */
 b003efc:	00bffb44 	movi	r2,-19
 b003f00:	e0bffe15 	stw	r2,-8(fp)
    }
  }
  
  flash->size_in_bytes = flash->dev.region_info[0].region_size;
 b003f04:	e0bfff17 	ldw	r2,-4(fp)
 b003f08:	10800e17 	ldw	r2,56(r2)
 b003f0c:	1007883a 	mov	r3,r2
 b003f10:	e0bfff17 	ldw	r2,-4(fp)
 b003f14:	10c02f15 	stw	r3,188(r2)
  flash->dev.number_of_regions = 1;
 b003f18:	e0bfff17 	ldw	r2,-4(fp)
 b003f1c:	00c00044 	movi	r3,1
 b003f20:	10c00c15 	stw	r3,48(r2)
  flash->dev.region_info[0].offset = 0;
 b003f24:	e0bfff17 	ldw	r2,-4(fp)
 b003f28:	10000d15 	stw	zero,52(r2)
  flash->page_size = 256;
 b003f2c:	e0bfff17 	ldw	r2,-4(fp)
 b003f30:	00c04004 	movi	r3,256
 b003f34:	10c03115 	stw	r3,196(r2)

  /* Consider clearing all BP bits here. */
  return ret_code;
 b003f38:	e0bffe17 	ldw	r2,-8(fp)
}
 b003f3c:	e037883a 	mov	sp,fp
 b003f40:	dfc00117 	ldw	ra,4(sp)
 b003f44:	df000017 	ldw	fp,0(sp)
 b003f48:	dec00204 	addi	sp,sp,8
 b003f4c:	f800283a 	ret

0b003f50 <alt_epcs_flash_memcmp>:
  alt_flash_dev* flash_info,
  const void* src_buffer,
  int offset,
  size_t n
)
{
 b003f50:	deffee04 	addi	sp,sp,-72
 b003f54:	dfc01115 	stw	ra,68(sp)
 b003f58:	df001015 	stw	fp,64(sp)
 b003f5c:	df001004 	addi	fp,sp,64
 b003f60:	e13ffc15 	stw	r4,-16(fp)
 b003f64:	e17ffd15 	stw	r5,-12(fp)
 b003f68:	e1bffe15 	stw	r6,-8(fp)
 b003f6c:	e1ffff15 	stw	r7,-4(fp)
  /*
   * Compare chunks of memory at a time, for better serial-flash
   * read efficiency.
   */
  alt_u8 chunk_buffer[32];
  const int chunk_size = sizeof(chunk_buffer) / sizeof(*chunk_buffer);
 b003f70:	00800804 	movi	r2,32
 b003f74:	e0bff115 	stw	r2,-60(fp)
  int current_offset = 0;
 b003f78:	e03ff015 	stw	zero,-64(fp)

  while (n > 0)
 b003f7c:	00002706 	br	b00401c <alt_epcs_flash_memcmp+0xcc>
  {
    int this_chunk_size = n > chunk_size ? chunk_size : n;
 b003f80:	e0fff117 	ldw	r3,-60(fp)
 b003f84:	e0bfff17 	ldw	r2,-4(fp)
 b003f88:	1880012e 	bgeu	r3,r2,b003f90 <alt_epcs_flash_memcmp+0x40>
 b003f8c:	1805883a 	mov	r2,r3
 b003f90:	e0bff215 	stw	r2,-56(fp)
    int this_chunk_cmp;

    if (
      alt_epcs_flash_read(
 b003f94:	e0fffe17 	ldw	r3,-8(fp)
 b003f98:	e0bff017 	ldw	r2,-64(fp)
 b003f9c:	1885883a 	add	r2,r3,r2
 b003fa0:	e0fff404 	addi	r3,fp,-48
 b003fa4:	e1fff217 	ldw	r7,-56(fp)
 b003fa8:	180d883a 	mov	r6,r3
 b003fac:	100b883a 	mov	r5,r2
 b003fb0:	e13ffc17 	ldw	r4,-16(fp)
 b003fb4:	b0045340 	call	b004534 <alt_epcs_flash_read>
  while (n > 0)
  {
    int this_chunk_size = n > chunk_size ? chunk_size : n;
    int this_chunk_cmp;

    if (
 b003fb8:	1000020e 	bge	r2,zero,b003fc4 <alt_epcs_flash_memcmp+0x74>
    {
      /*
      * If the read fails, I'm not sure what the appropriate action is.
      * Compare success seems wrong, so make it compare fail.
      */
      return -1;
 b003fbc:	00bfffc4 	movi	r2,-1
 b003fc0:	00001906 	br	b004028 <alt_epcs_flash_memcmp+0xd8>
    }

    /* Compare this chunk against the source memory buffer. */
    this_chunk_cmp = memcmp(&((unsigned char*)(src_buffer))[current_offset], chunk_buffer, this_chunk_size);
 b003fc4:	e0bff017 	ldw	r2,-64(fp)
 b003fc8:	e0fffd17 	ldw	r3,-12(fp)
 b003fcc:	1885883a 	add	r2,r3,r2
 b003fd0:	e13ff217 	ldw	r4,-56(fp)
 b003fd4:	e0fff404 	addi	r3,fp,-48
 b003fd8:	200d883a 	mov	r6,r4
 b003fdc:	180b883a 	mov	r5,r3
 b003fe0:	1009883a 	mov	r4,r2
 b003fe4:	b0071f40 	call	b0071f4 <memcmp>
 b003fe8:	e0bff315 	stw	r2,-52(fp)
    if (this_chunk_cmp)
 b003fec:	e0bff317 	ldw	r2,-52(fp)
 b003ff0:	10000226 	beq	r2,zero,b003ffc <alt_epcs_flash_memcmp+0xac>
    {
      return this_chunk_cmp;
 b003ff4:	e0bff317 	ldw	r2,-52(fp)
 b003ff8:	00000b06 	br	b004028 <alt_epcs_flash_memcmp+0xd8>
    }

    n -= this_chunk_size;
 b003ffc:	e0bff217 	ldw	r2,-56(fp)
 b004000:	e0ffff17 	ldw	r3,-4(fp)
 b004004:	1885c83a 	sub	r2,r3,r2
 b004008:	e0bfff15 	stw	r2,-4(fp)
    current_offset += this_chunk_size;
 b00400c:	e0fff017 	ldw	r3,-64(fp)
 b004010:	e0bff217 	ldw	r2,-56(fp)
 b004014:	1885883a 	add	r2,r3,r2
 b004018:	e0bff015 	stw	r2,-64(fp)
   */
  alt_u8 chunk_buffer[32];
  const int chunk_size = sizeof(chunk_buffer) / sizeof(*chunk_buffer);
  int current_offset = 0;

  while (n > 0)
 b00401c:	e0bfff17 	ldw	r2,-4(fp)
 b004020:	103fd71e 	bne	r2,zero,b003f80 <__alt_mem_flash+0xff002f80>
  }

  /*
   * If execution made it to this point, compare is successful.
   */
  return 0;
 b004024:	0005883a 	mov	r2,zero
}
 b004028:	e037883a 	mov	sp,fp
 b00402c:	dfc00117 	ldw	ra,4(sp)
 b004030:	df000017 	ldw	fp,0(sp)
 b004034:	dec00204 	addi	sp,sp,8
 b004038:	f800283a 	ret

0b00403c <alt_epcs_flash_write>:
 * large buffer to tie up in our programming library, when not all users will
 * want that functionality.
 */
int alt_epcs_flash_write(alt_flash_dev* flash_info, int offset,
                          const void* src_addr, int length)
{
 b00403c:	defff404 	addi	sp,sp,-48
 b004040:	dfc00b15 	stw	ra,44(sp)
 b004044:	df000a15 	stw	fp,40(sp)
 b004048:	df000a04 	addi	fp,sp,40
 b00404c:	e13ffc15 	stw	r4,-16(fp)
 b004050:	e17ffd15 	stw	r5,-12(fp)
 b004054:	e1bffe15 	stw	r6,-8(fp)
 b004058:	e1ffff15 	stw	r7,-4(fp)
  int         ret_code = 0;
 b00405c:	e03ff715 	stw	zero,-36(fp)
  int         current_offset;

  /*
   * First and foremost which sectors are affected?
   */
  for(i = 0; i < flash_info->number_of_regions; i++)
 b004060:	e03ff815 	stw	zero,-32(fp)
 b004064:	00008306 	br	b004274 <alt_epcs_flash_write+0x238>
  {
    /* Is it in this erase block region?*/
    if((offset >= flash_info->region_info[i].offset) &&
 b004068:	e0fffc17 	ldw	r3,-16(fp)
 b00406c:	e0bff817 	ldw	r2,-32(fp)
 b004070:	1004913a 	slli	r2,r2,4
 b004074:	1885883a 	add	r2,r3,r2
 b004078:	10800d04 	addi	r2,r2,52
 b00407c:	10800017 	ldw	r2,0(r2)
 b004080:	e0fffd17 	ldw	r3,-12(fp)
 b004084:	18807816 	blt	r3,r2,b004268 <alt_epcs_flash_write+0x22c>
      (offset < (flash_info->region_info[i].offset +
 b004088:	e0fffc17 	ldw	r3,-16(fp)
 b00408c:	e0bff817 	ldw	r2,-32(fp)
 b004090:	1004913a 	slli	r2,r2,4
 b004094:	1885883a 	add	r2,r3,r2
 b004098:	10800d04 	addi	r2,r2,52
 b00409c:	10c00017 	ldw	r3,0(r2)
      flash_info->region_info[i].region_size)))
 b0040a0:	e13ffc17 	ldw	r4,-16(fp)
 b0040a4:	e0bff817 	ldw	r2,-32(fp)
 b0040a8:	1004913a 	slli	r2,r2,4
 b0040ac:	2085883a 	add	r2,r4,r2
 b0040b0:	10800e04 	addi	r2,r2,56
 b0040b4:	10800017 	ldw	r2,0(r2)
   */
  for(i = 0; i < flash_info->number_of_regions; i++)
  {
    /* Is it in this erase block region?*/
    if((offset >= flash_info->region_info[i].offset) &&
      (offset < (flash_info->region_info[i].offset +
 b0040b8:	1885883a 	add	r2,r3,r2
   * First and foremost which sectors are affected?
   */
  for(i = 0; i < flash_info->number_of_regions; i++)
  {
    /* Is it in this erase block region?*/
    if((offset >= flash_info->region_info[i].offset) &&
 b0040bc:	e0fffd17 	ldw	r3,-12(fp)
 b0040c0:	1880690e 	bge	r3,r2,b004268 <alt_epcs_flash_write+0x22c>
      (offset < (flash_info->region_info[i].offset +
      flash_info->region_info[i].region_size)))
    {
      current_offset = flash_info->region_info[i].offset;
 b0040c4:	e0fffc17 	ldw	r3,-16(fp)
 b0040c8:	e0bff817 	ldw	r2,-32(fp)
 b0040cc:	1004913a 	slli	r2,r2,4
 b0040d0:	1885883a 	add	r2,r3,r2
 b0040d4:	10800d04 	addi	r2,r2,52
 b0040d8:	10800017 	ldw	r2,0(r2)
 b0040dc:	e0bffa15 	stw	r2,-24(fp)

      for(j=0;j<flash_info->region_info[i].number_of_blocks;j++)
 b0040e0:	e03ff915 	stw	zero,-28(fp)
 b0040e4:	00005806 	br	b004248 <alt_epcs_flash_write+0x20c>
      {
        if ((offset >= current_offset ) &&
 b0040e8:	e0fffd17 	ldw	r3,-12(fp)
 b0040ec:	e0bffa17 	ldw	r2,-24(fp)
 b0040f0:	18804916 	blt	r3,r2,b004218 <alt_epcs_flash_write+0x1dc>
            (offset < (current_offset +
            flash_info->region_info[i].block_size)))
 b0040f4:	e0fffc17 	ldw	r3,-16(fp)
 b0040f8:	e0bff817 	ldw	r2,-32(fp)
 b0040fc:	10800104 	addi	r2,r2,4
 b004100:	1004913a 	slli	r2,r2,4
 b004104:	1885883a 	add	r2,r3,r2
 b004108:	10c00017 	ldw	r3,0(r2)
      current_offset = flash_info->region_info[i].offset;

      for(j=0;j<flash_info->region_info[i].number_of_blocks;j++)
      {
        if ((offset >= current_offset ) &&
            (offset < (current_offset +
 b00410c:	e0bffa17 	ldw	r2,-24(fp)
 b004110:	1885883a 	add	r2,r3,r2
    {
      current_offset = flash_info->region_info[i].offset;

      for(j=0;j<flash_info->region_info[i].number_of_blocks;j++)
      {
        if ((offset >= current_offset ) &&
 b004114:	e0fffd17 	ldw	r3,-12(fp)
 b004118:	18803f0e 	bge	r3,r2,b004218 <alt_epcs_flash_write+0x1dc>
        {
          /*
           * Check if the contents of the block are different
           * from the data we wish to put there
           */
          data_to_write = ( current_offset + flash_info->region_info[i].block_size
 b00411c:	e0fffc17 	ldw	r3,-16(fp)
 b004120:	e0bff817 	ldw	r2,-32(fp)
 b004124:	10800104 	addi	r2,r2,4
 b004128:	1004913a 	slli	r2,r2,4
 b00412c:	1885883a 	add	r2,r3,r2
 b004130:	10c00017 	ldw	r3,0(r2)
 b004134:	e0bffa17 	ldw	r2,-24(fp)
 b004138:	1887883a 	add	r3,r3,r2
 b00413c:	e0bffd17 	ldw	r2,-12(fp)
 b004140:	1885c83a 	sub	r2,r3,r2
 b004144:	e0bffb15 	stw	r2,-20(fp)
                            - offset);
          data_to_write = MIN(data_to_write, length);
 b004148:	e0fffb17 	ldw	r3,-20(fp)
 b00414c:	e0bfff17 	ldw	r2,-4(fp)
 b004150:	1880010e 	bge	r3,r2,b004158 <alt_epcs_flash_write+0x11c>
 b004154:	1805883a 	mov	r2,r3
 b004158:	e0bffb15 	stw	r2,-20(fp)

          if(alt_epcs_flash_memcmp(flash_info, src_addr, offset, data_to_write))
 b00415c:	e0bffb17 	ldw	r2,-20(fp)
 b004160:	100f883a 	mov	r7,r2
 b004164:	e1bffd17 	ldw	r6,-12(fp)
 b004168:	e17ffe17 	ldw	r5,-8(fp)
 b00416c:	e13ffc17 	ldw	r4,-16(fp)
 b004170:	b003f500 	call	b003f50 <alt_epcs_flash_memcmp>
 b004174:	10001226 	beq	r2,zero,b0041c0 <alt_epcs_flash_write+0x184>
          {
            ret_code = (*flash_info->erase_block)(flash_info, current_offset);
 b004178:	e0bffc17 	ldw	r2,-16(fp)
 b00417c:	10800817 	ldw	r2,32(r2)
 b004180:	e17ffa17 	ldw	r5,-24(fp)
 b004184:	e13ffc17 	ldw	r4,-16(fp)
 b004188:	103ee83a 	callr	r2
 b00418c:	e0bff715 	stw	r2,-36(fp)

            if (!ret_code)
 b004190:	e0bff717 	ldw	r2,-36(fp)
 b004194:	10000a1e 	bne	r2,zero,b0041c0 <alt_epcs_flash_write+0x184>
            {
              ret_code = (*flash_info->write_block)(
 b004198:	e0bffc17 	ldw	r2,-16(fp)
 b00419c:	10800917 	ldw	r2,36(r2)
 b0041a0:	e0fffb17 	ldw	r3,-20(fp)
 b0041a4:	d8c00015 	stw	r3,0(sp)
 b0041a8:	e1fffe17 	ldw	r7,-8(fp)
 b0041ac:	e1bffd17 	ldw	r6,-12(fp)
 b0041b0:	e17ffa17 	ldw	r5,-24(fp)
 b0041b4:	e13ffc17 	ldw	r4,-16(fp)
 b0041b8:	103ee83a 	callr	r2
 b0041bc:	e0bff715 	stw	r2,-36(fp)
                                                  data_to_write);
            }
          }

          /* Was this the last block? */
          if ((length == data_to_write) || ret_code)
 b0041c0:	e0ffff17 	ldw	r3,-4(fp)
 b0041c4:	e0bffb17 	ldw	r2,-20(fp)
 b0041c8:	18802e26 	beq	r3,r2,b004284 <alt_epcs_flash_write+0x248>
 b0041cc:	e0bff717 	ldw	r2,-36(fp)
 b0041d0:	10002c1e 	bne	r2,zero,b004284 <alt_epcs_flash_write+0x248>
          {
            goto finished;
          }

          length -= data_to_write;
 b0041d4:	e0ffff17 	ldw	r3,-4(fp)
 b0041d8:	e0bffb17 	ldw	r2,-20(fp)
 b0041dc:	1885c83a 	sub	r2,r3,r2
 b0041e0:	e0bfff15 	stw	r2,-4(fp)
          offset = current_offset + flash_info->region_info[i].block_size;
 b0041e4:	e0fffc17 	ldw	r3,-16(fp)
 b0041e8:	e0bff817 	ldw	r2,-32(fp)
 b0041ec:	10800104 	addi	r2,r2,4
 b0041f0:	1004913a 	slli	r2,r2,4
 b0041f4:	1885883a 	add	r2,r3,r2
 b0041f8:	10c00017 	ldw	r3,0(r2)
 b0041fc:	e0bffa17 	ldw	r2,-24(fp)
 b004200:	1885883a 	add	r2,r3,r2
 b004204:	e0bffd15 	stw	r2,-12(fp)
          src_addr = (alt_u8*)src_addr + data_to_write;
 b004208:	e0bffb17 	ldw	r2,-20(fp)
 b00420c:	e0fffe17 	ldw	r3,-8(fp)
 b004210:	1885883a 	add	r2,r3,r2
 b004214:	e0bffe15 	stw	r2,-8(fp)
        }
        current_offset += flash_info->region_info[i].block_size;
 b004218:	e0fffc17 	ldw	r3,-16(fp)
 b00421c:	e0bff817 	ldw	r2,-32(fp)
 b004220:	10800104 	addi	r2,r2,4
 b004224:	1004913a 	slli	r2,r2,4
 b004228:	1885883a 	add	r2,r3,r2
 b00422c:	10800017 	ldw	r2,0(r2)
 b004230:	e0fffa17 	ldw	r3,-24(fp)
 b004234:	1885883a 	add	r2,r3,r2
 b004238:	e0bffa15 	stw	r2,-24(fp)
      (offset < (flash_info->region_info[i].offset +
      flash_info->region_info[i].region_size)))
    {
      current_offset = flash_info->region_info[i].offset;

      for(j=0;j<flash_info->region_info[i].number_of_blocks;j++)
 b00423c:	e0bff917 	ldw	r2,-28(fp)
 b004240:	10800044 	addi	r2,r2,1
 b004244:	e0bff915 	stw	r2,-28(fp)
 b004248:	e0fffc17 	ldw	r3,-16(fp)
 b00424c:	e0bff817 	ldw	r2,-32(fp)
 b004250:	1004913a 	slli	r2,r2,4
 b004254:	1885883a 	add	r2,r3,r2
 b004258:	10800f04 	addi	r2,r2,60
 b00425c:	10800017 	ldw	r2,0(r2)
 b004260:	e0fff917 	ldw	r3,-28(fp)
 b004264:	18bfa016 	blt	r3,r2,b0040e8 <__alt_mem_flash+0xff0030e8>
  int         current_offset;

  /*
   * First and foremost which sectors are affected?
   */
  for(i = 0; i < flash_info->number_of_regions; i++)
 b004268:	e0bff817 	ldw	r2,-32(fp)
 b00426c:	10800044 	addi	r2,r2,1
 b004270:	e0bff815 	stw	r2,-32(fp)
 b004274:	e0bffc17 	ldw	r2,-16(fp)
 b004278:	10800c17 	ldw	r2,48(r2)
 b00427c:	e0fff817 	ldw	r3,-32(fp)
 b004280:	18bf7916 	blt	r3,r2,b004068 <__alt_mem_flash+0xff003068>
      }
    }
  }

finished:
  return ret_code;
 b004284:	e0bff717 	ldw	r2,-36(fp)
}
 b004288:	e037883a 	mov	sp,fp
 b00428c:	dfc00117 	ldw	ra,4(sp)
 b004290:	df000017 	ldw	fp,0(sp)
 b004294:	dec00204 	addi	sp,sp,8
 b004298:	f800283a 	ret

0b00429c <alt_epcs_flash_get_info>:
 *
 *  Pass the table of erase blocks to the user
 */
int alt_epcs_flash_get_info(alt_flash_fd* fd, flash_region** info,
                            int* number_of_regions)
{
 b00429c:	defffa04 	addi	sp,sp,-24
 b0042a0:	df000515 	stw	fp,20(sp)
 b0042a4:	df000504 	addi	fp,sp,20
 b0042a8:	e13ffd15 	stw	r4,-12(fp)
 b0042ac:	e17ffe15 	stw	r5,-8(fp)
 b0042b0:	e1bfff15 	stw	r6,-4(fp)
  int ret_code = 0;
 b0042b4:	e03ffb15 	stw	zero,-20(fp)

  alt_flash_dev* flash = (alt_flash_dev*)fd;
 b0042b8:	e0bffd17 	ldw	r2,-12(fp)
 b0042bc:	e0bffc15 	stw	r2,-16(fp)

  *number_of_regions = flash->number_of_regions;
 b0042c0:	e0bffc17 	ldw	r2,-16(fp)
 b0042c4:	10c00c17 	ldw	r3,48(r2)
 b0042c8:	e0bfff17 	ldw	r2,-4(fp)
 b0042cc:	10c00015 	stw	r3,0(r2)

  if (!flash->number_of_regions)
 b0042d0:	e0bffc17 	ldw	r2,-16(fp)
 b0042d4:	10800c17 	ldw	r2,48(r2)
 b0042d8:	1000031e 	bne	r2,zero,b0042e8 <alt_epcs_flash_get_info+0x4c>
  {
    ret_code = -EIO;
 b0042dc:	00bffec4 	movi	r2,-5
 b0042e0:	e0bffb15 	stw	r2,-20(fp)
 b0042e4:	00000b06 	br	b004314 <alt_epcs_flash_get_info+0x78>
  }
  else if (flash->number_of_regions > ALT_MAX_NUMBER_OF_FLASH_REGIONS)
 b0042e8:	e0bffc17 	ldw	r2,-16(fp)
 b0042ec:	10800c17 	ldw	r2,48(r2)
 b0042f0:	10800250 	cmplti	r2,r2,9
 b0042f4:	1000031e 	bne	r2,zero,b004304 <alt_epcs_flash_get_info+0x68>
  {
    ret_code = -ENOMEM;
 b0042f8:	00bffd04 	movi	r2,-12
 b0042fc:	e0bffb15 	stw	r2,-20(fp)
 b004300:	00000406 	br	b004314 <alt_epcs_flash_get_info+0x78>
  }
  else
  {
    *info = &flash->region_info[0];
 b004304:	e0bffc17 	ldw	r2,-16(fp)
 b004308:	10c00d04 	addi	r3,r2,52
 b00430c:	e0bffe17 	ldw	r2,-8(fp)
 b004310:	10c00015 	stw	r3,0(r2)
  }

  return ret_code;
 b004314:	e0bffb17 	ldw	r2,-20(fp)
}
 b004318:	e037883a 	mov	sp,fp
 b00431c:	df000017 	ldw	fp,0(sp)
 b004320:	dec00104 	addi	sp,sp,4
 b004324:	f800283a 	ret

0b004328 <alt_epcs_test_address>:


/* This might be a candidate for optimization.  Precompute the last-address? */
static ALT_INLINE int alt_epcs_test_address(alt_flash_dev* flash_info, int offset)
{
 b004328:	defff904 	addi	sp,sp,-28
 b00432c:	df000615 	stw	fp,24(sp)
 b004330:	df000604 	addi	fp,sp,24
 b004334:	e13ffe15 	stw	r4,-8(fp)
 b004338:	e17fff15 	stw	r5,-4(fp)
  int ret_code = 0;
 b00433c:	e03ffa15 	stw	zero,-24(fp)
  /* Error checking:
   * if the block offset is outside of the memory, return -EIO.
   */
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;
 b004340:	e0bffe17 	ldw	r2,-8(fp)
 b004344:	e0bffb15 	stw	r2,-20(fp)

  const alt_u32 last_region_index = f->dev.number_of_regions - 1;
 b004348:	e0bffb17 	ldw	r2,-20(fp)
 b00434c:	10800c17 	ldw	r2,48(r2)
 b004350:	10bfffc4 	addi	r2,r2,-1
 b004354:	e0bffc15 	stw	r2,-16(fp)
  alt_u32 last_device_address =
    -1 +
    f->dev.region_info[last_region_index].offset +
 b004358:	e0fffb17 	ldw	r3,-20(fp)
 b00435c:	e0bffc17 	ldw	r2,-16(fp)
 b004360:	1004913a 	slli	r2,r2,4
 b004364:	1885883a 	add	r2,r3,r2
 b004368:	10800d04 	addi	r2,r2,52
 b00436c:	10800017 	ldw	r2,0(r2)
   */
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;

  const alt_u32 last_region_index = f->dev.number_of_regions - 1;
  alt_u32 last_device_address =
    -1 +
 b004370:	10ffffc4 	addi	r3,r2,-1
    f->dev.region_info[last_region_index].offset +
    f->dev.region_info[last_region_index].region_size;
 b004374:	e13ffb17 	ldw	r4,-20(fp)
 b004378:	e0bffc17 	ldw	r2,-16(fp)
 b00437c:	1004913a 	slli	r2,r2,4
 b004380:	2085883a 	add	r2,r4,r2
 b004384:	10800e04 	addi	r2,r2,56
 b004388:	10800017 	ldw	r2,0(r2)
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;

  const alt_u32 last_region_index = f->dev.number_of_regions - 1;
  alt_u32 last_device_address =
    -1 +
    f->dev.region_info[last_region_index].offset +
 b00438c:	1885883a 	add	r2,r3,r2
   * if the block offset is outside of the memory, return -EIO.
   */
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;

  const alt_u32 last_region_index = f->dev.number_of_regions - 1;
  alt_u32 last_device_address =
 b004390:	e0bffd15 	stw	r2,-12(fp)
    -1 +
    f->dev.region_info[last_region_index].offset +
    f->dev.region_info[last_region_index].region_size;

  if (offset > last_device_address)
 b004394:	e0bfff17 	ldw	r2,-4(fp)
 b004398:	e0fffd17 	ldw	r3,-12(fp)
 b00439c:	1880022e 	bgeu	r3,r2,b0043a8 <alt_epcs_test_address+0x80>
  {
    /* Someone tried to erase a block outside of this device's range. */
    ret_code = -EIO;
 b0043a0:	00bffec4 	movi	r2,-5
 b0043a4:	e0bffa15 	stw	r2,-24(fp)
  }
  return ret_code;
 b0043a8:	e0bffa17 	ldw	r2,-24(fp)
}
 b0043ac:	e037883a 	mov	sp,fp
 b0043b0:	df000017 	ldw	fp,0(sp)
 b0043b4:	dec00104 	addi	sp,sp,4
 b0043b8:	f800283a 	ret

0b0043bc <alt_epcs_flash_erase_block>:
 *
 * Erase the selected erase block ("sector erase", from the POV
 * of the EPCS data sheet).
 */
int alt_epcs_flash_erase_block(alt_flash_dev* flash_info, int block_offset)
{
 b0043bc:	defffa04 	addi	sp,sp,-24
 b0043c0:	dfc00515 	stw	ra,20(sp)
 b0043c4:	df000415 	stw	fp,16(sp)
 b0043c8:	df000404 	addi	fp,sp,16
 b0043cc:	e13ffe15 	stw	r4,-8(fp)
 b0043d0:	e17fff15 	stw	r5,-4(fp)
  int ret_code = 0;
 b0043d4:	e03ffc15 	stw	zero,-16(fp)
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;
 b0043d8:	e0bffe17 	ldw	r2,-8(fp)
 b0043dc:	e0bffd15 	stw	r2,-12(fp)

  ret_code = alt_epcs_test_address(flash_info, block_offset);
 b0043e0:	e17fff17 	ldw	r5,-4(fp)
 b0043e4:	e13ffe17 	ldw	r4,-8(fp)
 b0043e8:	b0043280 	call	b004328 <alt_epcs_test_address>
 b0043ec:	e0bffc15 	stw	r2,-16(fp)

  if (ret_code >= 0)
 b0043f0:	e0bffc17 	ldw	r2,-16(fp)
 b0043f4:	10000916 	blt	r2,zero,b00441c <alt_epcs_flash_erase_block+0x60>
  {
    /* Send the Sector Erase command, whose 3 address bytes are anywhere
     * within the chosen sector.
     */
    epcs_sector_erase(f->register_base, block_offset, f->four_bytes_mode);
 b0043f8:	e0bffd17 	ldw	r2,-12(fp)
 b0043fc:	10c02e17 	ldw	r3,184(r2)
 b004400:	e13fff17 	ldw	r4,-4(fp)
 b004404:	e0bffd17 	ldw	r2,-12(fp)
 b004408:	10803217 	ldw	r2,200(r2)
 b00440c:	100d883a 	mov	r6,r2
 b004410:	200b883a 	mov	r5,r4
 b004414:	1809883a 	mov	r4,r3
 b004418:	b0059dc0 	call	b0059dc <epcs_sector_erase>
  }
  return ret_code;
 b00441c:	e0bffc17 	ldw	r2,-16(fp)
}
 b004420:	e037883a 	mov	sp,fp
 b004424:	dfc00117 	ldw	ra,4(sp)
 b004428:	df000017 	ldw	fp,0(sp)
 b00442c:	dec00204 	addi	sp,sp,8
 b004430:	f800283a 	ret

0b004434 <alt_epcs_flash_write_block>:
 * function type compatibility.
 */
int alt_epcs_flash_write_block(alt_flash_dev* flash_info, int block_offset,
                                      int data_offset, const void* data,
                                      int length)
{
 b004434:	defff404 	addi	sp,sp,-48
 b004438:	dfc00b15 	stw	ra,44(sp)
 b00443c:	df000a15 	stw	fp,40(sp)
 b004440:	df000a04 	addi	fp,sp,40
 b004444:	e13ffc15 	stw	r4,-16(fp)
 b004448:	e17ffd15 	stw	r5,-12(fp)
 b00444c:	e1bffe15 	stw	r6,-8(fp)
 b004450:	e1ffff15 	stw	r7,-4(fp)
  int ret_code;
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;
 b004454:	e0bffc17 	ldw	r2,-16(fp)
 b004458:	e0bff815 	stw	r2,-32(fp)

  int buffer_offset = 0;
 b00445c:	e03ff715 	stw	zero,-36(fp)
  int length_of_current_write;
  ret_code = alt_epcs_test_address(flash_info, data_offset);
 b004460:	e17ffe17 	ldw	r5,-8(fp)
 b004464:	e13ffc17 	ldw	r4,-16(fp)
 b004468:	b0043280 	call	b004328 <alt_epcs_test_address>
 b00446c:	e0bff915 	stw	r2,-28(fp)

  if (ret_code >= 0)
 b004470:	e0bff917 	ldw	r2,-28(fp)
 b004474:	10002916 	blt	r2,zero,b00451c <alt_epcs_flash_write_block+0xe8>
  {

    /* "Block" writes must be broken up into the page writes that
     * the device understands.  Partial page writes are allowed.
     */
    while (length)
 b004478:	00002606 	br	b004514 <alt_epcs_flash_write_block+0xe0>
    {
      int next_page_start = (data_offset + f->page_size) & ~(f->page_size - 1);
 b00447c:	e0bff817 	ldw	r2,-32(fp)
 b004480:	10c03117 	ldw	r3,196(r2)
 b004484:	e0bffe17 	ldw	r2,-8(fp)
 b004488:	1887883a 	add	r3,r3,r2
 b00448c:	e0bff817 	ldw	r2,-32(fp)
 b004490:	10803117 	ldw	r2,196(r2)
 b004494:	0085c83a 	sub	r2,zero,r2
 b004498:	1884703a 	and	r2,r3,r2
 b00449c:	e0bffa15 	stw	r2,-24(fp)
      length_of_current_write = MIN(length, next_page_start - data_offset);
 b0044a0:	e0fffa17 	ldw	r3,-24(fp)
 b0044a4:	e0bffe17 	ldw	r2,-8(fp)
 b0044a8:	1885c83a 	sub	r2,r3,r2
 b0044ac:	e0c00217 	ldw	r3,8(fp)
 b0044b0:	1880010e 	bge	r3,r2,b0044b8 <alt_epcs_flash_write_block+0x84>
 b0044b4:	1805883a 	mov	r2,r3
 b0044b8:	e0bffb15 	stw	r2,-20(fp)

      epcs_write_buffer(f->register_base, data_offset, &((const alt_u8*)data)[buffer_offset], length_of_current_write,
 b0044bc:	e0bff817 	ldw	r2,-32(fp)
 b0044c0:	11002e17 	ldw	r4,184(r2)
 b0044c4:	e0bff717 	ldw	r2,-36(fp)
 b0044c8:	e0ffff17 	ldw	r3,-4(fp)
 b0044cc:	1887883a 	add	r3,r3,r2
 b0044d0:	e0bff817 	ldw	r2,-32(fp)
 b0044d4:	10803217 	ldw	r2,200(r2)
 b0044d8:	d8800015 	stw	r2,0(sp)
 b0044dc:	e1fffb17 	ldw	r7,-20(fp)
 b0044e0:	180d883a 	mov	r6,r3
 b0044e4:	e17ffe17 	ldw	r5,-8(fp)
 b0044e8:	b005c8c0 	call	b005c8c <epcs_write_buffer>
          f->four_bytes_mode);

      length -= length_of_current_write;
 b0044ec:	e0c00217 	ldw	r3,8(fp)
 b0044f0:	e0bffb17 	ldw	r2,-20(fp)
 b0044f4:	1885c83a 	sub	r2,r3,r2
 b0044f8:	e0800215 	stw	r2,8(fp)
      buffer_offset += length_of_current_write;
 b0044fc:	e0fff717 	ldw	r3,-36(fp)
 b004500:	e0bffb17 	ldw	r2,-20(fp)
 b004504:	1885883a 	add	r2,r3,r2
 b004508:	e0bff715 	stw	r2,-36(fp)
      data_offset = next_page_start;
 b00450c:	e0bffa17 	ldw	r2,-24(fp)
 b004510:	e0bffe15 	stw	r2,-8(fp)
  {

    /* "Block" writes must be broken up into the page writes that
     * the device understands.  Partial page writes are allowed.
     */
    while (length)
 b004514:	e0800217 	ldw	r2,8(fp)
 b004518:	103fd81e 	bne	r2,zero,b00447c <__alt_mem_flash+0xff00347c>
      length -= length_of_current_write;
      buffer_offset += length_of_current_write;
      data_offset = next_page_start;
    }
  }
  return ret_code;
 b00451c:	e0bff917 	ldw	r2,-28(fp)
}
 b004520:	e037883a 	mov	sp,fp
 b004524:	dfc00117 	ldw	ra,4(sp)
 b004528:	df000017 	ldw	fp,0(sp)
 b00452c:	dec00204 	addi	sp,sp,8
 b004530:	f800283a 	ret

0b004534 <alt_epcs_flash_read>:
 *  to the beginning.  Reads that start beyond the end of the memory are
 *  flagged as errors with EIO (is there a better error code?).
 */
int alt_epcs_flash_read(alt_flash_dev* flash_info, int offset,
                        void* dest_addr, int length)
{
 b004534:	defff704 	addi	sp,sp,-36
 b004538:	dfc00815 	stw	ra,32(sp)
 b00453c:	df000715 	stw	fp,28(sp)
 b004540:	df000704 	addi	fp,sp,28
 b004544:	e13ffc15 	stw	r4,-16(fp)
 b004548:	e17ffd15 	stw	r5,-12(fp)
 b00454c:	e1bffe15 	stw	r6,-8(fp)
 b004550:	e1ffff15 	stw	r7,-4(fp)
  int ret_code = 0;
 b004554:	e03ffa15 	stw	zero,-24(fp)

  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;
 b004558:	e0bffc17 	ldw	r2,-16(fp)
 b00455c:	e0bffb15 	stw	r2,-20(fp)

  ret_code = alt_epcs_test_address(flash_info, offset);
 b004560:	e17ffd17 	ldw	r5,-12(fp)
 b004564:	e13ffc17 	ldw	r4,-16(fp)
 b004568:	b0043280 	call	b004328 <alt_epcs_test_address>
 b00456c:	e0bffa15 	stw	r2,-24(fp)

  if (ret_code >= 0)
 b004570:	e0bffa17 	ldw	r2,-24(fp)
 b004574:	10000f16 	blt	r2,zero,b0045b4 <alt_epcs_flash_read+0x80>
  {
    ret_code = epcs_read_buffer(f->register_base, offset, dest_addr, length,
 b004578:	e0bffb17 	ldw	r2,-20(fp)
 b00457c:	10c02e17 	ldw	r3,184(r2)
 b004580:	e0bffb17 	ldw	r2,-20(fp)
 b004584:	10803217 	ldw	r2,200(r2)
 b004588:	d8800015 	stw	r2,0(sp)
 b00458c:	e1ffff17 	ldw	r7,-4(fp)
 b004590:	e1bffe17 	ldw	r6,-8(fp)
 b004594:	e17ffd17 	ldw	r5,-12(fp)
 b004598:	1809883a 	mov	r4,r3
 b00459c:	b005ad80 	call	b005ad8 <epcs_read_buffer>
 b0045a0:	e0bffa15 	stw	r2,-24(fp)
                                f->four_bytes_mode);

    /* epcs_read_buffer returns the number of buffers read, but
     * alt_epcs_flash_read returns 0 on success, <0 on failure.
     */
    if (ret_code == length)
 b0045a4:	e0fffa17 	ldw	r3,-24(fp)
 b0045a8:	e0bfff17 	ldw	r2,-4(fp)
 b0045ac:	1880011e 	bne	r3,r2,b0045b4 <alt_epcs_flash_read+0x80>
    {
      ret_code = 0;
 b0045b0:	e03ffa15 	stw	zero,-24(fp)
    }
  }
  return ret_code;
 b0045b4:	e0bffa17 	ldw	r2,-24(fp)
}
 b0045b8:	e037883a 	mov	sp,fp
 b0045bc:	dfc00117 	ldw	ra,4(sp)
 b0045c0:	df000017 	ldw	fp,0(sp)
 b0045c4:	dec00204 	addi	sp,sp,8
 b0045c8:	f800283a 	ret

0b0045cc <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
 b0045cc:	defffa04 	addi	sp,sp,-24
 b0045d0:	dfc00515 	stw	ra,20(sp)
 b0045d4:	df000415 	stw	fp,16(sp)
 b0045d8:	df000404 	addi	fp,sp,16
 b0045dc:	e13ffd15 	stw	r4,-12(fp)
 b0045e0:	e17ffe15 	stw	r5,-8(fp)
 b0045e4:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 b0045e8:	e0bffd17 	ldw	r2,-12(fp)
 b0045ec:	10800017 	ldw	r2,0(r2)
 b0045f0:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
 b0045f4:	e0bffc17 	ldw	r2,-16(fp)
 b0045f8:	10c00a04 	addi	r3,r2,40
 b0045fc:	e0bffd17 	ldw	r2,-12(fp)
 b004600:	10800217 	ldw	r2,8(r2)
 b004604:	100f883a 	mov	r7,r2
 b004608:	e1bfff17 	ldw	r6,-4(fp)
 b00460c:	e17ffe17 	ldw	r5,-8(fp)
 b004610:	1809883a 	mov	r4,r3
 b004614:	b004bf40 	call	b004bf4 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
 b004618:	e037883a 	mov	sp,fp
 b00461c:	dfc00117 	ldw	ra,4(sp)
 b004620:	df000017 	ldw	fp,0(sp)
 b004624:	dec00204 	addi	sp,sp,8
 b004628:	f800283a 	ret

0b00462c <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
 b00462c:	defffa04 	addi	sp,sp,-24
 b004630:	dfc00515 	stw	ra,20(sp)
 b004634:	df000415 	stw	fp,16(sp)
 b004638:	df000404 	addi	fp,sp,16
 b00463c:	e13ffd15 	stw	r4,-12(fp)
 b004640:	e17ffe15 	stw	r5,-8(fp)
 b004644:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 b004648:	e0bffd17 	ldw	r2,-12(fp)
 b00464c:	10800017 	ldw	r2,0(r2)
 b004650:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
 b004654:	e0bffc17 	ldw	r2,-16(fp)
 b004658:	10c00a04 	addi	r3,r2,40
 b00465c:	e0bffd17 	ldw	r2,-12(fp)
 b004660:	10800217 	ldw	r2,8(r2)
 b004664:	100f883a 	mov	r7,r2
 b004668:	e1bfff17 	ldw	r6,-4(fp)
 b00466c:	e17ffe17 	ldw	r5,-8(fp)
 b004670:	1809883a 	mov	r4,r3
 b004674:	b004e100 	call	b004e10 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
 b004678:	e037883a 	mov	sp,fp
 b00467c:	dfc00117 	ldw	ra,4(sp)
 b004680:	df000017 	ldw	fp,0(sp)
 b004684:	dec00204 	addi	sp,sp,8
 b004688:	f800283a 	ret

0b00468c <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
 b00468c:	defffc04 	addi	sp,sp,-16
 b004690:	dfc00315 	stw	ra,12(sp)
 b004694:	df000215 	stw	fp,8(sp)
 b004698:	df000204 	addi	fp,sp,8
 b00469c:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 b0046a0:	e0bfff17 	ldw	r2,-4(fp)
 b0046a4:	10800017 	ldw	r2,0(r2)
 b0046a8:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
 b0046ac:	e0bffe17 	ldw	r2,-8(fp)
 b0046b0:	10c00a04 	addi	r3,r2,40
 b0046b4:	e0bfff17 	ldw	r2,-4(fp)
 b0046b8:	10800217 	ldw	r2,8(r2)
 b0046bc:	100b883a 	mov	r5,r2
 b0046c0:	1809883a 	mov	r4,r3
 b0046c4:	b004a9c0 	call	b004a9c <altera_avalon_jtag_uart_close>
}
 b0046c8:	e037883a 	mov	sp,fp
 b0046cc:	dfc00117 	ldw	ra,4(sp)
 b0046d0:	df000017 	ldw	fp,0(sp)
 b0046d4:	dec00204 	addi	sp,sp,8
 b0046d8:	f800283a 	ret

0b0046dc <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
 b0046dc:	defffa04 	addi	sp,sp,-24
 b0046e0:	dfc00515 	stw	ra,20(sp)
 b0046e4:	df000415 	stw	fp,16(sp)
 b0046e8:	df000404 	addi	fp,sp,16
 b0046ec:	e13ffd15 	stw	r4,-12(fp)
 b0046f0:	e17ffe15 	stw	r5,-8(fp)
 b0046f4:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
 b0046f8:	e0bffd17 	ldw	r2,-12(fp)
 b0046fc:	10800017 	ldw	r2,0(r2)
 b004700:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
 b004704:	e0bffc17 	ldw	r2,-16(fp)
 b004708:	10800a04 	addi	r2,r2,40
 b00470c:	e1bfff17 	ldw	r6,-4(fp)
 b004710:	e17ffe17 	ldw	r5,-8(fp)
 b004714:	1009883a 	mov	r4,r2
 b004718:	b004b040 	call	b004b04 <altera_avalon_jtag_uart_ioctl>
}
 b00471c:	e037883a 	mov	sp,fp
 b004720:	dfc00117 	ldw	ra,4(sp)
 b004724:	df000017 	ldw	fp,0(sp)
 b004728:	dec00204 	addi	sp,sp,8
 b00472c:	f800283a 	ret

0b004730 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
 b004730:	defffa04 	addi	sp,sp,-24
 b004734:	dfc00515 	stw	ra,20(sp)
 b004738:	df000415 	stw	fp,16(sp)
 b00473c:	df000404 	addi	fp,sp,16
 b004740:	e13ffd15 	stw	r4,-12(fp)
 b004744:	e17ffe15 	stw	r5,-8(fp)
 b004748:	e1bfff15 	stw	r6,-4(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
  ALT_SEM_CREATE(&sp->read_lock, 1);
  ALT_SEM_CREATE(&sp->write_lock, 1);

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 b00474c:	e0bffd17 	ldw	r2,-12(fp)
 b004750:	00c00044 	movi	r3,1
 b004754:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
 b004758:	e0bffd17 	ldw	r2,-12(fp)
 b00475c:	10800017 	ldw	r2,0(r2)
 b004760:	10800104 	addi	r2,r2,4
 b004764:	1007883a 	mov	r3,r2
 b004768:	e0bffd17 	ldw	r2,-12(fp)
 b00476c:	10800817 	ldw	r2,32(r2)
 b004770:	18800035 	stwio	r2,0(r3)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
 b004774:	e0bffe17 	ldw	r2,-8(fp)
 b004778:	e0ffff17 	ldw	r3,-4(fp)
 b00477c:	d8000015 	stw	zero,0(sp)
 b004780:	e1fffd17 	ldw	r7,-12(fp)
 b004784:	0182c034 	movhi	r6,2816
 b004788:	3191fc04 	addi	r6,r6,18416
 b00478c:	180b883a 	mov	r5,r3
 b004790:	1009883a 	mov	r4,r2
 b004794:	b0064680 	call	b006468 <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
 b004798:	e0bffd17 	ldw	r2,-12(fp)
 b00479c:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
 b0047a0:	e0bffd17 	ldw	r2,-12(fp)
 b0047a4:	10800204 	addi	r2,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 b0047a8:	d0e72417 	ldw	r3,-25456(gp)
 b0047ac:	e1fffd17 	ldw	r7,-12(fp)
 b0047b0:	0182c034 	movhi	r6,2816
 b0047b4:	31927f04 	addi	r6,r6,18940
 b0047b8:	180b883a 	mov	r5,r3
 b0047bc:	1009883a 	mov	r4,r2
 b0047c0:	b005f480 	call	b005f48 <alt_alarm_start>
 b0047c4:	1000040e 	bge	r2,zero,b0047d8 <altera_avalon_jtag_uart_init+0xa8>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
 b0047c8:	e0fffd17 	ldw	r3,-12(fp)
 b0047cc:	00a00034 	movhi	r2,32768
 b0047d0:	10bfffc4 	addi	r2,r2,-1
 b0047d4:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
 b0047d8:	0001883a 	nop
 b0047dc:	e037883a 	mov	sp,fp
 b0047e0:	dfc00117 	ldw	ra,4(sp)
 b0047e4:	df000017 	ldw	fp,0(sp)
 b0047e8:	dec00204 	addi	sp,sp,8
 b0047ec:	f800283a 	ret

0b0047f0 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
 b0047f0:	defff804 	addi	sp,sp,-32
 b0047f4:	df000715 	stw	fp,28(sp)
 b0047f8:	df000704 	addi	fp,sp,28
 b0047fc:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
 b004800:	e0bfff17 	ldw	r2,-4(fp)
 b004804:	e0bffb15 	stw	r2,-20(fp)
  unsigned int base = sp->base;
 b004808:	e0bffb17 	ldw	r2,-20(fp)
 b00480c:	10800017 	ldw	r2,0(r2)
 b004810:	e0bffc15 	stw	r2,-16(fp)
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 b004814:	e0bffc17 	ldw	r2,-16(fp)
 b004818:	10800104 	addi	r2,r2,4
 b00481c:	10800037 	ldwio	r2,0(r2)
 b004820:	e0bffd15 	stw	r2,-12(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
 b004824:	e0bffd17 	ldw	r2,-12(fp)
 b004828:	1080c00c 	andi	r2,r2,768
 b00482c:	10006d26 	beq	r2,zero,b0049e4 <altera_avalon_jtag_uart_irq+0x1f4>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
 b004830:	e0bffd17 	ldw	r2,-12(fp)
 b004834:	1080400c 	andi	r2,r2,256
 b004838:	10003526 	beq	r2,zero,b004910 <altera_avalon_jtag_uart_irq+0x120>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
 b00483c:	00800074 	movhi	r2,1
 b004840:	e0bff915 	stw	r2,-28(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 b004844:	e0bffb17 	ldw	r2,-20(fp)
 b004848:	10800a17 	ldw	r2,40(r2)
 b00484c:	10800044 	addi	r2,r2,1
 b004850:	1081ffcc 	andi	r2,r2,2047
 b004854:	e0bffe15 	stw	r2,-8(fp)
        if (next == sp->rx_out)
 b004858:	e0bffb17 	ldw	r2,-20(fp)
 b00485c:	10c00b17 	ldw	r3,44(r2)
 b004860:	e0bffe17 	ldw	r2,-8(fp)
 b004864:	18801526 	beq	r3,r2,b0048bc <altera_avalon_jtag_uart_irq+0xcc>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
 b004868:	e0bffc17 	ldw	r2,-16(fp)
 b00486c:	10800037 	ldwio	r2,0(r2)
 b004870:	e0bff915 	stw	r2,-28(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
 b004874:	e0bff917 	ldw	r2,-28(fp)
 b004878:	10a0000c 	andi	r2,r2,32768
 b00487c:	10001126 	beq	r2,zero,b0048c4 <altera_avalon_jtag_uart_irq+0xd4>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
 b004880:	e0bffb17 	ldw	r2,-20(fp)
 b004884:	10800a17 	ldw	r2,40(r2)
 b004888:	e0fff917 	ldw	r3,-28(fp)
 b00488c:	1809883a 	mov	r4,r3
 b004890:	e0fffb17 	ldw	r3,-20(fp)
 b004894:	1885883a 	add	r2,r3,r2
 b004898:	10800e04 	addi	r2,r2,56
 b00489c:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 b0048a0:	e0bffb17 	ldw	r2,-20(fp)
 b0048a4:	10800a17 	ldw	r2,40(r2)
 b0048a8:	10800044 	addi	r2,r2,1
 b0048ac:	10c1ffcc 	andi	r3,r2,2047
 b0048b0:	e0bffb17 	ldw	r2,-20(fp)
 b0048b4:	10c00a15 	stw	r3,40(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }
 b0048b8:	003fe206 	br	b004844 <__alt_mem_flash+0xff003844>
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
        if (next == sp->rx_out)
          break;
 b0048bc:	0001883a 	nop
 b0048c0:	00000106 	br	b0048c8 <altera_avalon_jtag_uart_irq+0xd8>
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;
 b0048c4:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
 b0048c8:	e0bff917 	ldw	r2,-28(fp)
 b0048cc:	10bfffec 	andhi	r2,r2,65535
 b0048d0:	10000f26 	beq	r2,zero,b004910 <altera_avalon_jtag_uart_irq+0x120>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 b0048d4:	e0bffb17 	ldw	r2,-20(fp)
 b0048d8:	10c00817 	ldw	r3,32(r2)
 b0048dc:	00bfff84 	movi	r2,-2
 b0048e0:	1886703a 	and	r3,r3,r2
 b0048e4:	e0bffb17 	ldw	r2,-20(fp)
 b0048e8:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
 b0048ec:	e0bffc17 	ldw	r2,-16(fp)
 b0048f0:	10800104 	addi	r2,r2,4
 b0048f4:	1007883a 	mov	r3,r2
 b0048f8:	e0bffb17 	ldw	r2,-20(fp)
 b0048fc:	10800817 	ldw	r2,32(r2)
 b004900:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 b004904:	e0bffc17 	ldw	r2,-16(fp)
 b004908:	10800104 	addi	r2,r2,4
 b00490c:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
 b004910:	e0bffd17 	ldw	r2,-12(fp)
 b004914:	1080800c 	andi	r2,r2,512
 b004918:	103fbe26 	beq	r2,zero,b004814 <__alt_mem_flash+0xff003814>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
 b00491c:	e0bffd17 	ldw	r2,-12(fp)
 b004920:	1004d43a 	srli	r2,r2,16
 b004924:	e0bffa15 	stw	r2,-24(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
 b004928:	00001406 	br	b00497c <altera_avalon_jtag_uart_irq+0x18c>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
 b00492c:	e0bffc17 	ldw	r2,-16(fp)
 b004930:	e0fffb17 	ldw	r3,-20(fp)
 b004934:	18c00d17 	ldw	r3,52(r3)
 b004938:	e13ffb17 	ldw	r4,-20(fp)
 b00493c:	20c7883a 	add	r3,r4,r3
 b004940:	18c20e04 	addi	r3,r3,2104
 b004944:	18c00003 	ldbu	r3,0(r3)
 b004948:	18c03fcc 	andi	r3,r3,255
 b00494c:	18c0201c 	xori	r3,r3,128
 b004950:	18ffe004 	addi	r3,r3,-128
 b004954:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 b004958:	e0bffb17 	ldw	r2,-20(fp)
 b00495c:	10800d17 	ldw	r2,52(r2)
 b004960:	10800044 	addi	r2,r2,1
 b004964:	10c1ffcc 	andi	r3,r2,2047
 b004968:	e0bffb17 	ldw	r2,-20(fp)
 b00496c:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
 b004970:	e0bffa17 	ldw	r2,-24(fp)
 b004974:	10bfffc4 	addi	r2,r2,-1
 b004978:	e0bffa15 	stw	r2,-24(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
 b00497c:	e0bffa17 	ldw	r2,-24(fp)
 b004980:	10000526 	beq	r2,zero,b004998 <altera_avalon_jtag_uart_irq+0x1a8>
 b004984:	e0bffb17 	ldw	r2,-20(fp)
 b004988:	10c00d17 	ldw	r3,52(r2)
 b00498c:	e0bffb17 	ldw	r2,-20(fp)
 b004990:	10800c17 	ldw	r2,48(r2)
 b004994:	18bfe51e 	bne	r3,r2,b00492c <__alt_mem_flash+0xff00392c>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
 b004998:	e0bffa17 	ldw	r2,-24(fp)
 b00499c:	103f9d26 	beq	r2,zero,b004814 <__alt_mem_flash+0xff003814>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 b0049a0:	e0bffb17 	ldw	r2,-20(fp)
 b0049a4:	10c00817 	ldw	r3,32(r2)
 b0049a8:	00bfff44 	movi	r2,-3
 b0049ac:	1886703a 	and	r3,r3,r2
 b0049b0:	e0bffb17 	ldw	r2,-20(fp)
 b0049b4:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 b0049b8:	e0bffb17 	ldw	r2,-20(fp)
 b0049bc:	10800017 	ldw	r2,0(r2)
 b0049c0:	10800104 	addi	r2,r2,4
 b0049c4:	1007883a 	mov	r3,r2
 b0049c8:	e0bffb17 	ldw	r2,-20(fp)
 b0049cc:	10800817 	ldw	r2,32(r2)
 b0049d0:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 b0049d4:	e0bffc17 	ldw	r2,-16(fp)
 b0049d8:	10800104 	addi	r2,r2,4
 b0049dc:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
 b0049e0:	003f8c06 	br	b004814 <__alt_mem_flash+0xff003814>
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
      break;
 b0049e4:	0001883a 	nop
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
}
 b0049e8:	0001883a 	nop
 b0049ec:	e037883a 	mov	sp,fp
 b0049f0:	df000017 	ldw	fp,0(sp)
 b0049f4:	dec00104 	addi	sp,sp,4
 b0049f8:	f800283a 	ret

0b0049fc <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
 b0049fc:	defff804 	addi	sp,sp,-32
 b004a00:	df000715 	stw	fp,28(sp)
 b004a04:	df000704 	addi	fp,sp,28
 b004a08:	e13ffb15 	stw	r4,-20(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
 b004a0c:	e0bffb17 	ldw	r2,-20(fp)
 b004a10:	e0bff915 	stw	r2,-28(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
 b004a14:	e0bff917 	ldw	r2,-28(fp)
 b004a18:	10800017 	ldw	r2,0(r2)
 b004a1c:	10800104 	addi	r2,r2,4
 b004a20:	10800037 	ldwio	r2,0(r2)
 b004a24:	e0bffa15 	stw	r2,-24(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
 b004a28:	e0bffa17 	ldw	r2,-24(fp)
 b004a2c:	1081000c 	andi	r2,r2,1024
 b004a30:	10000b26 	beq	r2,zero,b004a60 <altera_avalon_jtag_uart_timeout+0x64>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
 b004a34:	e0bff917 	ldw	r2,-28(fp)
 b004a38:	10800017 	ldw	r2,0(r2)
 b004a3c:	10800104 	addi	r2,r2,4
 b004a40:	1007883a 	mov	r3,r2
 b004a44:	e0bff917 	ldw	r2,-28(fp)
 b004a48:	10800817 	ldw	r2,32(r2)
 b004a4c:	10810014 	ori	r2,r2,1024
 b004a50:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
 b004a54:	e0bff917 	ldw	r2,-28(fp)
 b004a58:	10000915 	stw	zero,36(r2)
 b004a5c:	00000a06 	br	b004a88 <altera_avalon_jtag_uart_timeout+0x8c>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
 b004a60:	e0bff917 	ldw	r2,-28(fp)
 b004a64:	10c00917 	ldw	r3,36(r2)
 b004a68:	00a00034 	movhi	r2,32768
 b004a6c:	10bfff04 	addi	r2,r2,-4
 b004a70:	10c00536 	bltu	r2,r3,b004a88 <altera_avalon_jtag_uart_timeout+0x8c>
    sp->host_inactive++;
 b004a74:	e0bff917 	ldw	r2,-28(fp)
 b004a78:	10800917 	ldw	r2,36(r2)
 b004a7c:	10c00044 	addi	r3,r2,1
 b004a80:	e0bff917 	ldw	r2,-28(fp)
 b004a84:	10c00915 	stw	r3,36(r2)
 b004a88:	d0a72417 	ldw	r2,-25456(gp)
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
    }
  }

  return alt_ticks_per_second();
}
 b004a8c:	e037883a 	mov	sp,fp
 b004a90:	df000017 	ldw	fp,0(sp)
 b004a94:	dec00104 	addi	sp,sp,4
 b004a98:	f800283a 	ret

0b004a9c <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
 b004a9c:	defffd04 	addi	sp,sp,-12
 b004aa0:	df000215 	stw	fp,8(sp)
 b004aa4:	df000204 	addi	fp,sp,8
 b004aa8:	e13ffe15 	stw	r4,-8(fp)
 b004aac:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 b004ab0:	00000506 	br	b004ac8 <altera_avalon_jtag_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
 b004ab4:	e0bfff17 	ldw	r2,-4(fp)
 b004ab8:	1090000c 	andi	r2,r2,16384
 b004abc:	10000226 	beq	r2,zero,b004ac8 <altera_avalon_jtag_uart_close+0x2c>
      return -EWOULDBLOCK; 
 b004ac0:	00bffd44 	movi	r2,-11
 b004ac4:	00000b06 	br	b004af4 <altera_avalon_jtag_uart_close+0x58>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 b004ac8:	e0bffe17 	ldw	r2,-8(fp)
 b004acc:	10c00d17 	ldw	r3,52(r2)
 b004ad0:	e0bffe17 	ldw	r2,-8(fp)
 b004ad4:	10800c17 	ldw	r2,48(r2)
 b004ad8:	18800526 	beq	r3,r2,b004af0 <altera_avalon_jtag_uart_close+0x54>
 b004adc:	e0bffe17 	ldw	r2,-8(fp)
 b004ae0:	10c00917 	ldw	r3,36(r2)
 b004ae4:	e0bffe17 	ldw	r2,-8(fp)
 b004ae8:	10800117 	ldw	r2,4(r2)
 b004aec:	18bff136 	bltu	r3,r2,b004ab4 <__alt_mem_flash+0xff003ab4>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
 b004af0:	0005883a 	mov	r2,zero
}
 b004af4:	e037883a 	mov	sp,fp
 b004af8:	df000017 	ldw	fp,0(sp)
 b004afc:	dec00104 	addi	sp,sp,4
 b004b00:	f800283a 	ret

0b004b04 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
 b004b04:	defffa04 	addi	sp,sp,-24
 b004b08:	df000515 	stw	fp,20(sp)
 b004b0c:	df000504 	addi	fp,sp,20
 b004b10:	e13ffd15 	stw	r4,-12(fp)
 b004b14:	e17ffe15 	stw	r5,-8(fp)
 b004b18:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
 b004b1c:	00bff9c4 	movi	r2,-25
 b004b20:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
 b004b24:	e0bffe17 	ldw	r2,-8(fp)
 b004b28:	10da8060 	cmpeqi	r3,r2,27137
 b004b2c:	1800031e 	bne	r3,zero,b004b3c <altera_avalon_jtag_uart_ioctl+0x38>
 b004b30:	109a80a0 	cmpeqi	r2,r2,27138
 b004b34:	1000181e 	bne	r2,zero,b004b98 <altera_avalon_jtag_uart_ioctl+0x94>
      rc = 0;
    }
    break;

  default:
    break;
 b004b38:	00002906 	br	b004be0 <altera_avalon_jtag_uart_ioctl+0xdc>

  switch (req)
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
 b004b3c:	e0bffd17 	ldw	r2,-12(fp)
 b004b40:	10c00117 	ldw	r3,4(r2)
 b004b44:	00a00034 	movhi	r2,32768
 b004b48:	10bfffc4 	addi	r2,r2,-1
 b004b4c:	18802126 	beq	r3,r2,b004bd4 <altera_avalon_jtag_uart_ioctl+0xd0>
    {
      int timeout = *((int *)arg);
 b004b50:	e0bfff17 	ldw	r2,-4(fp)
 b004b54:	10800017 	ldw	r2,0(r2)
 b004b58:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
 b004b5c:	e0bffc17 	ldw	r2,-16(fp)
 b004b60:	10800090 	cmplti	r2,r2,2
 b004b64:	1000061e 	bne	r2,zero,b004b80 <altera_avalon_jtag_uart_ioctl+0x7c>
 b004b68:	e0fffc17 	ldw	r3,-16(fp)
 b004b6c:	00a00034 	movhi	r2,32768
 b004b70:	10bfffc4 	addi	r2,r2,-1
 b004b74:	18800226 	beq	r3,r2,b004b80 <altera_avalon_jtag_uart_ioctl+0x7c>
 b004b78:	e0bffc17 	ldw	r2,-16(fp)
 b004b7c:	00000206 	br	b004b88 <altera_avalon_jtag_uart_ioctl+0x84>
 b004b80:	00a00034 	movhi	r2,32768
 b004b84:	10bfff84 	addi	r2,r2,-2
 b004b88:	e0fffd17 	ldw	r3,-12(fp)
 b004b8c:	18800115 	stw	r2,4(r3)
      rc = 0;
 b004b90:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
 b004b94:	00000f06 	br	b004bd4 <altera_avalon_jtag_uart_ioctl+0xd0>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
 b004b98:	e0bffd17 	ldw	r2,-12(fp)
 b004b9c:	10c00117 	ldw	r3,4(r2)
 b004ba0:	00a00034 	movhi	r2,32768
 b004ba4:	10bfffc4 	addi	r2,r2,-1
 b004ba8:	18800c26 	beq	r3,r2,b004bdc <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
 b004bac:	e0bffd17 	ldw	r2,-12(fp)
 b004bb0:	10c00917 	ldw	r3,36(r2)
 b004bb4:	e0bffd17 	ldw	r2,-12(fp)
 b004bb8:	10800117 	ldw	r2,4(r2)
 b004bbc:	1885803a 	cmpltu	r2,r3,r2
 b004bc0:	10c03fcc 	andi	r3,r2,255
 b004bc4:	e0bfff17 	ldw	r2,-4(fp)
 b004bc8:	10c00015 	stw	r3,0(r2)
      rc = 0;
 b004bcc:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
 b004bd0:	00000206 	br	b004bdc <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
      rc = 0;
    }
    break;
 b004bd4:	0001883a 	nop
 b004bd8:	00000106 	br	b004be0 <altera_avalon_jtag_uart_ioctl+0xdc>
    if (sp->timeout != INT_MAX)
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
      rc = 0;
    }
    break;
 b004bdc:	0001883a 	nop

  default:
    break;
  }

  return rc;
 b004be0:	e0bffb17 	ldw	r2,-20(fp)
}
 b004be4:	e037883a 	mov	sp,fp
 b004be8:	df000017 	ldw	fp,0(sp)
 b004bec:	dec00104 	addi	sp,sp,4
 b004bf0:	f800283a 	ret

0b004bf4 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
 b004bf4:	defff304 	addi	sp,sp,-52
 b004bf8:	dfc00c15 	stw	ra,48(sp)
 b004bfc:	df000b15 	stw	fp,44(sp)
 b004c00:	df000b04 	addi	fp,sp,44
 b004c04:	e13ffc15 	stw	r4,-16(fp)
 b004c08:	e17ffd15 	stw	r5,-12(fp)
 b004c0c:	e1bffe15 	stw	r6,-8(fp)
 b004c10:	e1ffff15 	stw	r7,-4(fp)
  char * ptr = buffer;
 b004c14:	e0bffd17 	ldw	r2,-12(fp)
 b004c18:	e0bff515 	stw	r2,-44(fp)
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
 b004c1c:	00004706 	br	b004d3c <altera_avalon_jtag_uart_read+0x148>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
 b004c20:	e0bffc17 	ldw	r2,-16(fp)
 b004c24:	10800a17 	ldw	r2,40(r2)
 b004c28:	e0bff715 	stw	r2,-36(fp)
      out = sp->rx_out;
 b004c2c:	e0bffc17 	ldw	r2,-16(fp)
 b004c30:	10800b17 	ldw	r2,44(r2)
 b004c34:	e0bff815 	stw	r2,-32(fp)

      if (in >= out)
 b004c38:	e0fff717 	ldw	r3,-36(fp)
 b004c3c:	e0bff817 	ldw	r2,-32(fp)
 b004c40:	18800536 	bltu	r3,r2,b004c58 <altera_avalon_jtag_uart_read+0x64>
        n = in - out;
 b004c44:	e0fff717 	ldw	r3,-36(fp)
 b004c48:	e0bff817 	ldw	r2,-32(fp)
 b004c4c:	1885c83a 	sub	r2,r3,r2
 b004c50:	e0bff615 	stw	r2,-40(fp)
 b004c54:	00000406 	br	b004c68 <altera_avalon_jtag_uart_read+0x74>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
 b004c58:	00c20004 	movi	r3,2048
 b004c5c:	e0bff817 	ldw	r2,-32(fp)
 b004c60:	1885c83a 	sub	r2,r3,r2
 b004c64:	e0bff615 	stw	r2,-40(fp)

      if (n == 0)
 b004c68:	e0bff617 	ldw	r2,-40(fp)
 b004c6c:	10001e26 	beq	r2,zero,b004ce8 <altera_avalon_jtag_uart_read+0xf4>
        break; /* No more data available */

      if (n > space)
 b004c70:	e0fffe17 	ldw	r3,-8(fp)
 b004c74:	e0bff617 	ldw	r2,-40(fp)
 b004c78:	1880022e 	bgeu	r3,r2,b004c84 <altera_avalon_jtag_uart_read+0x90>
        n = space;
 b004c7c:	e0bffe17 	ldw	r2,-8(fp)
 b004c80:	e0bff615 	stw	r2,-40(fp)

      memcpy(ptr, sp->rx_buf + out, n);
 b004c84:	e0bffc17 	ldw	r2,-16(fp)
 b004c88:	10c00e04 	addi	r3,r2,56
 b004c8c:	e0bff817 	ldw	r2,-32(fp)
 b004c90:	1885883a 	add	r2,r3,r2
 b004c94:	e1bff617 	ldw	r6,-40(fp)
 b004c98:	100b883a 	mov	r5,r2
 b004c9c:	e13ff517 	ldw	r4,-44(fp)
 b004ca0:	b0016880 	call	b001688 <memcpy>
      ptr   += n;
 b004ca4:	e0fff517 	ldw	r3,-44(fp)
 b004ca8:	e0bff617 	ldw	r2,-40(fp)
 b004cac:	1885883a 	add	r2,r3,r2
 b004cb0:	e0bff515 	stw	r2,-44(fp)
      space -= n;
 b004cb4:	e0fffe17 	ldw	r3,-8(fp)
 b004cb8:	e0bff617 	ldw	r2,-40(fp)
 b004cbc:	1885c83a 	sub	r2,r3,r2
 b004cc0:	e0bffe15 	stw	r2,-8(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 b004cc4:	e0fff817 	ldw	r3,-32(fp)
 b004cc8:	e0bff617 	ldw	r2,-40(fp)
 b004ccc:	1885883a 	add	r2,r3,r2
 b004cd0:	10c1ffcc 	andi	r3,r2,2047
 b004cd4:	e0bffc17 	ldw	r2,-16(fp)
 b004cd8:	10c00b15 	stw	r3,44(r2)
    }
    while (space > 0);
 b004cdc:	e0bffe17 	ldw	r2,-8(fp)
 b004ce0:	00bfcf16 	blt	zero,r2,b004c20 <__alt_mem_flash+0xff003c20>
 b004ce4:	00000106 	br	b004cec <altera_avalon_jtag_uart_read+0xf8>
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;

      if (n == 0)
        break; /* No more data available */
 b004ce8:	0001883a 	nop
      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
 b004cec:	e0fff517 	ldw	r3,-44(fp)
 b004cf0:	e0bffd17 	ldw	r2,-12(fp)
 b004cf4:	1880141e 	bne	r3,r2,b004d48 <altera_avalon_jtag_uart_read+0x154>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
 b004cf8:	e0bfff17 	ldw	r2,-4(fp)
 b004cfc:	1090000c 	andi	r2,r2,16384
 b004d00:	1000131e 	bne	r2,zero,b004d50 <altera_avalon_jtag_uart_read+0x15c>
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
        ;
    }
#else
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
 b004d04:	0001883a 	nop
 b004d08:	e0bffc17 	ldw	r2,-16(fp)
 b004d0c:	10c00a17 	ldw	r3,40(r2)
 b004d10:	e0bff717 	ldw	r2,-36(fp)
 b004d14:	1880051e 	bne	r3,r2,b004d2c <altera_avalon_jtag_uart_read+0x138>
 b004d18:	e0bffc17 	ldw	r2,-16(fp)
 b004d1c:	10c00917 	ldw	r3,36(r2)
 b004d20:	e0bffc17 	ldw	r2,-16(fp)
 b004d24:	10800117 	ldw	r2,4(r2)
 b004d28:	18bff736 	bltu	r3,r2,b004d08 <__alt_mem_flash+0xff003d08>
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
 b004d2c:	e0bffc17 	ldw	r2,-16(fp)
 b004d30:	10c00a17 	ldw	r3,40(r2)
 b004d34:	e0bff717 	ldw	r2,-36(fp)
 b004d38:	18800726 	beq	r3,r2,b004d58 <altera_avalon_jtag_uart_read+0x164>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
 b004d3c:	e0bffe17 	ldw	r2,-8(fp)
 b004d40:	00bfb716 	blt	zero,r2,b004c20 <__alt_mem_flash+0xff003c20>
 b004d44:	00000506 	br	b004d5c <altera_avalon_jtag_uart_read+0x168>
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
      break;
 b004d48:	0001883a 	nop
 b004d4c:	00000306 	br	b004d5c <altera_avalon_jtag_uart_read+0x168>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
      break;
 b004d50:	0001883a 	nop
 b004d54:	00000106 	br	b004d5c <altera_avalon_jtag_uart_read+0x168>
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
      break;
 b004d58:	0001883a 	nop
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);

  if (ptr != buffer)
 b004d5c:	e0fff517 	ldw	r3,-44(fp)
 b004d60:	e0bffd17 	ldw	r2,-12(fp)
 b004d64:	18801826 	beq	r3,r2,b004dc8 <altera_avalon_jtag_uart_read+0x1d4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 b004d68:	0005303a 	rdctl	r2,status
 b004d6c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 b004d70:	e0fffb17 	ldw	r3,-20(fp)
 b004d74:	00bfff84 	movi	r2,-2
 b004d78:	1884703a 	and	r2,r3,r2
 b004d7c:	1001703a 	wrctl	status,r2
  
  return context;
 b004d80:	e0bffb17 	ldw	r2,-20(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
 b004d84:	e0bffa15 	stw	r2,-24(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 b004d88:	e0bffc17 	ldw	r2,-16(fp)
 b004d8c:	10800817 	ldw	r2,32(r2)
 b004d90:	10c00054 	ori	r3,r2,1
 b004d94:	e0bffc17 	ldw	r2,-16(fp)
 b004d98:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 b004d9c:	e0bffc17 	ldw	r2,-16(fp)
 b004da0:	10800017 	ldw	r2,0(r2)
 b004da4:	10800104 	addi	r2,r2,4
 b004da8:	1007883a 	mov	r3,r2
 b004dac:	e0bffc17 	ldw	r2,-16(fp)
 b004db0:	10800817 	ldw	r2,32(r2)
 b004db4:	18800035 	stwio	r2,0(r3)
 b004db8:	e0bffa17 	ldw	r2,-24(fp)
 b004dbc:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 b004dc0:	e0bff917 	ldw	r2,-28(fp)
 b004dc4:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
 b004dc8:	e0fff517 	ldw	r3,-44(fp)
 b004dcc:	e0bffd17 	ldw	r2,-12(fp)
 b004dd0:	18800426 	beq	r3,r2,b004de4 <altera_avalon_jtag_uart_read+0x1f0>
    return ptr - buffer;
 b004dd4:	e0fff517 	ldw	r3,-44(fp)
 b004dd8:	e0bffd17 	ldw	r2,-12(fp)
 b004ddc:	1885c83a 	sub	r2,r3,r2
 b004de0:	00000606 	br	b004dfc <altera_avalon_jtag_uart_read+0x208>
  else if (flags & O_NONBLOCK)
 b004de4:	e0bfff17 	ldw	r2,-4(fp)
 b004de8:	1090000c 	andi	r2,r2,16384
 b004dec:	10000226 	beq	r2,zero,b004df8 <altera_avalon_jtag_uart_read+0x204>
    return -EWOULDBLOCK;
 b004df0:	00bffd44 	movi	r2,-11
 b004df4:	00000106 	br	b004dfc <altera_avalon_jtag_uart_read+0x208>
  else
    return -EIO;
 b004df8:	00bffec4 	movi	r2,-5
}
 b004dfc:	e037883a 	mov	sp,fp
 b004e00:	dfc00117 	ldw	ra,4(sp)
 b004e04:	df000017 	ldw	fp,0(sp)
 b004e08:	dec00204 	addi	sp,sp,8
 b004e0c:	f800283a 	ret

0b004e10 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
 b004e10:	defff304 	addi	sp,sp,-52
 b004e14:	dfc00c15 	stw	ra,48(sp)
 b004e18:	df000b15 	stw	fp,44(sp)
 b004e1c:	df000b04 	addi	fp,sp,44
 b004e20:	e13ffc15 	stw	r4,-16(fp)
 b004e24:	e17ffd15 	stw	r5,-12(fp)
 b004e28:	e1bffe15 	stw	r6,-8(fp)
 b004e2c:	e1ffff15 	stw	r7,-4(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
 b004e30:	e03ff515 	stw	zero,-44(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
 b004e34:	e0bffd17 	ldw	r2,-12(fp)
 b004e38:	e0bff715 	stw	r2,-36(fp)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 b004e3c:	00003706 	br	b004f1c <altera_avalon_jtag_uart_write+0x10c>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
 b004e40:	e0bffc17 	ldw	r2,-16(fp)
 b004e44:	10800c17 	ldw	r2,48(r2)
 b004e48:	e0bff915 	stw	r2,-28(fp)
      out = sp->tx_out;
 b004e4c:	e0bffc17 	ldw	r2,-16(fp)
 b004e50:	10800d17 	ldw	r2,52(r2)
 b004e54:	e0bff515 	stw	r2,-44(fp)

      if (in < out)
 b004e58:	e0fff917 	ldw	r3,-28(fp)
 b004e5c:	e0bff517 	ldw	r2,-44(fp)
 b004e60:	1880062e 	bgeu	r3,r2,b004e7c <altera_avalon_jtag_uart_write+0x6c>
        n = out - 1 - in;
 b004e64:	e0fff517 	ldw	r3,-44(fp)
 b004e68:	e0bff917 	ldw	r2,-28(fp)
 b004e6c:	1885c83a 	sub	r2,r3,r2
 b004e70:	10bfffc4 	addi	r2,r2,-1
 b004e74:	e0bff615 	stw	r2,-40(fp)
 b004e78:	00000b06 	br	b004ea8 <altera_avalon_jtag_uart_write+0x98>
      else if (out > 0)
 b004e7c:	e0bff517 	ldw	r2,-44(fp)
 b004e80:	10000526 	beq	r2,zero,b004e98 <altera_avalon_jtag_uart_write+0x88>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
 b004e84:	00c20004 	movi	r3,2048
 b004e88:	e0bff917 	ldw	r2,-28(fp)
 b004e8c:	1885c83a 	sub	r2,r3,r2
 b004e90:	e0bff615 	stw	r2,-40(fp)
 b004e94:	00000406 	br	b004ea8 <altera_avalon_jtag_uart_write+0x98>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
 b004e98:	00c1ffc4 	movi	r3,2047
 b004e9c:	e0bff917 	ldw	r2,-28(fp)
 b004ea0:	1885c83a 	sub	r2,r3,r2
 b004ea4:	e0bff615 	stw	r2,-40(fp)

      if (n == 0)
 b004ea8:	e0bff617 	ldw	r2,-40(fp)
 b004eac:	10001e26 	beq	r2,zero,b004f28 <altera_avalon_jtag_uart_write+0x118>
        break;

      if (n > count)
 b004eb0:	e0fffe17 	ldw	r3,-8(fp)
 b004eb4:	e0bff617 	ldw	r2,-40(fp)
 b004eb8:	1880022e 	bgeu	r3,r2,b004ec4 <altera_avalon_jtag_uart_write+0xb4>
        n = count;
 b004ebc:	e0bffe17 	ldw	r2,-8(fp)
 b004ec0:	e0bff615 	stw	r2,-40(fp)

      memcpy(sp->tx_buf + in, ptr, n);
 b004ec4:	e0bffc17 	ldw	r2,-16(fp)
 b004ec8:	10c20e04 	addi	r3,r2,2104
 b004ecc:	e0bff917 	ldw	r2,-28(fp)
 b004ed0:	1885883a 	add	r2,r3,r2
 b004ed4:	e1bff617 	ldw	r6,-40(fp)
 b004ed8:	e17ffd17 	ldw	r5,-12(fp)
 b004edc:	1009883a 	mov	r4,r2
 b004ee0:	b0016880 	call	b001688 <memcpy>
      ptr   += n;
 b004ee4:	e0fffd17 	ldw	r3,-12(fp)
 b004ee8:	e0bff617 	ldw	r2,-40(fp)
 b004eec:	1885883a 	add	r2,r3,r2
 b004ef0:	e0bffd15 	stw	r2,-12(fp)
      count -= n;
 b004ef4:	e0fffe17 	ldw	r3,-8(fp)
 b004ef8:	e0bff617 	ldw	r2,-40(fp)
 b004efc:	1885c83a 	sub	r2,r3,r2
 b004f00:	e0bffe15 	stw	r2,-8(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 b004f04:	e0fff917 	ldw	r3,-28(fp)
 b004f08:	e0bff617 	ldw	r2,-40(fp)
 b004f0c:	1885883a 	add	r2,r3,r2
 b004f10:	10c1ffcc 	andi	r3,r2,2047
 b004f14:	e0bffc17 	ldw	r2,-16(fp)
 b004f18:	10c00c15 	stw	r3,48(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 b004f1c:	e0bffe17 	ldw	r2,-8(fp)
 b004f20:	00bfc716 	blt	zero,r2,b004e40 <__alt_mem_flash+0xff003e40>
 b004f24:	00000106 	br	b004f2c <altera_avalon_jtag_uart_write+0x11c>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;

      if (n == 0)
        break;
 b004f28:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 b004f2c:	0005303a 	rdctl	r2,status
 b004f30:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 b004f34:	e0fffb17 	ldw	r3,-20(fp)
 b004f38:	00bfff84 	movi	r2,-2
 b004f3c:	1884703a 	and	r2,r3,r2
 b004f40:	1001703a 	wrctl	status,r2
  
  return context;
 b004f44:	e0bffb17 	ldw	r2,-20(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
 b004f48:	e0bffa15 	stw	r2,-24(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 b004f4c:	e0bffc17 	ldw	r2,-16(fp)
 b004f50:	10800817 	ldw	r2,32(r2)
 b004f54:	10c00094 	ori	r3,r2,2
 b004f58:	e0bffc17 	ldw	r2,-16(fp)
 b004f5c:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 b004f60:	e0bffc17 	ldw	r2,-16(fp)
 b004f64:	10800017 	ldw	r2,0(r2)
 b004f68:	10800104 	addi	r2,r2,4
 b004f6c:	1007883a 	mov	r3,r2
 b004f70:	e0bffc17 	ldw	r2,-16(fp)
 b004f74:	10800817 	ldw	r2,32(r2)
 b004f78:	18800035 	stwio	r2,0(r3)
 b004f7c:	e0bffa17 	ldw	r2,-24(fp)
 b004f80:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 b004f84:	e0bff817 	ldw	r2,-32(fp)
 b004f88:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
 b004f8c:	e0bffe17 	ldw	r2,-8(fp)
 b004f90:	0080100e 	bge	zero,r2,b004fd4 <altera_avalon_jtag_uart_write+0x1c4>
    {
      if (flags & O_NONBLOCK)
 b004f94:	e0bfff17 	ldw	r2,-4(fp)
 b004f98:	1090000c 	andi	r2,r2,16384
 b004f9c:	1000101e 	bne	r2,zero,b004fe0 <altera_avalon_jtag_uart_write+0x1d0>
      /*
       * No OS present: Always wait for data to be removed from buffer.  Once
       * the interrupt routine has removed some data then we will be able to
       * insert some more.
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
 b004fa0:	0001883a 	nop
 b004fa4:	e0bffc17 	ldw	r2,-16(fp)
 b004fa8:	10c00d17 	ldw	r3,52(r2)
 b004fac:	e0bff517 	ldw	r2,-44(fp)
 b004fb0:	1880051e 	bne	r3,r2,b004fc8 <altera_avalon_jtag_uart_write+0x1b8>
 b004fb4:	e0bffc17 	ldw	r2,-16(fp)
 b004fb8:	10c00917 	ldw	r3,36(r2)
 b004fbc:	e0bffc17 	ldw	r2,-16(fp)
 b004fc0:	10800117 	ldw	r2,4(r2)
 b004fc4:	18bff736 	bltu	r3,r2,b004fa4 <__alt_mem_flash+0xff003fa4>
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
 b004fc8:	e0bffc17 	ldw	r2,-16(fp)
 b004fcc:	10800917 	ldw	r2,36(r2)
 b004fd0:	1000051e 	bne	r2,zero,b004fe8 <altera_avalon_jtag_uart_write+0x1d8>
         break;
    }
  }
  while (count > 0);
 b004fd4:	e0bffe17 	ldw	r2,-8(fp)
 b004fd8:	00bfd016 	blt	zero,r2,b004f1c <__alt_mem_flash+0xff003f1c>
 b004fdc:	00000306 	br	b004fec <altera_avalon_jtag_uart_write+0x1dc>
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
        break;
 b004fe0:	0001883a 	nop
 b004fe4:	00000106 	br	b004fec <altera_avalon_jtag_uart_write+0x1dc>
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
         break;
 b004fe8:	0001883a 	nop
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);

  if (ptr != start)
 b004fec:	e0fffd17 	ldw	r3,-12(fp)
 b004ff0:	e0bff717 	ldw	r2,-36(fp)
 b004ff4:	18800426 	beq	r3,r2,b005008 <altera_avalon_jtag_uart_write+0x1f8>
    return ptr - start;
 b004ff8:	e0fffd17 	ldw	r3,-12(fp)
 b004ffc:	e0bff717 	ldw	r2,-36(fp)
 b005000:	1885c83a 	sub	r2,r3,r2
 b005004:	00000606 	br	b005020 <altera_avalon_jtag_uart_write+0x210>
  else if (flags & O_NONBLOCK)
 b005008:	e0bfff17 	ldw	r2,-4(fp)
 b00500c:	1090000c 	andi	r2,r2,16384
 b005010:	10000226 	beq	r2,zero,b00501c <altera_avalon_jtag_uart_write+0x20c>
    return -EWOULDBLOCK;
 b005014:	00bffd44 	movi	r2,-11
 b005018:	00000106 	br	b005020 <altera_avalon_jtag_uart_write+0x210>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
 b00501c:	00bffec4 	movi	r2,-5
}
 b005020:	e037883a 	mov	sp,fp
 b005024:	dfc00117 	ldw	ra,4(sp)
 b005028:	df000017 	ldw	fp,0(sp)
 b00502c:	dec00204 	addi	sp,sp,8
 b005030:	f800283a 	ret

0b005034 <altera_avalon_uart_read_fd>:
 *
 */

int 
altera_avalon_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
 b005034:	defffa04 	addi	sp,sp,-24
 b005038:	dfc00515 	stw	ra,20(sp)
 b00503c:	df000415 	stw	fp,16(sp)
 b005040:	df000404 	addi	fp,sp,16
 b005044:	e13ffd15 	stw	r4,-12(fp)
 b005048:	e17ffe15 	stw	r5,-8(fp)
 b00504c:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
 b005050:	e0bffd17 	ldw	r2,-12(fp)
 b005054:	10800017 	ldw	r2,0(r2)
 b005058:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_read(&dev->state, buffer, space,
 b00505c:	e0bffc17 	ldw	r2,-16(fp)
 b005060:	10c00a04 	addi	r3,r2,40
 b005064:	e0bffd17 	ldw	r2,-12(fp)
 b005068:	10800217 	ldw	r2,8(r2)
 b00506c:	100f883a 	mov	r7,r2
 b005070:	e1bfff17 	ldw	r6,-4(fp)
 b005074:	e17ffe17 	ldw	r5,-8(fp)
 b005078:	1809883a 	mov	r4,r3
 b00507c:	b0055480 	call	b005548 <altera_avalon_uart_read>
      fd->fd_flags);
}
 b005080:	e037883a 	mov	sp,fp
 b005084:	dfc00117 	ldw	ra,4(sp)
 b005088:	df000017 	ldw	fp,0(sp)
 b00508c:	dec00204 	addi	sp,sp,8
 b005090:	f800283a 	ret

0b005094 <altera_avalon_uart_write_fd>:

int 
altera_avalon_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
 b005094:	defffa04 	addi	sp,sp,-24
 b005098:	dfc00515 	stw	ra,20(sp)
 b00509c:	df000415 	stw	fp,16(sp)
 b0050a0:	df000404 	addi	fp,sp,16
 b0050a4:	e13ffd15 	stw	r4,-12(fp)
 b0050a8:	e17ffe15 	stw	r5,-8(fp)
 b0050ac:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
 b0050b0:	e0bffd17 	ldw	r2,-12(fp)
 b0050b4:	10800017 	ldw	r2,0(r2)
 b0050b8:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_write(&dev->state, buffer, space,
 b0050bc:	e0bffc17 	ldw	r2,-16(fp)
 b0050c0:	10c00a04 	addi	r3,r2,40
 b0050c4:	e0bffd17 	ldw	r2,-12(fp)
 b0050c8:	10800217 	ldw	r2,8(r2)
 b0050cc:	100f883a 	mov	r7,r2
 b0050d0:	e1bfff17 	ldw	r6,-4(fp)
 b0050d4:	e17ffe17 	ldw	r5,-8(fp)
 b0050d8:	1809883a 	mov	r4,r3
 b0050dc:	b0057600 	call	b005760 <altera_avalon_uart_write>
      fd->fd_flags);
}
 b0050e0:	e037883a 	mov	sp,fp
 b0050e4:	dfc00117 	ldw	ra,4(sp)
 b0050e8:	df000017 	ldw	fp,0(sp)
 b0050ec:	dec00204 	addi	sp,sp,8
 b0050f0:	f800283a 	ret

0b0050f4 <altera_avalon_uart_close_fd>:

#endif /* ALTERA_AVALON_UART_USE_IOCTL */

int 
altera_avalon_uart_close_fd(alt_fd* fd)
{
 b0050f4:	defffc04 	addi	sp,sp,-16
 b0050f8:	dfc00315 	stw	ra,12(sp)
 b0050fc:	df000215 	stw	fp,8(sp)
 b005100:	df000204 	addi	fp,sp,8
 b005104:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
 b005108:	e0bfff17 	ldw	r2,-4(fp)
 b00510c:	10800017 	ldw	r2,0(r2)
 b005110:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_uart_close(&dev->state, fd->fd_flags);
 b005114:	e0bffe17 	ldw	r2,-8(fp)
 b005118:	10c00a04 	addi	r3,r2,40
 b00511c:	e0bfff17 	ldw	r2,-4(fp)
 b005120:	10800217 	ldw	r2,8(r2)
 b005124:	100b883a 	mov	r5,r2
 b005128:	1809883a 	mov	r4,r3
 b00512c:	b0054b80 	call	b0054b8 <altera_avalon_uart_close>
}
 b005130:	e037883a 	mov	sp,fp
 b005134:	dfc00117 	ldw	ra,4(sp)
 b005138:	df000017 	ldw	fp,0(sp)
 b00513c:	dec00204 	addi	sp,sp,8
 b005140:	f800283a 	ret

0b005144 <altera_avalon_uart_init>:
  alt_u32 status);

void 
altera_avalon_uart_init(altera_avalon_uart_state* sp, 
  alt_u32 irq_controller_id,  alt_u32 irq)
{
 b005144:	defff804 	addi	sp,sp,-32
 b005148:	dfc00715 	stw	ra,28(sp)
 b00514c:	df000615 	stw	fp,24(sp)
 b005150:	df000604 	addi	fp,sp,24
 b005154:	e13ffd15 	stw	r4,-12(fp)
 b005158:	e17ffe15 	stw	r5,-8(fp)
 b00515c:	e1bfff15 	stw	r6,-4(fp)
  void* base = sp->base;
 b005160:	e0bffd17 	ldw	r2,-12(fp)
 b005164:	10800017 	ldw	r2,0(r2)
 b005168:	e0bffb15 	stw	r2,-20(fp)
 * HAL.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_no_error (void)
{
  return 0;
 b00516c:	0005883a 	mov	r2,zero
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
 b005170:	1000041e 	bne	r2,zero,b005184 <altera_avalon_uart_init+0x40>
 b005174:	0005883a 	mov	r2,zero
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
 b005178:	1000021e 	bne	r2,zero,b005184 <altera_avalon_uart_init+0x40>
 b00517c:	0005883a 	mov	r2,zero
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
 b005180:	10000226 	beq	r2,zero,b00518c <altera_avalon_uart_init+0x48>
 b005184:	00800044 	movi	r2,1
 b005188:	00000106 	br	b005190 <altera_avalon_uart_init+0x4c>
 b00518c:	0005883a 	mov	r2,zero
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
 b005190:	e0bffc15 	stw	r2,-16(fp)
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);

  if (!error)
 b005194:	e0bffc17 	ldw	r2,-16(fp)
 b005198:	10000f1e 	bne	r2,zero,b0051d8 <altera_avalon_uart_init+0x94>
  {
    /* enable interrupts at the device */
    sp->ctrl = ALTERA_AVALON_UART_CONTROL_RTS_MSK  |
 b00519c:	e0bffd17 	ldw	r2,-12(fp)
 b0051a0:	00c32004 	movi	r3,3200
 b0051a4:	10c00115 	stw	r3,4(r2)
                ALTERA_AVALON_UART_CONTROL_RRDY_MSK |
                ALTERA_AVALON_UART_CONTROL_DCTS_MSK;

    IOWR_ALTERA_AVALON_UART_CONTROL(base, sp->ctrl); 
 b0051a8:	e0bffb17 	ldw	r2,-20(fp)
 b0051ac:	10800304 	addi	r2,r2,12
 b0051b0:	e0fffd17 	ldw	r3,-12(fp)
 b0051b4:	18c00117 	ldw	r3,4(r3)
 b0051b8:	10c00035 	stwio	r3,0(r2)
  
    /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
    alt_ic_isr_register(irq_controller_id, irq, altera_avalon_uart_irq, sp, 
 b0051bc:	d8000015 	stw	zero,0(sp)
 b0051c0:	e1fffd17 	ldw	r7,-12(fp)
 b0051c4:	0182c034 	movhi	r6,2816
 b0051c8:	31947c04 	addi	r6,r6,20976
 b0051cc:	e17fff17 	ldw	r5,-4(fp)
 b0051d0:	e13ffe17 	ldw	r4,-8(fp)
 b0051d4:	b0064680 	call	b006468 <alt_ic_isr_register>
      0x0);
#else
    alt_irq_register (irq, sp, altera_avalon_uart_irq);
#endif  
  }
}
 b0051d8:	0001883a 	nop
 b0051dc:	e037883a 	mov	sp,fp
 b0051e0:	dfc00117 	ldw	ra,4(sp)
 b0051e4:	df000017 	ldw	fp,0(sp)
 b0051e8:	dec00204 	addi	sp,sp,8
 b0051ec:	f800283a 	ret

0b0051f0 <altera_avalon_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_uart_irq(void* context)
#else
static void altera_avalon_uart_irq(void* context, alt_u32 id)
#endif
{
 b0051f0:	defffa04 	addi	sp,sp,-24
 b0051f4:	dfc00515 	stw	ra,20(sp)
 b0051f8:	df000415 	stw	fp,16(sp)
 b0051fc:	df000404 	addi	fp,sp,16
 b005200:	e13fff15 	stw	r4,-4(fp)
  alt_u32 status;

  altera_avalon_uart_state* sp = (altera_avalon_uart_state*) context;
 b005204:	e0bfff17 	ldw	r2,-4(fp)
 b005208:	e0bffc15 	stw	r2,-16(fp)
  void* base               = sp->base;
 b00520c:	e0bffc17 	ldw	r2,-16(fp)
 b005210:	10800017 	ldw	r2,0(r2)
 b005214:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Read the status register in order to determine the cause of the
   * interrupt.
   */

  status = IORD_ALTERA_AVALON_UART_STATUS(base);
 b005218:	e0bffd17 	ldw	r2,-12(fp)
 b00521c:	10800204 	addi	r2,r2,8
 b005220:	10800037 	ldwio	r2,0(r2)
 b005224:	e0bffe15 	stw	r2,-8(fp)

  /* Clear any error flags set at the device */
  IOWR_ALTERA_AVALON_UART_STATUS(base, 0);
 b005228:	e0bffd17 	ldw	r2,-12(fp)
 b00522c:	10800204 	addi	r2,r2,8
 b005230:	0007883a 	mov	r3,zero
 b005234:	10c00035 	stwio	r3,0(r2)

  /* Dummy read to ensure IRQ is negated before ISR returns */
  IORD_ALTERA_AVALON_UART_STATUS(base);
 b005238:	e0bffd17 	ldw	r2,-12(fp)
 b00523c:	10800204 	addi	r2,r2,8
 b005240:	10800037 	ldwio	r2,0(r2)
  
  /* process a read irq */
  if (status & ALTERA_AVALON_UART_STATUS_RRDY_MSK)
 b005244:	e0bffe17 	ldw	r2,-8(fp)
 b005248:	1080200c 	andi	r2,r2,128
 b00524c:	10000326 	beq	r2,zero,b00525c <altera_avalon_uart_irq+0x6c>
  {
    altera_avalon_uart_rxirq(sp, status);
 b005250:	e17ffe17 	ldw	r5,-8(fp)
 b005254:	e13ffc17 	ldw	r4,-16(fp)
 b005258:	b00528c0 	call	b00528c <altera_avalon_uart_rxirq>
  }

  /* process a write irq */
  if (status & (ALTERA_AVALON_UART_STATUS_TRDY_MSK | 
 b00525c:	e0bffe17 	ldw	r2,-8(fp)
 b005260:	1081100c 	andi	r2,r2,1088
 b005264:	10000326 	beq	r2,zero,b005274 <altera_avalon_uart_irq+0x84>
                  ALTERA_AVALON_UART_STATUS_DCTS_MSK))
  {
    altera_avalon_uart_txirq(sp, status);
 b005268:	e17ffe17 	ldw	r5,-8(fp)
 b00526c:	e13ffc17 	ldw	r4,-16(fp)
 b005270:	b0053700 	call	b005370 <altera_avalon_uart_txirq>
  }
  

}
 b005274:	0001883a 	nop
 b005278:	e037883a 	mov	sp,fp
 b00527c:	dfc00117 	ldw	ra,4(sp)
 b005280:	df000017 	ldw	fp,0(sp)
 b005284:	dec00204 	addi	sp,sp,8
 b005288:	f800283a 	ret

0b00528c <altera_avalon_uart_rxirq>:
 * the receive circular buffer, and sets the apropriate flags to indicate 
 * that there is data ready to be processed.
 */
static void 
altera_avalon_uart_rxirq(altera_avalon_uart_state* sp, alt_u32 status)
{
 b00528c:	defffc04 	addi	sp,sp,-16
 b005290:	df000315 	stw	fp,12(sp)
 b005294:	df000304 	addi	fp,sp,12
 b005298:	e13ffe15 	stw	r4,-8(fp)
 b00529c:	e17fff15 	stw	r5,-4(fp)
  alt_u32 next;
  
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
 b0052a0:	e0bfff17 	ldw	r2,-4(fp)
 b0052a4:	108000cc 	andi	r2,r2,3
 b0052a8:	10002c1e 	bne	r2,zero,b00535c <altera_avalon_uart_rxirq+0xd0>
   * In a multi-threaded environment, set the read event flag to indicate
   * that there is data ready. This is only done if the circular buffer was
   * previously empty.
   */

  if (sp->rx_end == sp->rx_start)
 b0052ac:	e0bffe17 	ldw	r2,-8(fp)
 b0052b0:	10800317 	ldw	r2,12(r2)
 b0052b4:	e0bffe17 	ldw	r2,-8(fp)
 b0052b8:	10800217 	ldw	r2,8(r2)
    ALT_FLAG_POST (sp->events, ALT_UART_READ_RDY, OS_FLAG_SET);
  }

  /* Determine which slot to use next in the circular buffer */

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
 b0052bc:	e0bffe17 	ldw	r2,-8(fp)
 b0052c0:	10800317 	ldw	r2,12(r2)
 b0052c4:	10800044 	addi	r2,r2,1
 b0052c8:	10800fcc 	andi	r2,r2,63
 b0052cc:	e0bffd15 	stw	r2,-12(fp)

  /* Transfer data from the device to the circular buffer */

  sp->rx_buf[sp->rx_end] = IORD_ALTERA_AVALON_UART_RXDATA(sp->base);
 b0052d0:	e0bffe17 	ldw	r2,-8(fp)
 b0052d4:	10800317 	ldw	r2,12(r2)
 b0052d8:	e0fffe17 	ldw	r3,-8(fp)
 b0052dc:	18c00017 	ldw	r3,0(r3)
 b0052e0:	18c00037 	ldwio	r3,0(r3)
 b0052e4:	1809883a 	mov	r4,r3
 b0052e8:	e0fffe17 	ldw	r3,-8(fp)
 b0052ec:	1885883a 	add	r2,r3,r2
 b0052f0:	10800704 	addi	r2,r2,28
 b0052f4:	11000005 	stb	r4,0(r2)

  sp->rx_end = next;
 b0052f8:	e0bffe17 	ldw	r2,-8(fp)
 b0052fc:	e0fffd17 	ldw	r3,-12(fp)
 b005300:	10c00315 	stw	r3,12(r2)

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
 b005304:	e0bffe17 	ldw	r2,-8(fp)
 b005308:	10800317 	ldw	r2,12(r2)
 b00530c:	10800044 	addi	r2,r2,1
 b005310:	10800fcc 	andi	r2,r2,63
 b005314:	e0bffd15 	stw	r2,-12(fp)
  /*
   * If the cicular buffer was full, disable interrupts. Interrupts will be
   * re-enabled when data is removed from the buffer.
   */

  if (next == sp->rx_start)
 b005318:	e0bffe17 	ldw	r2,-8(fp)
 b00531c:	10c00217 	ldw	r3,8(r2)
 b005320:	e0bffd17 	ldw	r2,-12(fp)
 b005324:	18800e1e 	bne	r3,r2,b005360 <altera_avalon_uart_rxirq+0xd4>
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
 b005328:	e0bffe17 	ldw	r2,-8(fp)
 b00532c:	10c00117 	ldw	r3,4(r2)
 b005330:	00bfdfc4 	movi	r2,-129
 b005334:	1886703a 	and	r3,r3,r2
 b005338:	e0bffe17 	ldw	r2,-8(fp)
 b00533c:	10c00115 	stw	r3,4(r2)
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
 b005340:	e0bffe17 	ldw	r2,-8(fp)
 b005344:	10800017 	ldw	r2,0(r2)
 b005348:	10800304 	addi	r2,r2,12
 b00534c:	e0fffe17 	ldw	r3,-8(fp)
 b005350:	18c00117 	ldw	r3,4(r3)
 b005354:	10c00035 	stwio	r3,0(r2)
 b005358:	00000106 	br	b005360 <altera_avalon_uart_rxirq+0xd4>
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
                  ALTERA_AVALON_UART_STATUS_FE_MSK))
  {
    return;
 b00535c:	0001883a 	nop
  if (next == sp->rx_start)
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
  }   
}
 b005360:	e037883a 	mov	sp,fp
 b005364:	df000017 	ldw	fp,0(sp)
 b005368:	dec00104 	addi	sp,sp,4
 b00536c:	f800283a 	ret

0b005370 <altera_avalon_uart_txirq>:
 * buffer to the device, and sets the apropriate flags to indicate that 
 * there is data ready to be processed.
 */
static void 
altera_avalon_uart_txirq(altera_avalon_uart_state* sp, alt_u32 status)
{
 b005370:	defffb04 	addi	sp,sp,-20
 b005374:	df000415 	stw	fp,16(sp)
 b005378:	df000404 	addi	fp,sp,16
 b00537c:	e13ffc15 	stw	r4,-16(fp)
 b005380:	e17ffd15 	stw	r5,-12(fp)
  /* Transfer data if there is some ready to be transfered */

  if (sp->tx_start != sp->tx_end)
 b005384:	e0bffc17 	ldw	r2,-16(fp)
 b005388:	10c00417 	ldw	r3,16(r2)
 b00538c:	e0bffc17 	ldw	r2,-16(fp)
 b005390:	10800517 	ldw	r2,20(r2)
 b005394:	18803226 	beq	r3,r2,b005460 <altera_avalon_uart_txirq+0xf0>
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
 b005398:	e0bffc17 	ldw	r2,-16(fp)
 b00539c:	10800617 	ldw	r2,24(r2)
 b0053a0:	1080008c 	andi	r2,r2,2
 b0053a4:	10000326 	beq	r2,zero,b0053b4 <altera_avalon_uart_txirq+0x44>
      (status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
 b0053a8:	e0bffd17 	ldw	r2,-12(fp)
 b0053ac:	1082000c 	andi	r2,r2,2048
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
 b0053b0:	10001d26 	beq	r2,zero,b005428 <altera_avalon_uart_txirq+0xb8>
       * In a multi-threaded environment, set the write event flag to indicate
       * that there is space in the circular buffer. This is only done if the
       * buffer was previously empty.
       */

      if (sp->tx_start == ((sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK))
 b0053b4:	e0bffc17 	ldw	r2,-16(fp)
 b0053b8:	10800417 	ldw	r2,16(r2)
 b0053bc:	e0bffc17 	ldw	r2,-16(fp)
 b0053c0:	10800517 	ldw	r2,20(r2)
                       OS_FLAG_SET);
      }

      /* Write the data to the device */

      IOWR_ALTERA_AVALON_UART_TXDATA(sp->base, sp->tx_buf[sp->tx_start]);
 b0053c4:	e0bffc17 	ldw	r2,-16(fp)
 b0053c8:	10800017 	ldw	r2,0(r2)
 b0053cc:	10800104 	addi	r2,r2,4
 b0053d0:	e0fffc17 	ldw	r3,-16(fp)
 b0053d4:	18c00417 	ldw	r3,16(r3)
 b0053d8:	e13ffc17 	ldw	r4,-16(fp)
 b0053dc:	20c7883a 	add	r3,r4,r3
 b0053e0:	18c01704 	addi	r3,r3,92
 b0053e4:	18c00003 	ldbu	r3,0(r3)
 b0053e8:	18c03fcc 	andi	r3,r3,255
 b0053ec:	10c00035 	stwio	r3,0(r2)

      sp->tx_start = (++sp->tx_start) & ALT_AVALON_UART_BUF_MSK;
 b0053f0:	e0bffc17 	ldw	r2,-16(fp)
 b0053f4:	10800417 	ldw	r2,16(r2)
 b0053f8:	10800044 	addi	r2,r2,1
 b0053fc:	e0fffc17 	ldw	r3,-16(fp)
 b005400:	18800415 	stw	r2,16(r3)
 b005404:	10c00fcc 	andi	r3,r2,63
 b005408:	e0bffc17 	ldw	r2,-16(fp)
 b00540c:	10c00415 	stw	r3,16(r2)
      /*
       * In case the tranmit interrupt had previously been disabled by 
       * detecting a low value on CTS, it is reenabled here.
       */ 

      sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
 b005410:	e0bffc17 	ldw	r2,-16(fp)
 b005414:	10800117 	ldw	r2,4(r2)
 b005418:	10c01014 	ori	r3,r2,64
 b00541c:	e0bffc17 	ldw	r2,-16(fp)
 b005420:	10c00115 	stw	r3,4(r2)
 b005424:	00000e06 	br	b005460 <altera_avalon_uart_txirq+0xf0>
       * the last write to the status register. To avoid this resulting in
       * deadlock, it's necessary to re-check the status register here
       * before throttling.
       */
 
      status = IORD_ALTERA_AVALON_UART_STATUS(sp->base); 
 b005428:	e0bffc17 	ldw	r2,-16(fp)
 b00542c:	10800017 	ldw	r2,0(r2)
 b005430:	10800204 	addi	r2,r2,8
 b005434:	10800037 	ldwio	r2,0(r2)
 b005438:	e0bffd15 	stw	r2,-12(fp)

      if (!(status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
 b00543c:	e0bffd17 	ldw	r2,-12(fp)
 b005440:	1082000c 	andi	r2,r2,2048
 b005444:	1000061e 	bne	r2,zero,b005460 <altera_avalon_uart_txirq+0xf0>
      {
        sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
 b005448:	e0bffc17 	ldw	r2,-16(fp)
 b00544c:	10c00117 	ldw	r3,4(r2)
 b005450:	00bfefc4 	movi	r2,-65
 b005454:	1886703a 	and	r3,r3,r2
 b005458:	e0bffc17 	ldw	r2,-16(fp)
 b00545c:	10c00115 	stw	r3,4(r2)
  /*
   * If the circular buffer is empty, disable the interrupt. This will be
   * re-enabled when new data is placed in the buffer.
   */

  if (sp->tx_start == sp->tx_end)
 b005460:	e0bffc17 	ldw	r2,-16(fp)
 b005464:	10c00417 	ldw	r3,16(r2)
 b005468:	e0bffc17 	ldw	r2,-16(fp)
 b00546c:	10800517 	ldw	r2,20(r2)
 b005470:	1880061e 	bne	r3,r2,b00548c <altera_avalon_uart_txirq+0x11c>
  {
    sp->ctrl &= ~(ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
 b005474:	e0bffc17 	ldw	r2,-16(fp)
 b005478:	10c00117 	ldw	r3,4(r2)
 b00547c:	00beefc4 	movi	r2,-1089
 b005480:	1886703a 	and	r3,r3,r2
 b005484:	e0bffc17 	ldw	r2,-16(fp)
 b005488:	10c00115 	stw	r3,4(r2)
                    ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
  }

  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
 b00548c:	e0bffc17 	ldw	r2,-16(fp)
 b005490:	10800017 	ldw	r2,0(r2)
 b005494:	10800304 	addi	r2,r2,12
 b005498:	e0fffc17 	ldw	r3,-16(fp)
 b00549c:	18c00117 	ldw	r3,4(r3)
 b0054a0:	10c00035 	stwio	r3,0(r2)
}
 b0054a4:	0001883a 	nop
 b0054a8:	e037883a 	mov	sp,fp
 b0054ac:	df000017 	ldw	fp,0(sp)
 b0054b0:	dec00104 	addi	sp,sp,4
 b0054b4:	f800283a 	ret

0b0054b8 <altera_avalon_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
 b0054b8:	defffd04 	addi	sp,sp,-12
 b0054bc:	df000215 	stw	fp,8(sp)
 b0054c0:	df000204 	addi	fp,sp,8
 b0054c4:	e13ffe15 	stw	r4,-8(fp)
 b0054c8:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
 b0054cc:	00000506 	br	b0054e4 <altera_avalon_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
 b0054d0:	e0bfff17 	ldw	r2,-4(fp)
 b0054d4:	1090000c 	andi	r2,r2,16384
 b0054d8:	10000226 	beq	r2,zero,b0054e4 <altera_avalon_uart_close+0x2c>
      return -EWOULDBLOCK; 
 b0054dc:	00bffd44 	movi	r2,-11
 b0054e0:	00000606 	br	b0054fc <altera_avalon_uart_close+0x44>
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
 b0054e4:	e0bffe17 	ldw	r2,-8(fp)
 b0054e8:	10c00417 	ldw	r3,16(r2)
 b0054ec:	e0bffe17 	ldw	r2,-8(fp)
 b0054f0:	10800517 	ldw	r2,20(r2)
 b0054f4:	18bff61e 	bne	r3,r2,b0054d0 <__alt_mem_flash+0xff0044d0>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
 b0054f8:	0005883a 	mov	r2,zero
}
 b0054fc:	e037883a 	mov	sp,fp
 b005500:	df000017 	ldw	fp,0(sp)
 b005504:	dec00104 	addi	sp,sp,4
 b005508:	f800283a 	ret

0b00550c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 b00550c:	defffe04 	addi	sp,sp,-8
 b005510:	dfc00115 	stw	ra,4(sp)
 b005514:	df000015 	stw	fp,0(sp)
 b005518:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 b00551c:	d0a00917 	ldw	r2,-32732(gp)
 b005520:	10000326 	beq	r2,zero,b005530 <alt_get_errno+0x24>
 b005524:	d0a00917 	ldw	r2,-32732(gp)
 b005528:	103ee83a 	callr	r2
 b00552c:	00000106 	br	b005534 <alt_get_errno+0x28>
 b005530:	d0a71f04 	addi	r2,gp,-25476
}
 b005534:	e037883a 	mov	sp,fp
 b005538:	dfc00117 	ldw	ra,4(sp)
 b00553c:	df000017 	ldw	fp,0(sp)
 b005540:	dec00204 	addi	sp,sp,8
 b005544:	f800283a 	ret

0b005548 <altera_avalon_uart_read>:
 */

int 
altera_avalon_uart_read(altera_avalon_uart_state* sp, char* ptr, int len,
  int flags)
{
 b005548:	defff204 	addi	sp,sp,-56
 b00554c:	dfc00d15 	stw	ra,52(sp)
 b005550:	df000c15 	stw	fp,48(sp)
 b005554:	df000c04 	addi	fp,sp,48
 b005558:	e13ffc15 	stw	r4,-16(fp)
 b00555c:	e17ffd15 	stw	r5,-12(fp)
 b005560:	e1bffe15 	stw	r6,-8(fp)
 b005564:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             block;
  alt_u8          read_would_block = 0;
 b005568:	e03ff405 	stb	zero,-48(fp)
  int             count = 0;
 b00556c:	e03ff515 	stw	zero,-44(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  block = !(flags & O_NONBLOCK);
 b005570:	e0bfff17 	ldw	r2,-4(fp)
 b005574:	1090000c 	andi	r2,r2,16384
 b005578:	1005003a 	cmpeq	r2,r2,zero
 b00557c:	10803fcc 	andi	r2,r2,255
 b005580:	e0bff615 	stw	r2,-40(fp)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
 b005584:	00001306 	br	b0055d4 <altera_avalon_uart_read+0x8c>
    {
      count++;
 b005588:	e0bff517 	ldw	r2,-44(fp)
 b00558c:	10800044 	addi	r2,r2,1
 b005590:	e0bff515 	stw	r2,-44(fp)
      *ptr++ = sp->rx_buf[sp->rx_start];
 b005594:	e0bffd17 	ldw	r2,-12(fp)
 b005598:	10c00044 	addi	r3,r2,1
 b00559c:	e0fffd15 	stw	r3,-12(fp)
 b0055a0:	e0fffc17 	ldw	r3,-16(fp)
 b0055a4:	18c00217 	ldw	r3,8(r3)
 b0055a8:	e13ffc17 	ldw	r4,-16(fp)
 b0055ac:	20c7883a 	add	r3,r4,r3
 b0055b0:	18c00704 	addi	r3,r3,28
 b0055b4:	18c00003 	ldbu	r3,0(r3)
 b0055b8:	10c00005 	stb	r3,0(r2)
      
      sp->rx_start = (sp->rx_start+1) & ALT_AVALON_UART_BUF_MSK;
 b0055bc:	e0bffc17 	ldw	r2,-16(fp)
 b0055c0:	10800217 	ldw	r2,8(r2)
 b0055c4:	10800044 	addi	r2,r2,1
 b0055c8:	10c00fcc 	andi	r3,r2,63
 b0055cc:	e0bffc17 	ldw	r2,-16(fp)
 b0055d0:	10c00215 	stw	r3,8(r2)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
 b0055d4:	e0fff517 	ldw	r3,-44(fp)
 b0055d8:	e0bffe17 	ldw	r2,-8(fp)
 b0055dc:	1880050e 	bge	r3,r2,b0055f4 <altera_avalon_uart_read+0xac>
 b0055e0:	e0bffc17 	ldw	r2,-16(fp)
 b0055e4:	10c00217 	ldw	r3,8(r2)
 b0055e8:	e0bffc17 	ldw	r2,-16(fp)
 b0055ec:	10800317 	ldw	r2,12(r2)
 b0055f0:	18bfe51e 	bne	r3,r2,b005588 <__alt_mem_flash+0xff004588>
    /*
     * If no data has been transferred, the circular buffer is empty, and
     * this is not a non-blocking access, block waiting for data to arrive.
     */

    if (!count && (sp->rx_start == sp->rx_end))
 b0055f4:	e0bff517 	ldw	r2,-44(fp)
 b0055f8:	1000251e 	bne	r2,zero,b005690 <altera_avalon_uart_read+0x148>
 b0055fc:	e0bffc17 	ldw	r2,-16(fp)
 b005600:	10c00217 	ldw	r3,8(r2)
 b005604:	e0bffc17 	ldw	r2,-16(fp)
 b005608:	10800317 	ldw	r2,12(r2)
 b00560c:	1880201e 	bne	r3,r2,b005690 <altera_avalon_uart_read+0x148>
    {
      if (!block)
 b005610:	e0bff617 	ldw	r2,-40(fp)
 b005614:	1000071e 	bne	r2,zero,b005634 <altera_avalon_uart_read+0xec>
      {
        /* Set errno to indicate the reason we're not returning any data */

        ALT_ERRNO = EWOULDBLOCK;
 b005618:	b00550c0 	call	b00550c <alt_get_errno>
 b00561c:	1007883a 	mov	r3,r2
 b005620:	008002c4 	movi	r2,11
 b005624:	18800015 	stw	r2,0(r3)
        read_would_block = 1;
 b005628:	00800044 	movi	r2,1
 b00562c:	e0bff405 	stb	r2,-48(fp)
        break;
 b005630:	00001b06 	br	b0056a0 <altera_avalon_uart_read+0x158>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 b005634:	0005303a 	rdctl	r2,status
 b005638:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 b00563c:	e0fff917 	ldw	r3,-28(fp)
 b005640:	00bfff84 	movi	r2,-2
 b005644:	1884703a 	and	r2,r3,r2
 b005648:	1001703a 	wrctl	status,r2
  
  return context;
 b00564c:	e0bff917 	ldw	r2,-28(fp)
      {
       /* Block waiting for some data to arrive */

       /* First, ensure read interrupts are enabled to avoid deadlock */

       context = alt_irq_disable_all ();
 b005650:	e0bff815 	stw	r2,-32(fp)
       sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
 b005654:	e0bffc17 	ldw	r2,-16(fp)
 b005658:	10800117 	ldw	r2,4(r2)
 b00565c:	10c02014 	ori	r3,r2,128
 b005660:	e0bffc17 	ldw	r2,-16(fp)
 b005664:	10c00115 	stw	r3,4(r2)
       IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
 b005668:	e0bffc17 	ldw	r2,-16(fp)
 b00566c:	10800017 	ldw	r2,0(r2)
 b005670:	10800304 	addi	r2,r2,12
 b005674:	e0fffc17 	ldw	r3,-16(fp)
 b005678:	18c00117 	ldw	r3,4(r3)
 b00567c:	10c00035 	stwio	r3,0(r2)
 b005680:	e0bff817 	ldw	r2,-32(fp)
 b005684:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 b005688:	e0bffa17 	ldw	r2,-24(fp)
 b00568c:	1001703a 	wrctl	status,r2
                      OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                      0);
      }
    }
  }
  while (!count && len);
 b005690:	e0bff517 	ldw	r2,-44(fp)
 b005694:	1000021e 	bne	r2,zero,b0056a0 <altera_avalon_uart_read+0x158>
 b005698:	e0bffe17 	ldw	r2,-8(fp)
 b00569c:	103fcd1e 	bne	r2,zero,b0055d4 <__alt_mem_flash+0xff0045d4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 b0056a0:	0005303a 	rdctl	r2,status
 b0056a4:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 b0056a8:	e0fffb17 	ldw	r3,-20(fp)
 b0056ac:	00bfff84 	movi	r2,-2
 b0056b0:	1884703a 	and	r2,r3,r2
 b0056b4:	1001703a 	wrctl	status,r2
  
  return context;
 b0056b8:	e0bffb17 	ldw	r2,-20(fp)
  /*
   * Ensure that interrupts are enabled, so that the circular buffer can
   * re-fill.
   */

  context = alt_irq_disable_all ();
 b0056bc:	e0bff815 	stw	r2,-32(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
 b0056c0:	e0bffc17 	ldw	r2,-16(fp)
 b0056c4:	10800117 	ldw	r2,4(r2)
 b0056c8:	10c02014 	ori	r3,r2,128
 b0056cc:	e0bffc17 	ldw	r2,-16(fp)
 b0056d0:	10c00115 	stw	r3,4(r2)
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
 b0056d4:	e0bffc17 	ldw	r2,-16(fp)
 b0056d8:	10800017 	ldw	r2,0(r2)
 b0056dc:	10800304 	addi	r2,r2,12
 b0056e0:	e0fffc17 	ldw	r3,-16(fp)
 b0056e4:	18c00117 	ldw	r3,4(r3)
 b0056e8:	10c00035 	stwio	r3,0(r2)
 b0056ec:	e0bff817 	ldw	r2,-32(fp)
 b0056f0:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 b0056f4:	e0bff717 	ldw	r2,-36(fp)
 b0056f8:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* Return the number of bytes read */
  if(read_would_block) {
 b0056fc:	e0bff403 	ldbu	r2,-48(fp)
 b005700:	10000226 	beq	r2,zero,b00570c <altera_avalon_uart_read+0x1c4>
    return -EWOULDBLOCK;
 b005704:	00bffd44 	movi	r2,-11
 b005708:	00000106 	br	b005710 <altera_avalon_uart_read+0x1c8>
  }
  else {
    return count;
 b00570c:	e0bff517 	ldw	r2,-44(fp)
  }
}
 b005710:	e037883a 	mov	sp,fp
 b005714:	dfc00117 	ldw	ra,4(sp)
 b005718:	df000017 	ldw	fp,0(sp)
 b00571c:	dec00204 	addi	sp,sp,8
 b005720:	f800283a 	ret

0b005724 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 b005724:	defffe04 	addi	sp,sp,-8
 b005728:	dfc00115 	stw	ra,4(sp)
 b00572c:	df000015 	stw	fp,0(sp)
 b005730:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 b005734:	d0a00917 	ldw	r2,-32732(gp)
 b005738:	10000326 	beq	r2,zero,b005748 <alt_get_errno+0x24>
 b00573c:	d0a00917 	ldw	r2,-32732(gp)
 b005740:	103ee83a 	callr	r2
 b005744:	00000106 	br	b00574c <alt_get_errno+0x28>
 b005748:	d0a71f04 	addi	r2,gp,-25476
}
 b00574c:	e037883a 	mov	sp,fp
 b005750:	dfc00117 	ldw	ra,4(sp)
 b005754:	df000017 	ldw	fp,0(sp)
 b005758:	dec00204 	addi	sp,sp,8
 b00575c:	f800283a 	ret

0b005760 <altera_avalon_uart_write>:
 */

int
altera_avalon_uart_write(altera_avalon_uart_state* sp, const char* ptr, int len,
  int flags)
{
 b005760:	defff204 	addi	sp,sp,-56
 b005764:	dfc00d15 	stw	ra,52(sp)
 b005768:	df000c15 	stw	fp,48(sp)
 b00576c:	df000c04 	addi	fp,sp,48
 b005770:	e13ffc15 	stw	r4,-16(fp)
 b005774:	e17ffd15 	stw	r5,-12(fp)
 b005778:	e1bffe15 	stw	r6,-8(fp)
 b00577c:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             no_block;
  alt_u32         next;
  int             count = len;
 b005780:	e0bffe17 	ldw	r2,-8(fp)
 b005784:	e0bff415 	stw	r2,-48(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  no_block = (flags & O_NONBLOCK);
 b005788:	e0bfff17 	ldw	r2,-4(fp)
 b00578c:	1090000c 	andi	r2,r2,16384
 b005790:	e0bff515 	stw	r2,-44(fp)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
 b005794:	00003c06 	br	b005888 <altera_avalon_uart_write+0x128>
  {
    /* Determine the next slot in the buffer to access */

    next = (sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK;
 b005798:	e0bffc17 	ldw	r2,-16(fp)
 b00579c:	10800517 	ldw	r2,20(r2)
 b0057a0:	10800044 	addi	r2,r2,1
 b0057a4:	10800fcc 	andi	r2,r2,63
 b0057a8:	e0bff715 	stw	r2,-36(fp)

    /* block waiting for space if necessary */

    if (next == sp->tx_start)
 b0057ac:	e0bffc17 	ldw	r2,-16(fp)
 b0057b0:	10c00417 	ldw	r3,16(r2)
 b0057b4:	e0bff717 	ldw	r2,-36(fp)
 b0057b8:	1880221e 	bne	r3,r2,b005844 <altera_avalon_uart_write+0xe4>
    {
      if (no_block)
 b0057bc:	e0bff517 	ldw	r2,-44(fp)
 b0057c0:	10000526 	beq	r2,zero,b0057d8 <altera_avalon_uart_write+0x78>
      {
        /* Set errno to indicate why this function returned early */
 
        ALT_ERRNO = EWOULDBLOCK;
 b0057c4:	b0057240 	call	b005724 <alt_get_errno>
 b0057c8:	1007883a 	mov	r3,r2
 b0057cc:	008002c4 	movi	r2,11
 b0057d0:	18800015 	stw	r2,0(r3)
        break;
 b0057d4:	00002e06 	br	b005890 <altera_avalon_uart_write+0x130>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 b0057d8:	0005303a 	rdctl	r2,status
 b0057dc:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 b0057e0:	e0fff917 	ldw	r3,-28(fp)
 b0057e4:	00bfff84 	movi	r2,-2
 b0057e8:	1884703a 	and	r2,r3,r2
 b0057ec:	1001703a 	wrctl	status,r2
  
  return context;
 b0057f0:	e0bff917 	ldw	r2,-28(fp)
      {
        /* Block waiting for space in the circular buffer */

        /* First, ensure transmit interrupts are enabled to avoid deadlock */

        context = alt_irq_disable_all ();
 b0057f4:	e0bff815 	stw	r2,-32(fp)
        sp->ctrl |= (ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
 b0057f8:	e0bffc17 	ldw	r2,-16(fp)
 b0057fc:	10800117 	ldw	r2,4(r2)
 b005800:	10c11014 	ori	r3,r2,1088
 b005804:	e0bffc17 	ldw	r2,-16(fp)
 b005808:	10c00115 	stw	r3,4(r2)
                        ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
        IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
 b00580c:	e0bffc17 	ldw	r2,-16(fp)
 b005810:	10800017 	ldw	r2,0(r2)
 b005814:	10800304 	addi	r2,r2,12
 b005818:	e0fffc17 	ldw	r3,-16(fp)
 b00581c:	18c00117 	ldw	r3,4(r3)
 b005820:	10c00035 	stwio	r3,0(r2)
 b005824:	e0bff817 	ldw	r2,-32(fp)
 b005828:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 b00582c:	e0bff617 	ldw	r2,-40(fp)
 b005830:	1001703a 	wrctl	status,r2
          ALT_FLAG_PEND (sp->events, 
                         ALT_UART_WRITE_RDY,
                         OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                         0);
        }
        while ((next == sp->tx_start));
 b005834:	e0bffc17 	ldw	r2,-16(fp)
 b005838:	10c00417 	ldw	r3,16(r2)
 b00583c:	e0bff717 	ldw	r2,-36(fp)
 b005840:	18bffc26 	beq	r3,r2,b005834 <__alt_mem_flash+0xff004834>
      }
    }

    count--;
 b005844:	e0bff417 	ldw	r2,-48(fp)
 b005848:	10bfffc4 	addi	r2,r2,-1
 b00584c:	e0bff415 	stw	r2,-48(fp)

    /* Add the next character to the transmit buffer */

    sp->tx_buf[sp->tx_end] = *ptr++;
 b005850:	e0bffc17 	ldw	r2,-16(fp)
 b005854:	10c00517 	ldw	r3,20(r2)
 b005858:	e0bffd17 	ldw	r2,-12(fp)
 b00585c:	11000044 	addi	r4,r2,1
 b005860:	e13ffd15 	stw	r4,-12(fp)
 b005864:	10800003 	ldbu	r2,0(r2)
 b005868:	1009883a 	mov	r4,r2
 b00586c:	e0bffc17 	ldw	r2,-16(fp)
 b005870:	10c5883a 	add	r2,r2,r3
 b005874:	10801704 	addi	r2,r2,92
 b005878:	11000005 	stb	r4,0(r2)
    sp->tx_end = next;
 b00587c:	e0bffc17 	ldw	r2,-16(fp)
 b005880:	e0fff717 	ldw	r3,-36(fp)
 b005884:	10c00515 	stw	r3,20(r2)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
 b005888:	e0bff417 	ldw	r2,-48(fp)
 b00588c:	103fc21e 	bne	r2,zero,b005798 <__alt_mem_flash+0xff004798>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 b005890:	0005303a 	rdctl	r2,status
 b005894:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 b005898:	e0fffb17 	ldw	r3,-20(fp)
 b00589c:	00bfff84 	movi	r2,-2
 b0058a0:	1884703a 	and	r2,r3,r2
 b0058a4:	1001703a 	wrctl	status,r2
  
  return context;
 b0058a8:	e0bffb17 	ldw	r2,-20(fp)
  /* 
   * Ensure that interrupts are enabled, so that the circular buffer can 
   * drain.
   */

  context = alt_irq_disable_all ();
 b0058ac:	e0bff815 	stw	r2,-32(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
 b0058b0:	e0bffc17 	ldw	r2,-16(fp)
 b0058b4:	10800117 	ldw	r2,4(r2)
 b0058b8:	10c11014 	ori	r3,r2,1088
 b0058bc:	e0bffc17 	ldw	r2,-16(fp)
 b0058c0:	10c00115 	stw	r3,4(r2)
                 ALTERA_AVALON_UART_CONTROL_DCTS_MSK;
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
 b0058c4:	e0bffc17 	ldw	r2,-16(fp)
 b0058c8:	10800017 	ldw	r2,0(r2)
 b0058cc:	10800304 	addi	r2,r2,12
 b0058d0:	e0fffc17 	ldw	r3,-16(fp)
 b0058d4:	18c00117 	ldw	r3,4(r3)
 b0058d8:	10c00035 	stwio	r3,0(r2)
 b0058dc:	e0bff817 	ldw	r2,-32(fp)
 b0058e0:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 b0058e4:	e0bffa17 	ldw	r2,-24(fp)
 b0058e8:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* return the number of bytes written */

  return (len - count);
 b0058ec:	e0fffe17 	ldw	r3,-8(fp)
 b0058f0:	e0bff417 	ldw	r2,-48(fp)
 b0058f4:	1885c83a 	sub	r2,r3,r2
}
 b0058f8:	e037883a 	mov	sp,fp
 b0058fc:	dfc00117 	ldw	ra,4(sp)
 b005900:	df000017 	ldw	fp,0(sp)
 b005904:	dec00204 	addi	sp,sp,8
 b005908:	f800283a 	ret

0b00590c <epcs_read_status_register>:
#include "alt_types.h"
#include "epcs_commands.h"
#include "altera_avalon_spi.h"

alt_u8 epcs_read_status_register(alt_u32 base)
{
 b00590c:	defff904 	addi	sp,sp,-28
 b005910:	dfc00615 	stw	ra,24(sp)
 b005914:	df000515 	stw	fp,20(sp)
 b005918:	df000504 	addi	fp,sp,20
 b00591c:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 rdsr = epcs_rdsr;
 b005920:	00800144 	movi	r2,5
 b005924:	e0bffe05 	stb	r2,-8(fp)
  alt_u8 status;
  alt_avalon_spi_command(
 b005928:	d8000215 	stw	zero,8(sp)
 b00592c:	e0bffe44 	addi	r2,fp,-7
 b005930:	d8800115 	stw	r2,4(sp)
 b005934:	00800044 	movi	r2,1
 b005938:	d8800015 	stw	r2,0(sp)
 b00593c:	e1fffe04 	addi	r7,fp,-8
 b005940:	01800044 	movi	r6,1
 b005944:	000b883a 	mov	r5,zero
 b005948:	e13fff17 	ldw	r4,-4(fp)
 b00594c:	b006cb40 	call	b006cb4 <alt_avalon_spi_command>
    1,
    &status,
    0
  );

  return status;
 b005950:	e0bffe43 	ldbu	r2,-7(fp)
}
 b005954:	e037883a 	mov	sp,fp
 b005958:	dfc00117 	ldw	ra,4(sp)
 b00595c:	df000017 	ldw	fp,0(sp)
 b005960:	dec00204 	addi	sp,sp,8
 b005964:	f800283a 	ret

0b005968 <epcs_test_wip>:

static ALT_INLINE int epcs_test_wip(alt_u32 base)
{
 b005968:	defffd04 	addi	sp,sp,-12
 b00596c:	dfc00215 	stw	ra,8(sp)
 b005970:	df000115 	stw	fp,4(sp)
 b005974:	df000104 	addi	fp,sp,4
 b005978:	e13fff15 	stw	r4,-4(fp)
  return epcs_read_status_register(base) & 1;
 b00597c:	e13fff17 	ldw	r4,-4(fp)
 b005980:	b00590c0 	call	b00590c <epcs_read_status_register>
 b005984:	10803fcc 	andi	r2,r2,255
 b005988:	1080004c 	andi	r2,r2,1
}
 b00598c:	e037883a 	mov	sp,fp
 b005990:	dfc00117 	ldw	ra,4(sp)
 b005994:	df000017 	ldw	fp,0(sp)
 b005998:	dec00204 	addi	sp,sp,8
 b00599c:	f800283a 	ret

0b0059a0 <epcs_await_wip_released>:

static ALT_INLINE void epcs_await_wip_released(alt_u32 base)
{
 b0059a0:	defffd04 	addi	sp,sp,-12
 b0059a4:	dfc00215 	stw	ra,8(sp)
 b0059a8:	df000115 	stw	fp,4(sp)
 b0059ac:	df000104 	addi	fp,sp,4
 b0059b0:	e13fff15 	stw	r4,-4(fp)
  /* Wait until the WIP bit goes low. */
  while (epcs_test_wip(base))
 b0059b4:	0001883a 	nop
 b0059b8:	e13fff17 	ldw	r4,-4(fp)
 b0059bc:	b0059680 	call	b005968 <epcs_test_wip>
 b0059c0:	103ffd1e 	bne	r2,zero,b0059b8 <__alt_mem_flash+0xff0049b8>
  {
  }
}
 b0059c4:	0001883a 	nop
 b0059c8:	e037883a 	mov	sp,fp
 b0059cc:	dfc00117 	ldw	ra,4(sp)
 b0059d0:	df000017 	ldw	fp,0(sp)
 b0059d4:	dec00204 	addi	sp,sp,8
 b0059d8:	f800283a 	ret

0b0059dc <epcs_sector_erase>:

void epcs_sector_erase(alt_u32 base, alt_u32 offset, alt_u32 four_bytes_mode)
{
 b0059dc:	defff604 	addi	sp,sp,-40
 b0059e0:	dfc00915 	stw	ra,36(sp)
 b0059e4:	df000815 	stw	fp,32(sp)
 b0059e8:	df000804 	addi	fp,sp,32
 b0059ec:	e13ffd15 	stw	r4,-12(fp)
 b0059f0:	e17ffe15 	stw	r5,-8(fp)
 b0059f4:	e1bfff15 	stw	r6,-4(fp)
  alt_u8 se[5];
  alt_u8 len;
  
  if(four_bytes_mode)
 b0059f8:	e0bfff17 	ldw	r2,-4(fp)
 b0059fc:	10001226 	beq	r2,zero,b005a48 <epcs_sector_erase+0x6c>
  {
      se[0] = epcs_se;  /* Note: Use epcs_se for Micron EPCS256 */
 b005a00:	00bff604 	movi	r2,-40
 b005a04:	e0bffb45 	stb	r2,-19(fp)
      se[1] = (offset >> 24) & 0xFF;
 b005a08:	e0bffe17 	ldw	r2,-8(fp)
 b005a0c:	1004d63a 	srli	r2,r2,24
 b005a10:	e0bffb85 	stb	r2,-18(fp)
      se[2] = (offset >> 16) & 0xFF;
 b005a14:	e0bffe17 	ldw	r2,-8(fp)
 b005a18:	1004d43a 	srli	r2,r2,16
 b005a1c:	e0bffbc5 	stb	r2,-17(fp)
      se[3] = (offset >> 8) & 0xFF;
 b005a20:	e0bffe17 	ldw	r2,-8(fp)
 b005a24:	1004d23a 	srli	r2,r2,8
 b005a28:	e0bffc05 	stb	r2,-16(fp)
      se[4] = offset & 0xFF;
 b005a2c:	e0bffe17 	ldw	r2,-8(fp)
 b005a30:	e0bffc45 	stb	r2,-15(fp)
      len   = 5;
 b005a34:	00800144 	movi	r2,5
 b005a38:	e0bffb05 	stb	r2,-20(fp)
      epcs_enter_4_bytes_mode(base);
 b005a3c:	e13ffd17 	ldw	r4,-12(fp)
 b005a40:	b005e900 	call	b005e90 <epcs_enter_4_bytes_mode>
 b005a44:	00000c06 	br	b005a78 <epcs_sector_erase+0x9c>
  }
  else
  {
      se[0] = epcs_se;
 b005a48:	00bff604 	movi	r2,-40
 b005a4c:	e0bffb45 	stb	r2,-19(fp)
      se[1] = (offset >> 16) & 0xFF;
 b005a50:	e0bffe17 	ldw	r2,-8(fp)
 b005a54:	1004d43a 	srli	r2,r2,16
 b005a58:	e0bffb85 	stb	r2,-18(fp)
      se[2] = (offset >> 8) & 0xFF;
 b005a5c:	e0bffe17 	ldw	r2,-8(fp)
 b005a60:	1004d23a 	srli	r2,r2,8
 b005a64:	e0bffbc5 	stb	r2,-17(fp)
      se[3] = offset & 0xFF;
 b005a68:	e0bffe17 	ldw	r2,-8(fp)
 b005a6c:	e0bffc05 	stb	r2,-16(fp)
      len   = 4;
 b005a70:	00800104 	movi	r2,4
 b005a74:	e0bffb05 	stb	r2,-20(fp)
  }

  /* Execute a WREN instruction */
  epcs_write_enable(base);
 b005a78:	e13ffd17 	ldw	r4,-12(fp)
 b005a7c:	b005bcc0 	call	b005bcc <epcs_write_enable>

  alt_avalon_spi_command(
 b005a80:	e0bffb03 	ldbu	r2,-20(fp)
 b005a84:	e0fffb44 	addi	r3,fp,-19
 b005a88:	d8000215 	stw	zero,8(sp)
 b005a8c:	d8000115 	stw	zero,4(sp)
 b005a90:	d8000015 	stw	zero,0(sp)
 b005a94:	180f883a 	mov	r7,r3
 b005a98:	100d883a 	mov	r6,r2
 b005a9c:	000b883a 	mov	r5,zero
 b005aa0:	e13ffd17 	ldw	r4,-12(fp)
 b005aa4:	b006cb40 	call	b006cb4 <alt_avalon_spi_command>
    0,
    (alt_u8*)0,
    0
  );

  epcs_await_wip_released(base);
 b005aa8:	e13ffd17 	ldw	r4,-12(fp)
 b005aac:	b0059a00 	call	b0059a0 <epcs_await_wip_released>

  if(four_bytes_mode)
 b005ab0:	e0bfff17 	ldw	r2,-4(fp)
 b005ab4:	10000226 	beq	r2,zero,b005ac0 <epcs_sector_erase+0xe4>
  {
    epcs_exit_4_bytes_mode(base);
 b005ab8:	e13ffd17 	ldw	r4,-12(fp)
 b005abc:	b005eec0 	call	b005eec <epcs_exit_4_bytes_mode>
  }
}
 b005ac0:	0001883a 	nop
 b005ac4:	e037883a 	mov	sp,fp
 b005ac8:	dfc00117 	ldw	ra,4(sp)
 b005acc:	df000017 	ldw	fp,0(sp)
 b005ad0:	dec00204 	addi	sp,sp,8
 b005ad4:	f800283a 	ret

0b005ad8 <epcs_read_buffer>:

alt_32 epcs_read_buffer(alt_u32 base, int offset, alt_u8 *dest_addr, int length,
                        alt_u32 four_bytes_mode)
{
 b005ad8:	defff404 	addi	sp,sp,-48
 b005adc:	dfc00b15 	stw	ra,44(sp)
 b005ae0:	df000a15 	stw	fp,40(sp)
 b005ae4:	df000a04 	addi	fp,sp,40
 b005ae8:	e13ffc15 	stw	r4,-16(fp)
 b005aec:	e17ffd15 	stw	r5,-12(fp)
 b005af0:	e1bffe15 	stw	r6,-8(fp)
 b005af4:	e1ffff15 	stw	r7,-4(fp)
  alt_u8 read_command[5];
  alt_u32 cmd_len;

  read_command[0] = epcs_read;
 b005af8:	008000c4 	movi	r2,3
 b005afc:	e0bffa05 	stb	r2,-24(fp)
  
  if(four_bytes_mode)
 b005b00:	e0800217 	ldw	r2,8(fp)
 b005b04:	10001026 	beq	r2,zero,b005b48 <epcs_read_buffer+0x70>
  {
        read_command[1] = (offset >> 24) & 0xFF;
 b005b08:	e0bffd17 	ldw	r2,-12(fp)
 b005b0c:	1004d63a 	srli	r2,r2,24
 b005b10:	e0bffa45 	stb	r2,-23(fp)
        read_command[2] = (offset >> 16) & 0xFF;
 b005b14:	e0bffd17 	ldw	r2,-12(fp)
 b005b18:	1005d43a 	srai	r2,r2,16
 b005b1c:	e0bffa85 	stb	r2,-22(fp)
        read_command[3] = (offset >> 8) & 0xFF;
 b005b20:	e0bffd17 	ldw	r2,-12(fp)
 b005b24:	1005d23a 	srai	r2,r2,8
 b005b28:	e0bffac5 	stb	r2,-21(fp)
        read_command[4] = offset & 0xFF;
 b005b2c:	e0bffd17 	ldw	r2,-12(fp)
 b005b30:	e0bffb05 	stb	r2,-20(fp)
        cmd_len = 5;
 b005b34:	00800144 	movi	r2,5
 b005b38:	e0bff915 	stw	r2,-28(fp)
        epcs_enter_4_bytes_mode(base);
 b005b3c:	e13ffc17 	ldw	r4,-16(fp)
 b005b40:	b005e900 	call	b005e90 <epcs_enter_4_bytes_mode>
 b005b44:	00000a06 	br	b005b70 <epcs_read_buffer+0x98>
  }
  else
  {
        read_command[1] = (offset >> 16) & 0xFF;
 b005b48:	e0bffd17 	ldw	r2,-12(fp)
 b005b4c:	1005d43a 	srai	r2,r2,16
 b005b50:	e0bffa45 	stb	r2,-23(fp)
        read_command[2] = (offset >> 8) & 0xFF;
 b005b54:	e0bffd17 	ldw	r2,-12(fp)
 b005b58:	1005d23a 	srai	r2,r2,8
 b005b5c:	e0bffa85 	stb	r2,-22(fp)
        read_command[3] = offset & 0xFF;
 b005b60:	e0bffd17 	ldw	r2,-12(fp)
 b005b64:	e0bffac5 	stb	r2,-21(fp)
        cmd_len = 4;
 b005b68:	00800104 	movi	r2,4
 b005b6c:	e0bff915 	stw	r2,-28(fp)
  }

  epcs_await_wip_released(base);
 b005b70:	e13ffc17 	ldw	r4,-16(fp)
 b005b74:	b0059a00 	call	b0059a0 <epcs_await_wip_released>

  alt_avalon_spi_command(
 b005b78:	e0bfff17 	ldw	r2,-4(fp)
 b005b7c:	e13ffa04 	addi	r4,fp,-24
 b005b80:	d8000215 	stw	zero,8(sp)
 b005b84:	e0fffe17 	ldw	r3,-8(fp)
 b005b88:	d8c00115 	stw	r3,4(sp)
 b005b8c:	d8800015 	stw	r2,0(sp)
 b005b90:	200f883a 	mov	r7,r4
 b005b94:	e1bff917 	ldw	r6,-28(fp)
 b005b98:	000b883a 	mov	r5,zero
 b005b9c:	e13ffc17 	ldw	r4,-16(fp)
 b005ba0:	b006cb40 	call	b006cb4 <alt_avalon_spi_command>
    length,
    (alt_u8*)dest_addr,
    0
  );

  if(four_bytes_mode)
 b005ba4:	e0800217 	ldw	r2,8(fp)
 b005ba8:	10000226 	beq	r2,zero,b005bb4 <epcs_read_buffer+0xdc>
  {
    epcs_exit_4_bytes_mode(base);
 b005bac:	e13ffc17 	ldw	r4,-16(fp)
 b005bb0:	b005eec0 	call	b005eec <epcs_exit_4_bytes_mode>
  }

  return length;
 b005bb4:	e0bfff17 	ldw	r2,-4(fp)
}
 b005bb8:	e037883a 	mov	sp,fp
 b005bbc:	dfc00117 	ldw	ra,4(sp)
 b005bc0:	df000017 	ldw	fp,0(sp)
 b005bc4:	dec00204 	addi	sp,sp,8
 b005bc8:	f800283a 	ret

0b005bcc <epcs_write_enable>:

void epcs_write_enable(alt_u32 base)
{
 b005bcc:	defff904 	addi	sp,sp,-28
 b005bd0:	dfc00615 	stw	ra,24(sp)
 b005bd4:	df000515 	stw	fp,20(sp)
 b005bd8:	df000504 	addi	fp,sp,20
 b005bdc:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 wren = epcs_wren;
 b005be0:	00800184 	movi	r2,6
 b005be4:	e0bffe05 	stb	r2,-8(fp)
  alt_avalon_spi_command(
 b005be8:	d8000215 	stw	zero,8(sp)
 b005bec:	d8000115 	stw	zero,4(sp)
 b005bf0:	d8000015 	stw	zero,0(sp)
 b005bf4:	e1fffe04 	addi	r7,fp,-8
 b005bf8:	01800044 	movi	r6,1
 b005bfc:	000b883a 	mov	r5,zero
 b005c00:	e13fff17 	ldw	r4,-4(fp)
 b005c04:	b006cb40 	call	b006cb4 <alt_avalon_spi_command>
    &wren,
    0,
    (alt_u8*)0,
    0
  );
}
 b005c08:	0001883a 	nop
 b005c0c:	e037883a 	mov	sp,fp
 b005c10:	dfc00117 	ldw	ra,4(sp)
 b005c14:	df000017 	ldw	fp,0(sp)
 b005c18:	dec00204 	addi	sp,sp,8
 b005c1c:	f800283a 	ret

0b005c20 <epcs_write_status_register>:

void epcs_write_status_register(alt_u32 base, alt_u8 value)
{
 b005c20:	defff804 	addi	sp,sp,-32
 b005c24:	dfc00715 	stw	ra,28(sp)
 b005c28:	df000615 	stw	fp,24(sp)
 b005c2c:	df000604 	addi	fp,sp,24
 b005c30:	e13ffe15 	stw	r4,-8(fp)
 b005c34:	2805883a 	mov	r2,r5
 b005c38:	e0bfff05 	stb	r2,-4(fp)
  alt_u8 wrsr[2];
  
  wrsr[0] = epcs_wrsr;
 b005c3c:	00800044 	movi	r2,1
 b005c40:	e0bffd05 	stb	r2,-12(fp)
  wrsr[1] = value;
 b005c44:	e0bfff03 	ldbu	r2,-4(fp)
 b005c48:	e0bffd45 	stb	r2,-11(fp)

  alt_avalon_spi_command(
 b005c4c:	d8000215 	stw	zero,8(sp)
 b005c50:	d8000115 	stw	zero,4(sp)
 b005c54:	d8000015 	stw	zero,0(sp)
 b005c58:	e1fffd04 	addi	r7,fp,-12
 b005c5c:	01800084 	movi	r6,2
 b005c60:	000b883a 	mov	r5,zero
 b005c64:	e13ffe17 	ldw	r4,-8(fp)
 b005c68:	b006cb40 	call	b006cb4 <alt_avalon_spi_command>
    0,
    (alt_u8*)0,
    0
  );

  epcs_await_wip_released(base);
 b005c6c:	e13ffe17 	ldw	r4,-8(fp)
 b005c70:	b0059a00 	call	b0059a0 <epcs_await_wip_released>
}
 b005c74:	0001883a 	nop
 b005c78:	e037883a 	mov	sp,fp
 b005c7c:	dfc00117 	ldw	ra,4(sp)
 b005c80:	df000017 	ldw	fp,0(sp)
 b005c84:	dec00204 	addi	sp,sp,8
 b005c88:	f800283a 	ret

0b005c8c <epcs_write_buffer>:

/* Write a partial or full page, assuming that page has been erased */
alt_32 epcs_write_buffer(alt_u32 base, int offset, const alt_u8* src_addr, 
                         int length, alt_u32 four_bytes_mode)
{
 b005c8c:	defff404 	addi	sp,sp,-48
 b005c90:	dfc00b15 	stw	ra,44(sp)
 b005c94:	df000a15 	stw	fp,40(sp)
 b005c98:	df000a04 	addi	fp,sp,40
 b005c9c:	e13ffc15 	stw	r4,-16(fp)
 b005ca0:	e17ffd15 	stw	r5,-12(fp)
 b005ca4:	e1bffe15 	stw	r6,-8(fp)
 b005ca8:	e1ffff15 	stw	r7,-4(fp)
  alt_u8 pp[5];
  alt_u32 cmd_len;
  
  pp[0] = epcs_pp;
 b005cac:	00800084 	movi	r2,2
 b005cb0:	e0bffa05 	stb	r2,-24(fp)
  
  if(four_bytes_mode)
 b005cb4:	e0800217 	ldw	r2,8(fp)
 b005cb8:	10001026 	beq	r2,zero,b005cfc <epcs_write_buffer+0x70>
  {
      pp[1] = (offset >> 24) & 0xFF;
 b005cbc:	e0bffd17 	ldw	r2,-12(fp)
 b005cc0:	1004d63a 	srli	r2,r2,24
 b005cc4:	e0bffa45 	stb	r2,-23(fp)
      pp[2] = (offset >> 16) & 0xFF;
 b005cc8:	e0bffd17 	ldw	r2,-12(fp)
 b005ccc:	1005d43a 	srai	r2,r2,16
 b005cd0:	e0bffa85 	stb	r2,-22(fp)
      pp[3] = (offset >> 8) & 0xFF;
 b005cd4:	e0bffd17 	ldw	r2,-12(fp)
 b005cd8:	1005d23a 	srai	r2,r2,8
 b005cdc:	e0bffac5 	stb	r2,-21(fp)
      pp[4] = offset & 0xFF;
 b005ce0:	e0bffd17 	ldw	r2,-12(fp)
 b005ce4:	e0bffb05 	stb	r2,-20(fp)
      cmd_len = 5;
 b005ce8:	00800144 	movi	r2,5
 b005cec:	e0bff915 	stw	r2,-28(fp)
      epcs_enter_4_bytes_mode(base);
 b005cf0:	e13ffc17 	ldw	r4,-16(fp)
 b005cf4:	b005e900 	call	b005e90 <epcs_enter_4_bytes_mode>
 b005cf8:	00000a06 	br	b005d24 <epcs_write_buffer+0x98>
  }
  else
  {
      pp[1] = (offset >> 16) & 0xFF;
 b005cfc:	e0bffd17 	ldw	r2,-12(fp)
 b005d00:	1005d43a 	srai	r2,r2,16
 b005d04:	e0bffa45 	stb	r2,-23(fp)
      pp[2] = (offset >> 8) & 0xFF;
 b005d08:	e0bffd17 	ldw	r2,-12(fp)
 b005d0c:	1005d23a 	srai	r2,r2,8
 b005d10:	e0bffa85 	stb	r2,-22(fp)
      pp[3] = offset & 0xFF;
 b005d14:	e0bffd17 	ldw	r2,-12(fp)
 b005d18:	e0bffac5 	stb	r2,-21(fp)
      cmd_len = 4;
 b005d1c:	00800104 	movi	r2,4
 b005d20:	e0bff915 	stw	r2,-28(fp)
  }

  /* First, WREN */
  epcs_write_enable(base);
 b005d24:	e13ffc17 	ldw	r4,-16(fp)
 b005d28:	b005bcc0 	call	b005bcc <epcs_write_enable>

  /* Send the PP command */
  alt_avalon_spi_command(
 b005d2c:	e0fffa04 	addi	r3,fp,-24
 b005d30:	00800044 	movi	r2,1
 b005d34:	d8800215 	stw	r2,8(sp)
 b005d38:	d8000115 	stw	zero,4(sp)
 b005d3c:	d8000015 	stw	zero,0(sp)
 b005d40:	180f883a 	mov	r7,r3
 b005d44:	e1bff917 	ldw	r6,-28(fp)
 b005d48:	000b883a 	mov	r5,zero
 b005d4c:	e13ffc17 	ldw	r4,-16(fp)
 b005d50:	b006cb40 	call	b006cb4 <alt_avalon_spi_command>
    (alt_u8*)0,
    ALT_AVALON_SPI_COMMAND_MERGE
  );

  /* Send the user's buffer */
  alt_avalon_spi_command(
 b005d54:	e0bfff17 	ldw	r2,-4(fp)
 b005d58:	d8000215 	stw	zero,8(sp)
 b005d5c:	d8000115 	stw	zero,4(sp)
 b005d60:	d8000015 	stw	zero,0(sp)
 b005d64:	e1fffe17 	ldw	r7,-8(fp)
 b005d68:	100d883a 	mov	r6,r2
 b005d6c:	000b883a 	mov	r5,zero
 b005d70:	e13ffc17 	ldw	r4,-16(fp)
 b005d74:	b006cb40 	call	b006cb4 <alt_avalon_spi_command>
   * if the user's going to go off and ignore the flash for
   * a while, its writes could occur in parallel with user code
   * execution.  Unfortunately, I have to guard all reads/writes
   * with wip-tests, to make that happen.
   */
  epcs_await_wip_released(base);
 b005d78:	e13ffc17 	ldw	r4,-16(fp)
 b005d7c:	b0059a00 	call	b0059a0 <epcs_await_wip_released>

  if(four_bytes_mode)
 b005d80:	e0800217 	ldw	r2,8(fp)
 b005d84:	10000226 	beq	r2,zero,b005d90 <epcs_write_buffer+0x104>
  {
    epcs_exit_4_bytes_mode(base);
 b005d88:	e13ffc17 	ldw	r4,-16(fp)
 b005d8c:	b005eec0 	call	b005eec <epcs_exit_4_bytes_mode>
  }

  return length;
 b005d90:	e0bfff17 	ldw	r2,-4(fp)
}
 b005d94:	e037883a 	mov	sp,fp
 b005d98:	dfc00117 	ldw	ra,4(sp)
 b005d9c:	df000017 	ldw	fp,0(sp)
 b005da0:	dec00204 	addi	sp,sp,8
 b005da4:	f800283a 	ret

0b005da8 <epcs_read_electronic_signature>:


alt_u8 epcs_read_electronic_signature(alt_u32 base)
{
 b005da8:	defff804 	addi	sp,sp,-32
 b005dac:	dfc00715 	stw	ra,28(sp)
 b005db0:	df000615 	stw	fp,24(sp)
 b005db4:	df000604 	addi	fp,sp,24
 b005db8:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 res_cmd[] = {epcs_res, 0, 0, 0};
 b005dbc:	00bfeac4 	movi	r2,-85
 b005dc0:	e0bffd05 	stb	r2,-12(fp)
 b005dc4:	e03ffd45 	stb	zero,-11(fp)
 b005dc8:	e03ffd85 	stb	zero,-10(fp)
 b005dcc:	e03ffdc5 	stb	zero,-9(fp)
  alt_u8 res;

  alt_avalon_spi_command(
 b005dd0:	d8000215 	stw	zero,8(sp)
 b005dd4:	e0bffe04 	addi	r2,fp,-8
 b005dd8:	d8800115 	stw	r2,4(sp)
 b005ddc:	00800044 	movi	r2,1
 b005de0:	d8800015 	stw	r2,0(sp)
 b005de4:	e1fffd04 	addi	r7,fp,-12
 b005de8:	01800104 	movi	r6,4
 b005dec:	000b883a 	mov	r5,zero
 b005df0:	e13fff17 	ldw	r4,-4(fp)
 b005df4:	b006cb40 	call	b006cb4 <alt_avalon_spi_command>
    1,
    &res,
    0
  );

  return res;
 b005df8:	e0bffe03 	ldbu	r2,-8(fp)
}
 b005dfc:	e037883a 	mov	sp,fp
 b005e00:	dfc00117 	ldw	ra,4(sp)
 b005e04:	df000017 	ldw	fp,0(sp)
 b005e08:	dec00204 	addi	sp,sp,8
 b005e0c:	f800283a 	ret

0b005e10 <epcs_read_device_id>:

alt_u32 epcs_read_device_id(alt_u32 base)
{
 b005e10:	defff904 	addi	sp,sp,-28
 b005e14:	dfc00615 	stw	ra,24(sp)
 b005e18:	df000515 	stw	fp,20(sp)
 b005e1c:	df000504 	addi	fp,sp,20
 b005e20:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 rd_id_cmd[] = {epcs_rdid};
 b005e24:	00bfe7c4 	movi	r2,-97
 b005e28:	e0bffe05 	stb	r2,-8(fp)
  alt_u8 id[3];

  alt_avalon_spi_command(
 b005e2c:	d8000215 	stw	zero,8(sp)
 b005e30:	e0bffe44 	addi	r2,fp,-7
 b005e34:	d8800115 	stw	r2,4(sp)
 b005e38:	008000c4 	movi	r2,3
 b005e3c:	d8800015 	stw	r2,0(sp)
 b005e40:	e1fffe04 	addi	r7,fp,-8
 b005e44:	01800044 	movi	r6,1
 b005e48:	000b883a 	mov	r5,zero
 b005e4c:	e13fff17 	ldw	r4,-4(fp)
 b005e50:	b006cb40 	call	b006cb4 <alt_avalon_spi_command>
    3,
    id,
    0
  );

  return (alt_u32) ((id[0] << 16) | (id[1] << 8) | id[2]);
 b005e54:	e0bffe43 	ldbu	r2,-7(fp)
 b005e58:	10803fcc 	andi	r2,r2,255
 b005e5c:	1006943a 	slli	r3,r2,16
 b005e60:	e0bffe83 	ldbu	r2,-6(fp)
 b005e64:	10803fcc 	andi	r2,r2,255
 b005e68:	1004923a 	slli	r2,r2,8
 b005e6c:	1886b03a 	or	r3,r3,r2
 b005e70:	e0bffec3 	ldbu	r2,-5(fp)
 b005e74:	10803fcc 	andi	r2,r2,255
 b005e78:	1884b03a 	or	r2,r3,r2
}
 b005e7c:	e037883a 	mov	sp,fp
 b005e80:	dfc00117 	ldw	ra,4(sp)
 b005e84:	df000017 	ldw	fp,0(sp)
 b005e88:	dec00204 	addi	sp,sp,8
 b005e8c:	f800283a 	ret

0b005e90 <epcs_enter_4_bytes_mode>:

void epcs_enter_4_bytes_mode(alt_u32 base)
{
 b005e90:	defff904 	addi	sp,sp,-28
 b005e94:	dfc00615 	stw	ra,24(sp)
 b005e98:	df000515 	stw	fp,20(sp)
 b005e9c:	df000504 	addi	fp,sp,20
 b005ea0:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 en4b_cmd = epcs_en4b;
 b005ea4:	00bfedc4 	movi	r2,-73
 b005ea8:	e0bffe05 	stb	r2,-8(fp)

  /* First, WREN */
  epcs_write_enable(base);
 b005eac:	e13fff17 	ldw	r4,-4(fp)
 b005eb0:	b005bcc0 	call	b005bcc <epcs_write_enable>

  alt_avalon_spi_command(
 b005eb4:	d8000215 	stw	zero,8(sp)
 b005eb8:	d8000115 	stw	zero,4(sp)
 b005ebc:	d8000015 	stw	zero,0(sp)
 b005ec0:	e1fffe04 	addi	r7,fp,-8
 b005ec4:	01800044 	movi	r6,1
 b005ec8:	000b883a 	mov	r5,zero
 b005ecc:	e13fff17 	ldw	r4,-4(fp)
 b005ed0:	b006cb40 	call	b006cb4 <alt_avalon_spi_command>
    0,
    (alt_u8*)0,
    0
  );

  return;
 b005ed4:	0001883a 	nop
}
 b005ed8:	e037883a 	mov	sp,fp
 b005edc:	dfc00117 	ldw	ra,4(sp)
 b005ee0:	df000017 	ldw	fp,0(sp)
 b005ee4:	dec00204 	addi	sp,sp,8
 b005ee8:	f800283a 	ret

0b005eec <epcs_exit_4_bytes_mode>:

void epcs_exit_4_bytes_mode(alt_u32 base)
{
 b005eec:	defff904 	addi	sp,sp,-28
 b005ef0:	dfc00615 	stw	ra,24(sp)
 b005ef4:	df000515 	stw	fp,20(sp)
 b005ef8:	df000504 	addi	fp,sp,20
 b005efc:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 exit4b_cmd = epcs_dis4b;
 b005f00:	00bffa44 	movi	r2,-23
 b005f04:	e0bffe05 	stb	r2,-8(fp)

  /* First, WREN */
  epcs_write_enable(base);
 b005f08:	e13fff17 	ldw	r4,-4(fp)
 b005f0c:	b005bcc0 	call	b005bcc <epcs_write_enable>

  alt_avalon_spi_command(
 b005f10:	d8000215 	stw	zero,8(sp)
 b005f14:	d8000115 	stw	zero,4(sp)
 b005f18:	d8000015 	stw	zero,0(sp)
 b005f1c:	e1fffe04 	addi	r7,fp,-8
 b005f20:	01800044 	movi	r6,1
 b005f24:	000b883a 	mov	r5,zero
 b005f28:	e13fff17 	ldw	r4,-4(fp)
 b005f2c:	b006cb40 	call	b006cb4 <alt_avalon_spi_command>
    0,
    (alt_u8*)0,
    0
  );

  return;
 b005f30:	0001883a 	nop
}
 b005f34:	e037883a 	mov	sp,fp
 b005f38:	dfc00117 	ldw	ra,4(sp)
 b005f3c:	df000017 	ldw	fp,0(sp)
 b005f40:	dec00204 	addi	sp,sp,8
 b005f44:	f800283a 	ret

0b005f48 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
 b005f48:	defff504 	addi	sp,sp,-44
 b005f4c:	df000a15 	stw	fp,40(sp)
 b005f50:	df000a04 	addi	fp,sp,40
 b005f54:	e13ffc15 	stw	r4,-16(fp)
 b005f58:	e17ffd15 	stw	r5,-12(fp)
 b005f5c:	e1bffe15 	stw	r6,-8(fp)
 b005f60:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
 b005f64:	e03ff615 	stw	zero,-40(fp)
 b005f68:	d0a72417 	ldw	r2,-25456(gp)
  
  if (alt_ticks_per_second ())
 b005f6c:	10003c26 	beq	r2,zero,b006060 <alt_alarm_start+0x118>
  {
    if (alarm)
 b005f70:	e0bffc17 	ldw	r2,-16(fp)
 b005f74:	10003826 	beq	r2,zero,b006058 <alt_alarm_start+0x110>
    {
      alarm->callback = callback;
 b005f78:	e0bffc17 	ldw	r2,-16(fp)
 b005f7c:	e0fffe17 	ldw	r3,-8(fp)
 b005f80:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
 b005f84:	e0bffc17 	ldw	r2,-16(fp)
 b005f88:	e0ffff17 	ldw	r3,-4(fp)
 b005f8c:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 b005f90:	0005303a 	rdctl	r2,status
 b005f94:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 b005f98:	e0fff917 	ldw	r3,-28(fp)
 b005f9c:	00bfff84 	movi	r2,-2
 b005fa0:	1884703a 	and	r2,r3,r2
 b005fa4:	1001703a 	wrctl	status,r2
  
  return context;
 b005fa8:	e0bff917 	ldw	r2,-28(fp)
 
      irq_context = alt_irq_disable_all ();
 b005fac:	e0bff815 	stw	r2,-32(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
 b005fb0:	d0a72517 	ldw	r2,-25452(gp)
      
      current_nticks = alt_nticks();
 b005fb4:	e0bff615 	stw	r2,-40(fp)
      
      alarm->time = nticks + current_nticks + 1; 
 b005fb8:	e0fffd17 	ldw	r3,-12(fp)
 b005fbc:	e0bff617 	ldw	r2,-40(fp)
 b005fc0:	1885883a 	add	r2,r3,r2
 b005fc4:	10c00044 	addi	r3,r2,1
 b005fc8:	e0bffc17 	ldw	r2,-16(fp)
 b005fcc:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
 b005fd0:	e0bffc17 	ldw	r2,-16(fp)
 b005fd4:	10c00217 	ldw	r3,8(r2)
 b005fd8:	e0bff617 	ldw	r2,-40(fp)
 b005fdc:	1880042e 	bgeu	r3,r2,b005ff0 <alt_alarm_start+0xa8>
      {
        alarm->rollover = 1;
 b005fe0:	e0bffc17 	ldw	r2,-16(fp)
 b005fe4:	00c00044 	movi	r3,1
 b005fe8:	10c00405 	stb	r3,16(r2)
 b005fec:	00000206 	br	b005ff8 <alt_alarm_start+0xb0>
      }
      else
      {
        alarm->rollover = 0;
 b005ff0:	e0bffc17 	ldw	r2,-16(fp)
 b005ff4:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
 b005ff8:	e0bffc17 	ldw	r2,-16(fp)
 b005ffc:	d0e00e04 	addi	r3,gp,-32712
 b006000:	e0fffa15 	stw	r3,-24(fp)
 b006004:	e0bffb15 	stw	r2,-20(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 b006008:	e0bffb17 	ldw	r2,-20(fp)
 b00600c:	e0fffa17 	ldw	r3,-24(fp)
 b006010:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 b006014:	e0bffa17 	ldw	r2,-24(fp)
 b006018:	10c00017 	ldw	r3,0(r2)
 b00601c:	e0bffb17 	ldw	r2,-20(fp)
 b006020:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 b006024:	e0bffa17 	ldw	r2,-24(fp)
 b006028:	10800017 	ldw	r2,0(r2)
 b00602c:	e0fffb17 	ldw	r3,-20(fp)
 b006030:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 b006034:	e0bffa17 	ldw	r2,-24(fp)
 b006038:	e0fffb17 	ldw	r3,-20(fp)
 b00603c:	10c00015 	stw	r3,0(r2)
 b006040:	e0bff817 	ldw	r2,-32(fp)
 b006044:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 b006048:	e0bff717 	ldw	r2,-36(fp)
 b00604c:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
 b006050:	0005883a 	mov	r2,zero
 b006054:	00000306 	br	b006064 <alt_alarm_start+0x11c>
    }
    else
    {
      return -EINVAL;
 b006058:	00bffa84 	movi	r2,-22
 b00605c:	00000106 	br	b006064 <alt_alarm_start+0x11c>
    }
  }
  else
  {
    return -ENOTSUP;
 b006060:	00bfde84 	movi	r2,-134
  }
}
 b006064:	e037883a 	mov	sp,fp
 b006068:	df000017 	ldw	fp,0(sp)
 b00606c:	dec00104 	addi	sp,sp,4
 b006070:	f800283a 	ret

0b006074 <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
 b006074:	defffa04 	addi	sp,sp,-24
 b006078:	dfc00515 	stw	ra,20(sp)
 b00607c:	df000415 	stw	fp,16(sp)
 b006080:	df000404 	addi	fp,sp,16
 b006084:	e13fff15 	stw	r4,-4(fp)
  int big_loops;
  alt_u32 cycles_per_loop;
  
  if (!strcmp(NIOS2_CPU_IMPLEMENTATION,"tiny"))
  {
    cycles_per_loop = 9;
 b006088:	00800244 	movi	r2,9
 b00608c:	e0bffd15 	stw	r2,-12(fp)
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));
 b006090:	014003f4 	movhi	r5,15
 b006094:	29509004 	addi	r5,r5,16960
 b006098:	e13ffd17 	ldw	r4,-12(fp)
 b00609c:	b0030100 	call	b003010 <__mulsi3>
 b0060a0:	100b883a 	mov	r5,r2
 b0060a4:	01017db4 	movhi	r4,1526
 b0060a8:	21384004 	addi	r4,r4,-7936
 b0060ac:	b002f540 	call	b002f54 <__udivsi3>
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
 b0060b0:	100b883a 	mov	r5,r2
 b0060b4:	01200034 	movhi	r4,32768
 b0060b8:	213fffc4 	addi	r4,r4,-1
 b0060bc:	b002f540 	call	b002f54 <__udivsi3>
 b0060c0:	100b883a 	mov	r5,r2
 b0060c4:	e13fff17 	ldw	r4,-4(fp)
 b0060c8:	b002f540 	call	b002f54 <__udivsi3>
 b0060cc:	e0bffe15 	stw	r2,-8(fp)
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
 b0060d0:	e0bffe17 	ldw	r2,-8(fp)
 b0060d4:	10002a26 	beq	r2,zero,b006180 <alt_busy_sleep+0x10c>
  {
    for(i=0;i<big_loops;i++)
 b0060d8:	e03ffc15 	stw	zero,-16(fp)
 b0060dc:	00001706 	br	b00613c <alt_busy_sleep+0xc8>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
 b0060e0:	00a00034 	movhi	r2,32768
 b0060e4:	10bfffc4 	addi	r2,r2,-1
 b0060e8:	10bfffc4 	addi	r2,r2,-1
 b0060ec:	103ffe1e 	bne	r2,zero,b0060e8 <__alt_mem_flash+0xff0050e8>
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
      (cycles_per_loop * 1000000)));
 b0060f0:	014003f4 	movhi	r5,15
 b0060f4:	29509004 	addi	r5,r5,16960
 b0060f8:	e13ffd17 	ldw	r4,-12(fp)
 b0060fc:	b0030100 	call	b003010 <__mulsi3>
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
 b006100:	100b883a 	mov	r5,r2
 b006104:	01017db4 	movhi	r4,1526
 b006108:	21384004 	addi	r4,r4,-7936
 b00610c:	b002f540 	call	b002f54 <__udivsi3>
 b006110:	100b883a 	mov	r5,r2
 b006114:	01200034 	movhi	r4,32768
 b006118:	213fffc4 	addi	r4,r4,-1
 b00611c:	b002f540 	call	b002f54 <__udivsi3>
 b006120:	1007883a 	mov	r3,r2
 b006124:	e0bfff17 	ldw	r2,-4(fp)
 b006128:	10c5c83a 	sub	r2,r2,r3
 b00612c:	e0bfff15 	stw	r2,-4(fp)
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
 b006130:	e0bffc17 	ldw	r2,-16(fp)
 b006134:	10800044 	addi	r2,r2,1
 b006138:	e0bffc15 	stw	r2,-16(fp)
 b00613c:	e0fffc17 	ldw	r3,-16(fp)
 b006140:	e0bffe17 	ldw	r2,-8(fp)
 b006144:	18bfe616 	blt	r3,r2,b0060e0 <__alt_mem_flash+0xff0050e0>
      "\n\tbne %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
 b006148:	014003f4 	movhi	r5,15
 b00614c:	29509004 	addi	r5,r5,16960
 b006150:	e13ffd17 	ldw	r4,-12(fp)
 b006154:	b0030100 	call	b003010 <__mulsi3>
 b006158:	100b883a 	mov	r5,r2
 b00615c:	01017db4 	movhi	r4,1526
 b006160:	21384004 	addi	r4,r4,-7936
 b006164:	b002f540 	call	b002f54 <__udivsi3>
 b006168:	e17fff17 	ldw	r5,-4(fp)
 b00616c:	1009883a 	mov	r4,r2
 b006170:	b0030100 	call	b003010 <__mulsi3>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
 b006174:	10bfffc4 	addi	r2,r2,-1
 b006178:	103ffe1e 	bne	r2,zero,b006174 <__alt_mem_flash+0xff005174>
 b00617c:	00000d06 	br	b0061b4 <alt_busy_sleep+0x140>
      "\n\tbgt %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
 b006180:	014003f4 	movhi	r5,15
 b006184:	29509004 	addi	r5,r5,16960
 b006188:	e13ffd17 	ldw	r4,-12(fp)
 b00618c:	b0030100 	call	b003010 <__mulsi3>
 b006190:	100b883a 	mov	r5,r2
 b006194:	01017db4 	movhi	r4,1526
 b006198:	21384004 	addi	r4,r4,-7936
 b00619c:	b002f540 	call	b002f54 <__udivsi3>
 b0061a0:	e17fff17 	ldw	r5,-4(fp)
 b0061a4:	1009883a 	mov	r4,r2
 b0061a8:	b0030100 	call	b003010 <__mulsi3>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
 b0061ac:	10bfffc4 	addi	r2,r2,-1
 b0061b0:	00bffe16 	blt	zero,r2,b0061ac <__alt_mem_flash+0xff0051ac>
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
 b0061b4:	0005883a 	mov	r2,zero
}
 b0061b8:	e037883a 	mov	sp,fp
 b0061bc:	dfc00117 	ldw	ra,4(sp)
 b0061c0:	df000017 	ldw	fp,0(sp)
 b0061c4:	dec00204 	addi	sp,sp,8
 b0061c8:	f800283a 	ret

0b0061cc <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
 b0061cc:	deffff04 	addi	sp,sp,-4
 b0061d0:	df000015 	stw	fp,0(sp)
 b0061d4:	d839883a 	mov	fp,sp
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
 b0061d8:	0001883a 	nop
 b0061dc:	e037883a 	mov	sp,fp
 b0061e0:	df000017 	ldw	fp,0(sp)
 b0061e4:	dec00104 	addi	sp,sp,4
 b0061e8:	f800283a 	ret

0b0061ec <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 b0061ec:	defffe04 	addi	sp,sp,-8
 b0061f0:	dfc00115 	stw	ra,4(sp)
 b0061f4:	df000015 	stw	fp,0(sp)
 b0061f8:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 b0061fc:	d0a00917 	ldw	r2,-32732(gp)
 b006200:	10000326 	beq	r2,zero,b006210 <alt_get_errno+0x24>
 b006204:	d0a00917 	ldw	r2,-32732(gp)
 b006208:	103ee83a 	callr	r2
 b00620c:	00000106 	br	b006214 <alt_get_errno+0x28>
 b006210:	d0a71f04 	addi	r2,gp,-25476
}
 b006214:	e037883a 	mov	sp,fp
 b006218:	dfc00117 	ldw	ra,4(sp)
 b00621c:	df000017 	ldw	fp,0(sp)
 b006220:	dec00204 	addi	sp,sp,8
 b006224:	f800283a 	ret

0b006228 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
 b006228:	defffa04 	addi	sp,sp,-24
 b00622c:	dfc00515 	stw	ra,20(sp)
 b006230:	df000415 	stw	fp,16(sp)
 b006234:	df000404 	addi	fp,sp,16
 b006238:	e13ffe15 	stw	r4,-8(fp)
 b00623c:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
 b006240:	e0bffe17 	ldw	r2,-8(fp)
 b006244:	10000326 	beq	r2,zero,b006254 <alt_dev_llist_insert+0x2c>
 b006248:	e0bffe17 	ldw	r2,-8(fp)
 b00624c:	10800217 	ldw	r2,8(r2)
 b006250:	1000061e 	bne	r2,zero,b00626c <alt_dev_llist_insert+0x44>
  {
    ALT_ERRNO = EINVAL;
 b006254:	b0061ec0 	call	b0061ec <alt_get_errno>
 b006258:	1007883a 	mov	r3,r2
 b00625c:	00800584 	movi	r2,22
 b006260:	18800015 	stw	r2,0(r3)
    return -EINVAL;
 b006264:	00bffa84 	movi	r2,-22
 b006268:	00001306 	br	b0062b8 <alt_dev_llist_insert+0x90>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
 b00626c:	e0bffe17 	ldw	r2,-8(fp)
 b006270:	e0ffff17 	ldw	r3,-4(fp)
 b006274:	e0fffc15 	stw	r3,-16(fp)
 b006278:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 b00627c:	e0bffd17 	ldw	r2,-12(fp)
 b006280:	e0fffc17 	ldw	r3,-16(fp)
 b006284:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 b006288:	e0bffc17 	ldw	r2,-16(fp)
 b00628c:	10c00017 	ldw	r3,0(r2)
 b006290:	e0bffd17 	ldw	r2,-12(fp)
 b006294:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 b006298:	e0bffc17 	ldw	r2,-16(fp)
 b00629c:	10800017 	ldw	r2,0(r2)
 b0062a0:	e0fffd17 	ldw	r3,-12(fp)
 b0062a4:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 b0062a8:	e0bffc17 	ldw	r2,-16(fp)
 b0062ac:	e0fffd17 	ldw	r3,-12(fp)
 b0062b0:	10c00015 	stw	r3,0(r2)

  return 0;  
 b0062b4:	0005883a 	mov	r2,zero
}
 b0062b8:	e037883a 	mov	sp,fp
 b0062bc:	dfc00117 	ldw	ra,4(sp)
 b0062c0:	df000017 	ldw	fp,0(sp)
 b0062c4:	dec00204 	addi	sp,sp,8
 b0062c8:	f800283a 	ret

0b0062cc <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
 b0062cc:	defffd04 	addi	sp,sp,-12
 b0062d0:	dfc00215 	stw	ra,8(sp)
 b0062d4:	df000115 	stw	fp,4(sp)
 b0062d8:	df000104 	addi	fp,sp,4
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 b0062dc:	0082c034 	movhi	r2,2816
 b0062e0:	109d7404 	addi	r2,r2,30160
 b0062e4:	e0bfff15 	stw	r2,-4(fp)
 b0062e8:	00000606 	br	b006304 <_do_ctors+0x38>
        (*ctor) (); 
 b0062ec:	e0bfff17 	ldw	r2,-4(fp)
 b0062f0:	10800017 	ldw	r2,0(r2)
 b0062f4:	103ee83a 	callr	r2

void _do_ctors(void)
{
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 b0062f8:	e0bfff17 	ldw	r2,-4(fp)
 b0062fc:	10bfff04 	addi	r2,r2,-4
 b006300:	e0bfff15 	stw	r2,-4(fp)
 b006304:	e0ffff17 	ldw	r3,-4(fp)
 b006308:	0082c034 	movhi	r2,2816
 b00630c:	109d7504 	addi	r2,r2,30164
 b006310:	18bff62e 	bgeu	r3,r2,b0062ec <__alt_mem_flash+0xff0052ec>
        (*ctor) (); 
}
 b006314:	0001883a 	nop
 b006318:	e037883a 	mov	sp,fp
 b00631c:	dfc00117 	ldw	ra,4(sp)
 b006320:	df000017 	ldw	fp,0(sp)
 b006324:	dec00204 	addi	sp,sp,8
 b006328:	f800283a 	ret

0b00632c <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
 b00632c:	defffd04 	addi	sp,sp,-12
 b006330:	dfc00215 	stw	ra,8(sp)
 b006334:	df000115 	stw	fp,4(sp)
 b006338:	df000104 	addi	fp,sp,4
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 b00633c:	0082c034 	movhi	r2,2816
 b006340:	109d7404 	addi	r2,r2,30160
 b006344:	e0bfff15 	stw	r2,-4(fp)
 b006348:	00000606 	br	b006364 <_do_dtors+0x38>
        (*dtor) (); 
 b00634c:	e0bfff17 	ldw	r2,-4(fp)
 b006350:	10800017 	ldw	r2,0(r2)
 b006354:	103ee83a 	callr	r2

void _do_dtors(void)
{
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 b006358:	e0bfff17 	ldw	r2,-4(fp)
 b00635c:	10bfff04 	addi	r2,r2,-4
 b006360:	e0bfff15 	stw	r2,-4(fp)
 b006364:	e0ffff17 	ldw	r3,-4(fp)
 b006368:	0082c034 	movhi	r2,2816
 b00636c:	109d7504 	addi	r2,r2,30164
 b006370:	18bff62e 	bgeu	r3,r2,b00634c <__alt_mem_flash+0xff00534c>
        (*dtor) (); 
}
 b006374:	0001883a 	nop
 b006378:	e037883a 	mov	sp,fp
 b00637c:	dfc00117 	ldw	ra,4(sp)
 b006380:	df000017 	ldw	fp,0(sp)
 b006384:	dec00204 	addi	sp,sp,8
 b006388:	f800283a 	ret

0b00638c <alt_flash_open_dev>:
#include "priv/alt_file.h"

ALT_LLIST_HEAD(alt_flash_dev_list);

alt_flash_fd* alt_flash_open_dev(const char* name)
{
 b00638c:	defffc04 	addi	sp,sp,-16
 b006390:	dfc00315 	stw	ra,12(sp)
 b006394:	df000215 	stw	fp,8(sp)
 b006398:	df000204 	addi	fp,sp,8
 b00639c:	e13fff15 	stw	r4,-4(fp)
  alt_flash_dev* dev = (alt_flash_dev*)alt_find_dev(name, &alt_flash_dev_list);
 b0063a0:	d1600b04 	addi	r5,gp,-32724
 b0063a4:	e13fff17 	ldw	r4,-4(fp)
 b0063a8:	b006eb00 	call	b006eb0 <alt_find_dev>
 b0063ac:	e0bffe15 	stw	r2,-8(fp)

  if ((dev) && dev->open)
 b0063b0:	e0bffe17 	ldw	r2,-8(fp)
 b0063b4:	10000926 	beq	r2,zero,b0063dc <alt_flash_open_dev+0x50>
 b0063b8:	e0bffe17 	ldw	r2,-8(fp)
 b0063bc:	10800317 	ldw	r2,12(r2)
 b0063c0:	10000626 	beq	r2,zero,b0063dc <alt_flash_open_dev+0x50>
  {
    return dev->open(dev, name);
 b0063c4:	e0bffe17 	ldw	r2,-8(fp)
 b0063c8:	10800317 	ldw	r2,12(r2)
 b0063cc:	e17fff17 	ldw	r5,-4(fp)
 b0063d0:	e13ffe17 	ldw	r4,-8(fp)
 b0063d4:	103ee83a 	callr	r2
 b0063d8:	00000106 	br	b0063e0 <alt_flash_open_dev+0x54>
  }

  return dev;
 b0063dc:	e0bffe17 	ldw	r2,-8(fp)
}
 b0063e0:	e037883a 	mov	sp,fp
 b0063e4:	dfc00117 	ldw	ra,4(sp)
 b0063e8:	df000017 	ldw	fp,0(sp)
 b0063ec:	dec00204 	addi	sp,sp,8
 b0063f0:	f800283a 	ret

0b0063f4 <alt_flash_close_dev>:

void alt_flash_close_dev(alt_flash_fd* fd)
{
 b0063f4:	defffd04 	addi	sp,sp,-12
 b0063f8:	dfc00215 	stw	ra,8(sp)
 b0063fc:	df000115 	stw	fp,4(sp)
 b006400:	df000104 	addi	fp,sp,4
 b006404:	e13fff15 	stw	r4,-4(fp)
  if (fd && fd->close)
 b006408:	e0bfff17 	ldw	r2,-4(fp)
 b00640c:	10000826 	beq	r2,zero,b006430 <alt_flash_close_dev+0x3c>
 b006410:	e0bfff17 	ldw	r2,-4(fp)
 b006414:	10800417 	ldw	r2,16(r2)
 b006418:	10000526 	beq	r2,zero,b006430 <alt_flash_close_dev+0x3c>
  {
    fd->close(fd);
 b00641c:	e0bfff17 	ldw	r2,-4(fp)
 b006420:	10800417 	ldw	r2,16(r2)
 b006424:	e13fff17 	ldw	r4,-4(fp)
 b006428:	103ee83a 	callr	r2
  }
  return;
 b00642c:	0001883a 	nop
 b006430:	0001883a 	nop
}
 b006434:	e037883a 	mov	sp,fp
 b006438:	dfc00117 	ldw	ra,4(sp)
 b00643c:	df000017 	ldw	fp,0(sp)
 b006440:	dec00204 	addi	sp,sp,8
 b006444:	f800283a 	ret

0b006448 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
 b006448:	deffff04 	addi	sp,sp,-4
 b00644c:	df000015 	stw	fp,0(sp)
 b006450:	d839883a 	mov	fp,sp
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
#endif
}
 b006454:	0001883a 	nop
 b006458:	e037883a 	mov	sp,fp
 b00645c:	df000017 	ldw	fp,0(sp)
 b006460:	dec00104 	addi	sp,sp,4
 b006464:	f800283a 	ret

0b006468 <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 b006468:	defff904 	addi	sp,sp,-28
 b00646c:	dfc00615 	stw	ra,24(sp)
 b006470:	df000515 	stw	fp,20(sp)
 b006474:	df000504 	addi	fp,sp,20
 b006478:	e13ffc15 	stw	r4,-16(fp)
 b00647c:	e17ffd15 	stw	r5,-12(fp)
 b006480:	e1bffe15 	stw	r6,-8(fp)
 b006484:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
 b006488:	e0800217 	ldw	r2,8(fp)
 b00648c:	d8800015 	stw	r2,0(sp)
 b006490:	e1ffff17 	ldw	r7,-4(fp)
 b006494:	e1bffe17 	ldw	r6,-8(fp)
 b006498:	e17ffd17 	ldw	r5,-12(fp)
 b00649c:	e13ffc17 	ldw	r4,-16(fp)
 b0064a0:	b0066180 	call	b006618 <alt_iic_isr_register>
}  
 b0064a4:	e037883a 	mov	sp,fp
 b0064a8:	dfc00117 	ldw	ra,4(sp)
 b0064ac:	df000017 	ldw	fp,0(sp)
 b0064b0:	dec00204 	addi	sp,sp,8
 b0064b4:	f800283a 	ret

0b0064b8 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
 b0064b8:	defff904 	addi	sp,sp,-28
 b0064bc:	df000615 	stw	fp,24(sp)
 b0064c0:	df000604 	addi	fp,sp,24
 b0064c4:	e13ffe15 	stw	r4,-8(fp)
 b0064c8:	e17fff15 	stw	r5,-4(fp)
 b0064cc:	e0bfff17 	ldw	r2,-4(fp)
 b0064d0:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 b0064d4:	0005303a 	rdctl	r2,status
 b0064d8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 b0064dc:	e0fffb17 	ldw	r3,-20(fp)
 b0064e0:	00bfff84 	movi	r2,-2
 b0064e4:	1884703a 	and	r2,r3,r2
 b0064e8:	1001703a 	wrctl	status,r2
  
  return context;
 b0064ec:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 b0064f0:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active |= (1 << id);
 b0064f4:	00c00044 	movi	r3,1
 b0064f8:	e0bffa17 	ldw	r2,-24(fp)
 b0064fc:	1884983a 	sll	r2,r3,r2
 b006500:	1007883a 	mov	r3,r2
 b006504:	d0a72317 	ldw	r2,-25460(gp)
 b006508:	1884b03a 	or	r2,r3,r2
 b00650c:	d0a72315 	stw	r2,-25460(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 b006510:	d0a72317 	ldw	r2,-25460(gp)
 b006514:	100170fa 	wrctl	ienable,r2
 b006518:	e0bffc17 	ldw	r2,-16(fp)
 b00651c:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 b006520:	e0bffd17 	ldw	r2,-12(fp)
 b006524:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 b006528:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
 b00652c:	0001883a 	nop
}
 b006530:	e037883a 	mov	sp,fp
 b006534:	df000017 	ldw	fp,0(sp)
 b006538:	dec00104 	addi	sp,sp,4
 b00653c:	f800283a 	ret

0b006540 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
 b006540:	defff904 	addi	sp,sp,-28
 b006544:	df000615 	stw	fp,24(sp)
 b006548:	df000604 	addi	fp,sp,24
 b00654c:	e13ffe15 	stw	r4,-8(fp)
 b006550:	e17fff15 	stw	r5,-4(fp)
 b006554:	e0bfff17 	ldw	r2,-4(fp)
 b006558:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 b00655c:	0005303a 	rdctl	r2,status
 b006560:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 b006564:	e0fffb17 	ldw	r3,-20(fp)
 b006568:	00bfff84 	movi	r2,-2
 b00656c:	1884703a 	and	r2,r3,r2
 b006570:	1001703a 	wrctl	status,r2
  
  return context;
 b006574:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 b006578:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active &= ~(1 << id);
 b00657c:	00c00044 	movi	r3,1
 b006580:	e0bffa17 	ldw	r2,-24(fp)
 b006584:	1884983a 	sll	r2,r3,r2
 b006588:	0084303a 	nor	r2,zero,r2
 b00658c:	1007883a 	mov	r3,r2
 b006590:	d0a72317 	ldw	r2,-25460(gp)
 b006594:	1884703a 	and	r2,r3,r2
 b006598:	d0a72315 	stw	r2,-25460(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 b00659c:	d0a72317 	ldw	r2,-25460(gp)
 b0065a0:	100170fa 	wrctl	ienable,r2
 b0065a4:	e0bffc17 	ldw	r2,-16(fp)
 b0065a8:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 b0065ac:	e0bffd17 	ldw	r2,-12(fp)
 b0065b0:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 b0065b4:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
 b0065b8:	0001883a 	nop
}
 b0065bc:	e037883a 	mov	sp,fp
 b0065c0:	df000017 	ldw	fp,0(sp)
 b0065c4:	dec00104 	addi	sp,sp,4
 b0065c8:	f800283a 	ret

0b0065cc <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
 b0065cc:	defffc04 	addi	sp,sp,-16
 b0065d0:	df000315 	stw	fp,12(sp)
 b0065d4:	df000304 	addi	fp,sp,12
 b0065d8:	e13ffe15 	stw	r4,-8(fp)
 b0065dc:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
 b0065e0:	000530fa 	rdctl	r2,ienable
 b0065e4:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
 b0065e8:	00c00044 	movi	r3,1
 b0065ec:	e0bfff17 	ldw	r2,-4(fp)
 b0065f0:	1884983a 	sll	r2,r3,r2
 b0065f4:	1007883a 	mov	r3,r2
 b0065f8:	e0bffd17 	ldw	r2,-12(fp)
 b0065fc:	1884703a 	and	r2,r3,r2
 b006600:	1004c03a 	cmpne	r2,r2,zero
 b006604:	10803fcc 	andi	r2,r2,255
}
 b006608:	e037883a 	mov	sp,fp
 b00660c:	df000017 	ldw	fp,0(sp)
 b006610:	dec00104 	addi	sp,sp,4
 b006614:	f800283a 	ret

0b006618 <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 b006618:	defff504 	addi	sp,sp,-44
 b00661c:	dfc00a15 	stw	ra,40(sp)
 b006620:	df000915 	stw	fp,36(sp)
 b006624:	df000904 	addi	fp,sp,36
 b006628:	e13ffc15 	stw	r4,-16(fp)
 b00662c:	e17ffd15 	stw	r5,-12(fp)
 b006630:	e1bffe15 	stw	r6,-8(fp)
 b006634:	e1ffff15 	stw	r7,-4(fp)
  int rc = -EINVAL;  
 b006638:	00bffa84 	movi	r2,-22
 b00663c:	e0bff715 	stw	r2,-36(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
 b006640:	e0bffd17 	ldw	r2,-12(fp)
 b006644:	e0bff815 	stw	r2,-32(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
 b006648:	e0bff817 	ldw	r2,-32(fp)
 b00664c:	10800808 	cmpgei	r2,r2,32
 b006650:	1000271e 	bne	r2,zero,b0066f0 <alt_iic_isr_register+0xd8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 b006654:	0005303a 	rdctl	r2,status
 b006658:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 b00665c:	e0fffb17 	ldw	r3,-20(fp)
 b006660:	00bfff84 	movi	r2,-2
 b006664:	1884703a 	and	r2,r3,r2
 b006668:	1001703a 	wrctl	status,r2
  
  return context;
 b00666c:	e0bffb17 	ldw	r2,-20(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
 b006670:	e0bffa15 	stw	r2,-24(fp)

    alt_irq[id].handler = isr;
 b006674:	0082c074 	movhi	r2,2817
 b006678:	10abbd04 	addi	r2,r2,-20748
 b00667c:	e0fff817 	ldw	r3,-32(fp)
 b006680:	180690fa 	slli	r3,r3,3
 b006684:	10c5883a 	add	r2,r2,r3
 b006688:	e0fffe17 	ldw	r3,-8(fp)
 b00668c:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = isr_context;
 b006690:	0082c074 	movhi	r2,2817
 b006694:	10abbd04 	addi	r2,r2,-20748
 b006698:	e0fff817 	ldw	r3,-32(fp)
 b00669c:	180690fa 	slli	r3,r3,3
 b0066a0:	10c5883a 	add	r2,r2,r3
 b0066a4:	10800104 	addi	r2,r2,4
 b0066a8:	e0ffff17 	ldw	r3,-4(fp)
 b0066ac:	10c00015 	stw	r3,0(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
 b0066b0:	e0bffe17 	ldw	r2,-8(fp)
 b0066b4:	10000526 	beq	r2,zero,b0066cc <alt_iic_isr_register+0xb4>
 b0066b8:	e0bff817 	ldw	r2,-32(fp)
 b0066bc:	100b883a 	mov	r5,r2
 b0066c0:	e13ffc17 	ldw	r4,-16(fp)
 b0066c4:	b0064b80 	call	b0064b8 <alt_ic_irq_enable>
 b0066c8:	00000406 	br	b0066dc <alt_iic_isr_register+0xc4>
 b0066cc:	e0bff817 	ldw	r2,-32(fp)
 b0066d0:	100b883a 	mov	r5,r2
 b0066d4:	e13ffc17 	ldw	r4,-16(fp)
 b0066d8:	b0065400 	call	b006540 <alt_ic_irq_disable>
 b0066dc:	e0bff715 	stw	r2,-36(fp)
 b0066e0:	e0bffa17 	ldw	r2,-24(fp)
 b0066e4:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 b0066e8:	e0bff917 	ldw	r2,-28(fp)
 b0066ec:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
 b0066f0:	e0bff717 	ldw	r2,-36(fp)
}
 b0066f4:	e037883a 	mov	sp,fp
 b0066f8:	dfc00117 	ldw	ra,4(sp)
 b0066fc:	df000017 	ldw	fp,0(sp)
 b006700:	dec00204 	addi	sp,sp,8
 b006704:	f800283a 	ret

0b006708 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
 b006708:	defff804 	addi	sp,sp,-32
 b00670c:	dfc00715 	stw	ra,28(sp)
 b006710:	df000615 	stw	fp,24(sp)
 b006714:	dc000515 	stw	r16,20(sp)
 b006718:	df000604 	addi	fp,sp,24
 b00671c:	e13ffb15 	stw	r4,-20(fp)
 b006720:	e17ffc15 	stw	r5,-16(fp)
 b006724:	e1bffd15 	stw	r6,-12(fp)
 b006728:	e1fffe15 	stw	r7,-8(fp)
  int old;

  old = open (name, flags, mode);
 b00672c:	e1bffe17 	ldw	r6,-8(fp)
 b006730:	e17ffd17 	ldw	r5,-12(fp)
 b006734:	e13ffc17 	ldw	r4,-16(fp)
 b006738:	b0069900 	call	b006990 <open>
 b00673c:	e0bffa15 	stw	r2,-24(fp)

  if (old >= 0)
 b006740:	e0bffa17 	ldw	r2,-24(fp)
 b006744:	10002216 	blt	r2,zero,b0067d0 <alt_open_fd+0xc8>
  {
    fd->dev      = alt_fd_list[old].dev;
 b006748:	0402c034 	movhi	r16,2816
 b00674c:	841fa504 	addi	r16,r16,32404
 b006750:	e0bffa17 	ldw	r2,-24(fp)
 b006754:	01400304 	movi	r5,12
 b006758:	1009883a 	mov	r4,r2
 b00675c:	b0030100 	call	b003010 <__mulsi3>
 b006760:	8085883a 	add	r2,r16,r2
 b006764:	10c00017 	ldw	r3,0(r2)
 b006768:	e0bffb17 	ldw	r2,-20(fp)
 b00676c:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
 b006770:	0402c034 	movhi	r16,2816
 b006774:	841fa504 	addi	r16,r16,32404
 b006778:	e0bffa17 	ldw	r2,-24(fp)
 b00677c:	01400304 	movi	r5,12
 b006780:	1009883a 	mov	r4,r2
 b006784:	b0030100 	call	b003010 <__mulsi3>
 b006788:	8085883a 	add	r2,r16,r2
 b00678c:	10800104 	addi	r2,r2,4
 b006790:	10c00017 	ldw	r3,0(r2)
 b006794:	e0bffb17 	ldw	r2,-20(fp)
 b006798:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
 b00679c:	0402c034 	movhi	r16,2816
 b0067a0:	841fa504 	addi	r16,r16,32404
 b0067a4:	e0bffa17 	ldw	r2,-24(fp)
 b0067a8:	01400304 	movi	r5,12
 b0067ac:	1009883a 	mov	r4,r2
 b0067b0:	b0030100 	call	b003010 <__mulsi3>
 b0067b4:	8085883a 	add	r2,r16,r2
 b0067b8:	10800204 	addi	r2,r2,8
 b0067bc:	10c00017 	ldw	r3,0(r2)
 b0067c0:	e0bffb17 	ldw	r2,-20(fp)
 b0067c4:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
 b0067c8:	e13ffa17 	ldw	r4,-24(fp)
 b0067cc:	b00375c0 	call	b00375c <alt_release_fd>
  }
} 
 b0067d0:	0001883a 	nop
 b0067d4:	e6ffff04 	addi	sp,fp,-4
 b0067d8:	dfc00217 	ldw	ra,8(sp)
 b0067dc:	df000117 	ldw	fp,4(sp)
 b0067e0:	dc000017 	ldw	r16,0(sp)
 b0067e4:	dec00304 	addi	sp,sp,12
 b0067e8:	f800283a 	ret

0b0067ec <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
 b0067ec:	defffb04 	addi	sp,sp,-20
 b0067f0:	dfc00415 	stw	ra,16(sp)
 b0067f4:	df000315 	stw	fp,12(sp)
 b0067f8:	df000304 	addi	fp,sp,12
 b0067fc:	e13ffd15 	stw	r4,-12(fp)
 b006800:	e17ffe15 	stw	r5,-8(fp)
 b006804:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
 b006808:	01c07fc4 	movi	r7,511
 b00680c:	01800044 	movi	r6,1
 b006810:	e17ffd17 	ldw	r5,-12(fp)
 b006814:	0102c034 	movhi	r4,2816
 b006818:	211fa804 	addi	r4,r4,32416
 b00681c:	b0067080 	call	b006708 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
 b006820:	01c07fc4 	movi	r7,511
 b006824:	000d883a 	mov	r6,zero
 b006828:	e17ffe17 	ldw	r5,-8(fp)
 b00682c:	0102c034 	movhi	r4,2816
 b006830:	211fa504 	addi	r4,r4,32404
 b006834:	b0067080 	call	b006708 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
 b006838:	01c07fc4 	movi	r7,511
 b00683c:	01800044 	movi	r6,1
 b006840:	e17fff17 	ldw	r5,-4(fp)
 b006844:	0102c034 	movhi	r4,2816
 b006848:	211fab04 	addi	r4,r4,32428
 b00684c:	b0067080 	call	b006708 <alt_open_fd>
}  
 b006850:	0001883a 	nop
 b006854:	e037883a 	mov	sp,fp
 b006858:	dfc00117 	ldw	ra,4(sp)
 b00685c:	df000017 	ldw	fp,0(sp)
 b006860:	dec00204 	addi	sp,sp,8
 b006864:	f800283a 	ret

0b006868 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 b006868:	defffe04 	addi	sp,sp,-8
 b00686c:	dfc00115 	stw	ra,4(sp)
 b006870:	df000015 	stw	fp,0(sp)
 b006874:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 b006878:	d0a00917 	ldw	r2,-32732(gp)
 b00687c:	10000326 	beq	r2,zero,b00688c <alt_get_errno+0x24>
 b006880:	d0a00917 	ldw	r2,-32732(gp)
 b006884:	103ee83a 	callr	r2
 b006888:	00000106 	br	b006890 <alt_get_errno+0x28>
 b00688c:	d0a71f04 	addi	r2,gp,-25476
}
 b006890:	e037883a 	mov	sp,fp
 b006894:	dfc00117 	ldw	ra,4(sp)
 b006898:	df000017 	ldw	fp,0(sp)
 b00689c:	dec00204 	addi	sp,sp,8
 b0068a0:	f800283a 	ret

0b0068a4 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
 b0068a4:	defffb04 	addi	sp,sp,-20
 b0068a8:	dfc00415 	stw	ra,16(sp)
 b0068ac:	df000315 	stw	fp,12(sp)
 b0068b0:	dc000215 	stw	r16,8(sp)
 b0068b4:	df000304 	addi	fp,sp,12
 b0068b8:	e13ffe15 	stw	r4,-8(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
 b0068bc:	e0bffe17 	ldw	r2,-8(fp)
 b0068c0:	10800217 	ldw	r2,8(r2)
 b0068c4:	10d00034 	orhi	r3,r2,16384
 b0068c8:	e0bffe17 	ldw	r2,-8(fp)
 b0068cc:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 b0068d0:	e03ffd15 	stw	zero,-12(fp)
 b0068d4:	00002306 	br	b006964 <alt_file_locked+0xc0>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
 b0068d8:	0402c034 	movhi	r16,2816
 b0068dc:	841fa504 	addi	r16,r16,32404
 b0068e0:	e0bffd17 	ldw	r2,-12(fp)
 b0068e4:	01400304 	movi	r5,12
 b0068e8:	1009883a 	mov	r4,r2
 b0068ec:	b0030100 	call	b003010 <__mulsi3>
 b0068f0:	8085883a 	add	r2,r16,r2
 b0068f4:	10c00017 	ldw	r3,0(r2)
 b0068f8:	e0bffe17 	ldw	r2,-8(fp)
 b0068fc:	10800017 	ldw	r2,0(r2)
 b006900:	1880151e 	bne	r3,r2,b006958 <alt_file_locked+0xb4>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
 b006904:	0402c034 	movhi	r16,2816
 b006908:	841fa504 	addi	r16,r16,32404
 b00690c:	e0bffd17 	ldw	r2,-12(fp)
 b006910:	01400304 	movi	r5,12
 b006914:	1009883a 	mov	r4,r2
 b006918:	b0030100 	call	b003010 <__mulsi3>
 b00691c:	8085883a 	add	r2,r16,r2
 b006920:	10800204 	addi	r2,r2,8
 b006924:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
 b006928:	10000b0e 	bge	r2,zero,b006958 <alt_file_locked+0xb4>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
 b00692c:	01400304 	movi	r5,12
 b006930:	e13ffd17 	ldw	r4,-12(fp)
 b006934:	b0030100 	call	b003010 <__mulsi3>
 b006938:	1007883a 	mov	r3,r2
 b00693c:	0082c034 	movhi	r2,2816
 b006940:	109fa504 	addi	r2,r2,32404
 b006944:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
 b006948:	e0bffe17 	ldw	r2,-8(fp)
 b00694c:	18800226 	beq	r3,r2,b006958 <alt_file_locked+0xb4>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
 b006950:	00bffcc4 	movi	r2,-13
 b006954:	00000806 	br	b006978 <alt_file_locked+0xd4>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 b006958:	e0bffd17 	ldw	r2,-12(fp)
 b00695c:	10800044 	addi	r2,r2,1
 b006960:	e0bffd15 	stw	r2,-12(fp)
 b006964:	d0a00817 	ldw	r2,-32736(gp)
 b006968:	1007883a 	mov	r3,r2
 b00696c:	e0bffd17 	ldw	r2,-12(fp)
 b006970:	18bfd92e 	bgeu	r3,r2,b0068d8 <__alt_mem_flash+0xff0058d8>
    }
  }
  
  /* The device is not locked */
 
  return 0;
 b006974:	0005883a 	mov	r2,zero
}
 b006978:	e6ffff04 	addi	sp,fp,-4
 b00697c:	dfc00217 	ldw	ra,8(sp)
 b006980:	df000117 	ldw	fp,4(sp)
 b006984:	dc000017 	ldw	r16,0(sp)
 b006988:	dec00304 	addi	sp,sp,12
 b00698c:	f800283a 	ret

0b006990 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
 b006990:	defff604 	addi	sp,sp,-40
 b006994:	dfc00915 	stw	ra,36(sp)
 b006998:	df000815 	stw	fp,32(sp)
 b00699c:	df000804 	addi	fp,sp,32
 b0069a0:	e13ffd15 	stw	r4,-12(fp)
 b0069a4:	e17ffe15 	stw	r5,-8(fp)
 b0069a8:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
 b0069ac:	00bfffc4 	movi	r2,-1
 b0069b0:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
 b0069b4:	00bffb44 	movi	r2,-19
 b0069b8:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
 b0069bc:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
 b0069c0:	d1600604 	addi	r5,gp,-32744
 b0069c4:	e13ffd17 	ldw	r4,-12(fp)
 b0069c8:	b006eb00 	call	b006eb0 <alt_find_dev>
 b0069cc:	e0bff815 	stw	r2,-32(fp)
 b0069d0:	e0bff817 	ldw	r2,-32(fp)
 b0069d4:	1000051e 	bne	r2,zero,b0069ec <open+0x5c>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
 b0069d8:	e13ffd17 	ldw	r4,-12(fp)
 b0069dc:	b006f400 	call	b006f40 <alt_find_file>
 b0069e0:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
 b0069e4:	00800044 	movi	r2,1
 b0069e8:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
 b0069ec:	e0bff817 	ldw	r2,-32(fp)
 b0069f0:	10002b26 	beq	r2,zero,b006aa0 <open+0x110>
  {
    if ((index = alt_get_fd (dev)) < 0)
 b0069f4:	e13ff817 	ldw	r4,-32(fp)
 b0069f8:	b0070480 	call	b007048 <alt_get_fd>
 b0069fc:	e0bff915 	stw	r2,-28(fp)
 b006a00:	e0bff917 	ldw	r2,-28(fp)
 b006a04:	1000030e 	bge	r2,zero,b006a14 <open+0x84>
    {
      status = index;
 b006a08:	e0bff917 	ldw	r2,-28(fp)
 b006a0c:	e0bffa15 	stw	r2,-24(fp)
 b006a10:	00002506 	br	b006aa8 <open+0x118>
    }
    else
    {
      fd = &alt_fd_list[index];
 b006a14:	01400304 	movi	r5,12
 b006a18:	e13ff917 	ldw	r4,-28(fp)
 b006a1c:	b0030100 	call	b003010 <__mulsi3>
 b006a20:	1007883a 	mov	r3,r2
 b006a24:	0082c034 	movhi	r2,2816
 b006a28:	109fa504 	addi	r2,r2,32404
 b006a2c:	1885883a 	add	r2,r3,r2
 b006a30:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
 b006a34:	e0fffe17 	ldw	r3,-8(fp)
 b006a38:	00900034 	movhi	r2,16384
 b006a3c:	10bfffc4 	addi	r2,r2,-1
 b006a40:	1886703a 	and	r3,r3,r2
 b006a44:	e0bffc17 	ldw	r2,-16(fp)
 b006a48:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
 b006a4c:	e0bffb17 	ldw	r2,-20(fp)
 b006a50:	1000051e 	bne	r2,zero,b006a68 <open+0xd8>
 b006a54:	e13ffc17 	ldw	r4,-16(fp)
 b006a58:	b0068a40 	call	b0068a4 <alt_file_locked>
 b006a5c:	e0bffa15 	stw	r2,-24(fp)
 b006a60:	e0bffa17 	ldw	r2,-24(fp)
 b006a64:	10001016 	blt	r2,zero,b006aa8 <open+0x118>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
 b006a68:	e0bff817 	ldw	r2,-32(fp)
 b006a6c:	10800317 	ldw	r2,12(r2)
 b006a70:	10000826 	beq	r2,zero,b006a94 <open+0x104>
 b006a74:	e0bff817 	ldw	r2,-32(fp)
 b006a78:	10800317 	ldw	r2,12(r2)
 b006a7c:	e1ffff17 	ldw	r7,-4(fp)
 b006a80:	e1bffe17 	ldw	r6,-8(fp)
 b006a84:	e17ffd17 	ldw	r5,-12(fp)
 b006a88:	e13ffc17 	ldw	r4,-16(fp)
 b006a8c:	103ee83a 	callr	r2
 b006a90:	00000106 	br	b006a98 <open+0x108>
 b006a94:	0005883a 	mov	r2,zero
 b006a98:	e0bffa15 	stw	r2,-24(fp)
 b006a9c:	00000206 	br	b006aa8 <open+0x118>
      }
    }
  }
  else
  {
    status = -ENODEV;
 b006aa0:	00bffb44 	movi	r2,-19
 b006aa4:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
 b006aa8:	e0bffa17 	ldw	r2,-24(fp)
 b006aac:	1000090e 	bge	r2,zero,b006ad4 <open+0x144>
  {
    alt_release_fd (index);  
 b006ab0:	e13ff917 	ldw	r4,-28(fp)
 b006ab4:	b00375c0 	call	b00375c <alt_release_fd>
    ALT_ERRNO = -status;
 b006ab8:	b0068680 	call	b006868 <alt_get_errno>
 b006abc:	1007883a 	mov	r3,r2
 b006ac0:	e0bffa17 	ldw	r2,-24(fp)
 b006ac4:	0085c83a 	sub	r2,zero,r2
 b006ac8:	18800015 	stw	r2,0(r3)
    return -1;
 b006acc:	00bfffc4 	movi	r2,-1
 b006ad0:	00000106 	br	b006ad8 <open+0x148>
  }
  
  /* return the reference upon success */

  return index;
 b006ad4:	e0bff917 	ldw	r2,-28(fp)
}
 b006ad8:	e037883a 	mov	sp,fp
 b006adc:	dfc00117 	ldw	ra,4(sp)
 b006ae0:	df000017 	ldw	fp,0(sp)
 b006ae4:	dec00204 	addi	sp,sp,8
 b006ae8:	f800283a 	ret

0b006aec <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
 b006aec:	defffa04 	addi	sp,sp,-24
 b006af0:	df000515 	stw	fp,20(sp)
 b006af4:	df000504 	addi	fp,sp,20
 b006af8:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 b006afc:	0005303a 	rdctl	r2,status
 b006b00:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 b006b04:	e0fffc17 	ldw	r3,-16(fp)
 b006b08:	00bfff84 	movi	r2,-2
 b006b0c:	1884703a 	and	r2,r3,r2
 b006b10:	1001703a 	wrctl	status,r2
  
  return context;
 b006b14:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
 b006b18:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
 b006b1c:	e0bfff17 	ldw	r2,-4(fp)
 b006b20:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
 b006b24:	e0bffd17 	ldw	r2,-12(fp)
 b006b28:	10800017 	ldw	r2,0(r2)
 b006b2c:	e0fffd17 	ldw	r3,-12(fp)
 b006b30:	18c00117 	ldw	r3,4(r3)
 b006b34:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
 b006b38:	e0bffd17 	ldw	r2,-12(fp)
 b006b3c:	10800117 	ldw	r2,4(r2)
 b006b40:	e0fffd17 	ldw	r3,-12(fp)
 b006b44:	18c00017 	ldw	r3,0(r3)
 b006b48:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
 b006b4c:	e0bffd17 	ldw	r2,-12(fp)
 b006b50:	e0fffd17 	ldw	r3,-12(fp)
 b006b54:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
 b006b58:	e0bffd17 	ldw	r2,-12(fp)
 b006b5c:	e0fffd17 	ldw	r3,-12(fp)
 b006b60:	10c00015 	stw	r3,0(r2)
 b006b64:	e0bffb17 	ldw	r2,-20(fp)
 b006b68:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 b006b6c:	e0bffe17 	ldw	r2,-8(fp)
 b006b70:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
 b006b74:	0001883a 	nop
 b006b78:	e037883a 	mov	sp,fp
 b006b7c:	df000017 	ldw	fp,0(sp)
 b006b80:	dec00104 	addi	sp,sp,4
 b006b84:	f800283a 	ret

0b006b88 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
 b006b88:	defffb04 	addi	sp,sp,-20
 b006b8c:	dfc00415 	stw	ra,16(sp)
 b006b90:	df000315 	stw	fp,12(sp)
 b006b94:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
 b006b98:	d0a00e17 	ldw	r2,-32712(gp)
 b006b9c:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
 b006ba0:	d0a72517 	ldw	r2,-25452(gp)
 b006ba4:	10800044 	addi	r2,r2,1
 b006ba8:	d0a72515 	stw	r2,-25452(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 b006bac:	00002e06 	br	b006c68 <alt_tick+0xe0>
  {
    next = (alt_alarm*) alarm->llist.next;
 b006bb0:	e0bffd17 	ldw	r2,-12(fp)
 b006bb4:	10800017 	ldw	r2,0(r2)
 b006bb8:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
 b006bbc:	e0bffd17 	ldw	r2,-12(fp)
 b006bc0:	10800403 	ldbu	r2,16(r2)
 b006bc4:	10803fcc 	andi	r2,r2,255
 b006bc8:	10000426 	beq	r2,zero,b006bdc <alt_tick+0x54>
 b006bcc:	d0a72517 	ldw	r2,-25452(gp)
 b006bd0:	1000021e 	bne	r2,zero,b006bdc <alt_tick+0x54>
    {
      alarm->rollover = 0;
 b006bd4:	e0bffd17 	ldw	r2,-12(fp)
 b006bd8:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
 b006bdc:	e0bffd17 	ldw	r2,-12(fp)
 b006be0:	10800217 	ldw	r2,8(r2)
 b006be4:	d0e72517 	ldw	r3,-25452(gp)
 b006be8:	18801d36 	bltu	r3,r2,b006c60 <alt_tick+0xd8>
 b006bec:	e0bffd17 	ldw	r2,-12(fp)
 b006bf0:	10800403 	ldbu	r2,16(r2)
 b006bf4:	10803fcc 	andi	r2,r2,255
 b006bf8:	1000191e 	bne	r2,zero,b006c60 <alt_tick+0xd8>
    {
      next_callback = alarm->callback (alarm->context);
 b006bfc:	e0bffd17 	ldw	r2,-12(fp)
 b006c00:	10800317 	ldw	r2,12(r2)
 b006c04:	e0fffd17 	ldw	r3,-12(fp)
 b006c08:	18c00517 	ldw	r3,20(r3)
 b006c0c:	1809883a 	mov	r4,r3
 b006c10:	103ee83a 	callr	r2
 b006c14:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
 b006c18:	e0bfff17 	ldw	r2,-4(fp)
 b006c1c:	1000031e 	bne	r2,zero,b006c2c <alt_tick+0xa4>
      {
        alt_alarm_stop (alarm);
 b006c20:	e13ffd17 	ldw	r4,-12(fp)
 b006c24:	b006aec0 	call	b006aec <alt_alarm_stop>
 b006c28:	00000d06 	br	b006c60 <alt_tick+0xd8>
      }
      else
      {
        alarm->time += next_callback;
 b006c2c:	e0bffd17 	ldw	r2,-12(fp)
 b006c30:	10c00217 	ldw	r3,8(r2)
 b006c34:	e0bfff17 	ldw	r2,-4(fp)
 b006c38:	1887883a 	add	r3,r3,r2
 b006c3c:	e0bffd17 	ldw	r2,-12(fp)
 b006c40:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
 b006c44:	e0bffd17 	ldw	r2,-12(fp)
 b006c48:	10c00217 	ldw	r3,8(r2)
 b006c4c:	d0a72517 	ldw	r2,-25452(gp)
 b006c50:	1880032e 	bgeu	r3,r2,b006c60 <alt_tick+0xd8>
        {
          alarm->rollover = 1;
 b006c54:	e0bffd17 	ldw	r2,-12(fp)
 b006c58:	00c00044 	movi	r3,1
 b006c5c:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
 b006c60:	e0bffe17 	ldw	r2,-8(fp)
 b006c64:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 b006c68:	e0fffd17 	ldw	r3,-12(fp)
 b006c6c:	d0a00e04 	addi	r2,gp,-32712
 b006c70:	18bfcf1e 	bne	r3,r2,b006bb0 <__alt_mem_flash+0xff005bb0>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
 b006c74:	0001883a 	nop
}
 b006c78:	0001883a 	nop
 b006c7c:	e037883a 	mov	sp,fp
 b006c80:	dfc00117 	ldw	ra,4(sp)
 b006c84:	df000017 	ldw	fp,0(sp)
 b006c88:	dec00204 	addi	sp,sp,8
 b006c8c:	f800283a 	ret

0b006c90 <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
 b006c90:	deffff04 	addi	sp,sp,-4
 b006c94:	df000015 	stw	fp,0(sp)
 b006c98:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
 b006c9c:	000170fa 	wrctl	ienable,zero
}
 b006ca0:	0001883a 	nop
 b006ca4:	e037883a 	mov	sp,fp
 b006ca8:	df000017 	ldw	fp,0(sp)
 b006cac:	dec00104 	addi	sp,sp,4
 b006cb0:	f800283a 	ret

0b006cb4 <alt_avalon_spi_command>:

int alt_avalon_spi_command(alt_u32 base, alt_u32 slave,
                           alt_u32 write_length, const alt_u8 * write_data,
                           alt_u32 read_length, alt_u8 * read_data,
                           alt_u32 flags)
{
 b006cb4:	defff404 	addi	sp,sp,-48
 b006cb8:	df000b15 	stw	fp,44(sp)
 b006cbc:	df000b04 	addi	fp,sp,44
 b006cc0:	e13ffc15 	stw	r4,-16(fp)
 b006cc4:	e17ffd15 	stw	r5,-12(fp)
 b006cc8:	e1bffe15 	stw	r6,-8(fp)
 b006ccc:	e1ffff15 	stw	r7,-4(fp)
  const alt_u8 * write_end = write_data + write_length;
 b006cd0:	e0ffff17 	ldw	r3,-4(fp)
 b006cd4:	e0bffe17 	ldw	r2,-8(fp)
 b006cd8:	1885883a 	add	r2,r3,r2
 b006cdc:	e0bff815 	stw	r2,-32(fp)
  alt_u8 * read_end = read_data + read_length;
 b006ce0:	e0c00217 	ldw	r3,8(fp)
 b006ce4:	e0800117 	ldw	r2,4(fp)
 b006ce8:	1885883a 	add	r2,r3,r2
 b006cec:	e0bff915 	stw	r2,-28(fp)

  alt_u32 write_zeros = read_length;
 b006cf0:	e0800117 	ldw	r2,4(fp)
 b006cf4:	e0bff515 	stw	r2,-44(fp)
  alt_u32 read_ignore = write_length;
 b006cf8:	e0bffe17 	ldw	r2,-8(fp)
 b006cfc:	e0bff615 	stw	r2,-40(fp)

  /* We must not send more than two bytes to the target before it has
   * returned any as otherwise it will overflow. */
  /* Unfortunately the hardware does not seem to work with credits > 1,
   * leave it at 1 for now. */
  alt_32 credits = 1;
 b006d00:	00800044 	movi	r2,1
 b006d04:	e0bff715 	stw	r2,-36(fp)
  /* Warning: this function is not currently safe if called in a multi-threaded
   * environment, something above must perform locking to make it safe if more
   * than one thread intends to use it.
   */

  IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(base, 1 << slave);
 b006d08:	e0bffc17 	ldw	r2,-16(fp)
 b006d0c:	10800504 	addi	r2,r2,20
 b006d10:	1009883a 	mov	r4,r2
 b006d14:	00c00044 	movi	r3,1
 b006d18:	e0bffd17 	ldw	r2,-12(fp)
 b006d1c:	1884983a 	sll	r2,r3,r2
 b006d20:	20800035 	stwio	r2,0(r4)
  
  /* Set the SSO bit (force chipselect) only if the toggle flag is not set */
  if ((flags & ALT_AVALON_SPI_COMMAND_TOGGLE_SS_N) == 0) {
 b006d24:	e0800317 	ldw	r2,12(fp)
 b006d28:	1080008c 	andi	r2,r2,2
 b006d2c:	1000051e 	bne	r2,zero,b006d44 <alt_avalon_spi_command+0x90>
    IOWR_ALTERA_AVALON_SPI_CONTROL(base, ALTERA_AVALON_SPI_CONTROL_SSO_MSK);
 b006d30:	e0bffc17 	ldw	r2,-16(fp)
 b006d34:	10800304 	addi	r2,r2,12
 b006d38:	1007883a 	mov	r3,r2
 b006d3c:	00810004 	movi	r2,1024
 b006d40:	18800035 	stwio	r2,0(r3)
  /*
   * Discard any stale data present in the RXDATA register, in case
   * previous communication was interrupted and stale data was left
   * behind.
   */
  IORD_ALTERA_AVALON_SPI_RXDATA(base);
 b006d44:	e0bffc17 	ldw	r2,-16(fp)
 b006d48:	10800037 	ldwio	r2,0(r2)
  for ( ; ; )
  {
    
    do
    {
      status = IORD_ALTERA_AVALON_SPI_STATUS(base);
 b006d4c:	e0bffc17 	ldw	r2,-16(fp)
 b006d50:	10800204 	addi	r2,r2,8
 b006d54:	10800037 	ldwio	r2,0(r2)
 b006d58:	e0bffa15 	stw	r2,-24(fp)
    }
    while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
 b006d5c:	e0bffa17 	ldw	r2,-24(fp)
 b006d60:	1080100c 	andi	r2,r2,64
            (status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) == 0);
 b006d64:	10000226 	beq	r2,zero,b006d70 <alt_avalon_spi_command+0xbc>
    
    do
    {
      status = IORD_ALTERA_AVALON_SPI_STATUS(base);
    }
    while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
 b006d68:	e0bff717 	ldw	r2,-36(fp)
 b006d6c:	1000031e 	bne	r2,zero,b006d7c <alt_avalon_spi_command+0xc8>
            (status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) == 0);
 b006d70:	e0bffa17 	ldw	r2,-24(fp)
 b006d74:	1080200c 	andi	r2,r2,128
    
    do
    {
      status = IORD_ALTERA_AVALON_SPI_STATUS(base);
    }
    while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
 b006d78:	103ff426 	beq	r2,zero,b006d4c <__alt_mem_flash+0xff005d4c>
            (status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) == 0);

    if ((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) != 0 && credits > 0)
 b006d7c:	e0bffa17 	ldw	r2,-24(fp)
 b006d80:	1080100c 	andi	r2,r2,64
 b006d84:	10001e26 	beq	r2,zero,b006e00 <alt_avalon_spi_command+0x14c>
 b006d88:	e0bff717 	ldw	r2,-36(fp)
 b006d8c:	00801c0e 	bge	zero,r2,b006e00 <alt_avalon_spi_command+0x14c>
    {
      credits--;
 b006d90:	e0bff717 	ldw	r2,-36(fp)
 b006d94:	10bfffc4 	addi	r2,r2,-1
 b006d98:	e0bff715 	stw	r2,-36(fp)

      if (write_data < write_end)
 b006d9c:	e0ffff17 	ldw	r3,-4(fp)
 b006da0:	e0bff817 	ldw	r2,-32(fp)
 b006da4:	18800a2e 	bgeu	r3,r2,b006dd0 <alt_avalon_spi_command+0x11c>
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, *write_data++);
 b006da8:	e0bffc17 	ldw	r2,-16(fp)
 b006dac:	10800104 	addi	r2,r2,4
 b006db0:	1009883a 	mov	r4,r2
 b006db4:	e0bfff17 	ldw	r2,-4(fp)
 b006db8:	10c00044 	addi	r3,r2,1
 b006dbc:	e0ffff15 	stw	r3,-4(fp)
 b006dc0:	10800003 	ldbu	r2,0(r2)
 b006dc4:	10803fcc 	andi	r2,r2,255
 b006dc8:	20800035 	stwio	r2,0(r4)
 b006dcc:	00000c06 	br	b006e00 <alt_avalon_spi_command+0x14c>
      else if (write_zeros > 0)
 b006dd0:	e0bff517 	ldw	r2,-44(fp)
 b006dd4:	10000826 	beq	r2,zero,b006df8 <alt_avalon_spi_command+0x144>
      {
        write_zeros--;
 b006dd8:	e0bff517 	ldw	r2,-44(fp)
 b006ddc:	10bfffc4 	addi	r2,r2,-1
 b006de0:	e0bff515 	stw	r2,-44(fp)
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, 0);
 b006de4:	e0bffc17 	ldw	r2,-16(fp)
 b006de8:	10800104 	addi	r2,r2,4
 b006dec:	0007883a 	mov	r3,zero
 b006df0:	10c00035 	stwio	r3,0(r2)
 b006df4:	00000206 	br	b006e00 <alt_avalon_spi_command+0x14c>
      }
      else
        credits = -1024;
 b006df8:	00bf0004 	movi	r2,-1024
 b006dfc:	e0bff715 	stw	r2,-36(fp)
    };

    if ((status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) != 0)
 b006e00:	e0bffa17 	ldw	r2,-24(fp)
 b006e04:	1080200c 	andi	r2,r2,128
 b006e08:	103fd026 	beq	r2,zero,b006d4c <__alt_mem_flash+0xff005d4c>
    {
      alt_u32 rxdata = IORD_ALTERA_AVALON_SPI_RXDATA(base);
 b006e0c:	e0bffc17 	ldw	r2,-16(fp)
 b006e10:	10800037 	ldwio	r2,0(r2)
 b006e14:	e0bffb15 	stw	r2,-20(fp)

      if (read_ignore > 0)
 b006e18:	e0bff617 	ldw	r2,-40(fp)
 b006e1c:	10000426 	beq	r2,zero,b006e30 <alt_avalon_spi_command+0x17c>
        read_ignore--;
 b006e20:	e0bff617 	ldw	r2,-40(fp)
 b006e24:	10bfffc4 	addi	r2,r2,-1
 b006e28:	e0bff615 	stw	r2,-40(fp)
 b006e2c:	00000506 	br	b006e44 <alt_avalon_spi_command+0x190>
      else
        *read_data++ = (alt_u8)rxdata;
 b006e30:	e0800217 	ldw	r2,8(fp)
 b006e34:	10c00044 	addi	r3,r2,1
 b006e38:	e0c00215 	stw	r3,8(fp)
 b006e3c:	e0fffb17 	ldw	r3,-20(fp)
 b006e40:	10c00005 	stb	r3,0(r2)
      credits++;
 b006e44:	e0bff717 	ldw	r2,-36(fp)
 b006e48:	10800044 	addi	r2,r2,1
 b006e4c:	e0bff715 	stw	r2,-36(fp)

      if (read_ignore == 0 && read_data == read_end)
 b006e50:	e0bff617 	ldw	r2,-40(fp)
 b006e54:	103fbd1e 	bne	r2,zero,b006d4c <__alt_mem_flash+0xff005d4c>
 b006e58:	e0c00217 	ldw	r3,8(fp)
 b006e5c:	e0bff917 	ldw	r2,-28(fp)
 b006e60:	18bfba1e 	bne	r3,r2,b006d4c <__alt_mem_flash+0xff005d4c>
  }

  /* Wait until the interface has finished transmitting */
  do
  {
    status = IORD_ALTERA_AVALON_SPI_STATUS(base);
 b006e64:	e0bffc17 	ldw	r2,-16(fp)
 b006e68:	10800204 	addi	r2,r2,8
 b006e6c:	10800037 	ldwio	r2,0(r2)
 b006e70:	e0bffa15 	stw	r2,-24(fp)
  }
  while ((status & ALTERA_AVALON_SPI_STATUS_TMT_MSK) == 0);
 b006e74:	e0bffa17 	ldw	r2,-24(fp)
 b006e78:	1080080c 	andi	r2,r2,32
 b006e7c:	103ff926 	beq	r2,zero,b006e64 <__alt_mem_flash+0xff005e64>

  /* Clear SSO (release chipselect) unless the caller is going to
   * keep using this chip
   */
  if ((flags & ALT_AVALON_SPI_COMMAND_MERGE) == 0)
 b006e80:	e0800317 	ldw	r2,12(fp)
 b006e84:	1080004c 	andi	r2,r2,1
 b006e88:	1000041e 	bne	r2,zero,b006e9c <alt_avalon_spi_command+0x1e8>
    IOWR_ALTERA_AVALON_SPI_CONTROL(base, 0);
 b006e8c:	e0bffc17 	ldw	r2,-16(fp)
 b006e90:	10800304 	addi	r2,r2,12
 b006e94:	0007883a 	mov	r3,zero
 b006e98:	10c00035 	stwio	r3,0(r2)

  return read_length;
 b006e9c:	e0800117 	ldw	r2,4(fp)
}
 b006ea0:	e037883a 	mov	sp,fp
 b006ea4:	df000017 	ldw	fp,0(sp)
 b006ea8:	dec00104 	addi	sp,sp,4
 b006eac:	f800283a 	ret

0b006eb0 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
 b006eb0:	defffa04 	addi	sp,sp,-24
 b006eb4:	dfc00515 	stw	ra,20(sp)
 b006eb8:	df000415 	stw	fp,16(sp)
 b006ebc:	df000404 	addi	fp,sp,16
 b006ec0:	e13ffe15 	stw	r4,-8(fp)
 b006ec4:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
 b006ec8:	e0bfff17 	ldw	r2,-4(fp)
 b006ecc:	10800017 	ldw	r2,0(r2)
 b006ed0:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
 b006ed4:	e13ffe17 	ldw	r4,-8(fp)
 b006ed8:	b0072700 	call	b007270 <strlen>
 b006edc:	10800044 	addi	r2,r2,1
 b006ee0:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 b006ee4:	00000d06 	br	b006f1c <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
 b006ee8:	e0bffc17 	ldw	r2,-16(fp)
 b006eec:	10800217 	ldw	r2,8(r2)
 b006ef0:	e0fffd17 	ldw	r3,-12(fp)
 b006ef4:	180d883a 	mov	r6,r3
 b006ef8:	e17ffe17 	ldw	r5,-8(fp)
 b006efc:	1009883a 	mov	r4,r2
 b006f00:	b0071f40 	call	b0071f4 <memcmp>
 b006f04:	1000021e 	bne	r2,zero,b006f10 <alt_find_dev+0x60>
    {
      /* match found */

      return next;
 b006f08:	e0bffc17 	ldw	r2,-16(fp)
 b006f0c:	00000706 	br	b006f2c <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
 b006f10:	e0bffc17 	ldw	r2,-16(fp)
 b006f14:	10800017 	ldw	r2,0(r2)
 b006f18:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 b006f1c:	e0fffc17 	ldw	r3,-16(fp)
 b006f20:	e0bfff17 	ldw	r2,-4(fp)
 b006f24:	18bff01e 	bne	r3,r2,b006ee8 <__alt_mem_flash+0xff005ee8>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
 b006f28:	0005883a 	mov	r2,zero
}
 b006f2c:	e037883a 	mov	sp,fp
 b006f30:	dfc00117 	ldw	ra,4(sp)
 b006f34:	df000017 	ldw	fp,0(sp)
 b006f38:	dec00204 	addi	sp,sp,8
 b006f3c:	f800283a 	ret

0b006f40 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
 b006f40:	defffb04 	addi	sp,sp,-20
 b006f44:	dfc00415 	stw	ra,16(sp)
 b006f48:	df000315 	stw	fp,12(sp)
 b006f4c:	df000304 	addi	fp,sp,12
 b006f50:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
 b006f54:	d0a00417 	ldw	r2,-32752(gp)
 b006f58:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 b006f5c:	00003106 	br	b007024 <alt_find_file+0xe4>
  {
    len = strlen(next->name);
 b006f60:	e0bffd17 	ldw	r2,-12(fp)
 b006f64:	10800217 	ldw	r2,8(r2)
 b006f68:	1009883a 	mov	r4,r2
 b006f6c:	b0072700 	call	b007270 <strlen>
 b006f70:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
 b006f74:	e0bffd17 	ldw	r2,-12(fp)
 b006f78:	10c00217 	ldw	r3,8(r2)
 b006f7c:	e0bffe17 	ldw	r2,-8(fp)
 b006f80:	10bfffc4 	addi	r2,r2,-1
 b006f84:	1885883a 	add	r2,r3,r2
 b006f88:	10800003 	ldbu	r2,0(r2)
 b006f8c:	10803fcc 	andi	r2,r2,255
 b006f90:	1080201c 	xori	r2,r2,128
 b006f94:	10bfe004 	addi	r2,r2,-128
 b006f98:	10800bd8 	cmpnei	r2,r2,47
 b006f9c:	1000031e 	bne	r2,zero,b006fac <alt_find_file+0x6c>
    {
      len -= 1;
 b006fa0:	e0bffe17 	ldw	r2,-8(fp)
 b006fa4:	10bfffc4 	addi	r2,r2,-1
 b006fa8:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
 b006fac:	e0bffe17 	ldw	r2,-8(fp)
 b006fb0:	e0ffff17 	ldw	r3,-4(fp)
 b006fb4:	1885883a 	add	r2,r3,r2
 b006fb8:	10800003 	ldbu	r2,0(r2)
 b006fbc:	10803fcc 	andi	r2,r2,255
 b006fc0:	1080201c 	xori	r2,r2,128
 b006fc4:	10bfe004 	addi	r2,r2,-128
 b006fc8:	10800be0 	cmpeqi	r2,r2,47
 b006fcc:	1000081e 	bne	r2,zero,b006ff0 <alt_find_file+0xb0>
 b006fd0:	e0bffe17 	ldw	r2,-8(fp)
 b006fd4:	e0ffff17 	ldw	r3,-4(fp)
 b006fd8:	1885883a 	add	r2,r3,r2
 b006fdc:	10800003 	ldbu	r2,0(r2)
 b006fe0:	10803fcc 	andi	r2,r2,255
 b006fe4:	1080201c 	xori	r2,r2,128
 b006fe8:	10bfe004 	addi	r2,r2,-128
 b006fec:	10000a1e 	bne	r2,zero,b007018 <alt_find_file+0xd8>
        !memcmp (next->name, name, len))
 b006ff0:	e0bffd17 	ldw	r2,-12(fp)
 b006ff4:	10800217 	ldw	r2,8(r2)
 b006ff8:	e0fffe17 	ldw	r3,-8(fp)
 b006ffc:	180d883a 	mov	r6,r3
 b007000:	e17fff17 	ldw	r5,-4(fp)
 b007004:	1009883a 	mov	r4,r2
 b007008:	b0071f40 	call	b0071f4 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
 b00700c:	1000021e 	bne	r2,zero,b007018 <alt_find_file+0xd8>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
 b007010:	e0bffd17 	ldw	r2,-12(fp)
 b007014:	00000706 	br	b007034 <alt_find_file+0xf4>
    }
    next = (alt_dev*) next->llist.next;
 b007018:	e0bffd17 	ldw	r2,-12(fp)
 b00701c:	10800017 	ldw	r2,0(r2)
 b007020:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 b007024:	e0fffd17 	ldw	r3,-12(fp)
 b007028:	d0a00404 	addi	r2,gp,-32752
 b00702c:	18bfcc1e 	bne	r3,r2,b006f60 <__alt_mem_flash+0xff005f60>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
 b007030:	0005883a 	mov	r2,zero
}
 b007034:	e037883a 	mov	sp,fp
 b007038:	dfc00117 	ldw	ra,4(sp)
 b00703c:	df000017 	ldw	fp,0(sp)
 b007040:	dec00204 	addi	sp,sp,8
 b007044:	f800283a 	ret

0b007048 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
 b007048:	defffa04 	addi	sp,sp,-24
 b00704c:	dfc00515 	stw	ra,20(sp)
 b007050:	df000415 	stw	fp,16(sp)
 b007054:	dc000315 	stw	r16,12(sp)
 b007058:	df000404 	addi	fp,sp,16
 b00705c:	e13ffe15 	stw	r4,-8(fp)
  alt_32 i;
  int rc = -EMFILE;
 b007060:	00bffa04 	movi	r2,-24
 b007064:	e0bffd15 	stw	r2,-12(fp)
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 b007068:	e03ffc15 	stw	zero,-16(fp)
 b00706c:	00001d06 	br	b0070e4 <alt_get_fd+0x9c>
  {
    if (!alt_fd_list[i].dev)
 b007070:	0402c034 	movhi	r16,2816
 b007074:	841fa504 	addi	r16,r16,32404
 b007078:	e0bffc17 	ldw	r2,-16(fp)
 b00707c:	01400304 	movi	r5,12
 b007080:	1009883a 	mov	r4,r2
 b007084:	b0030100 	call	b003010 <__mulsi3>
 b007088:	8085883a 	add	r2,r16,r2
 b00708c:	10800017 	ldw	r2,0(r2)
 b007090:	1000111e 	bne	r2,zero,b0070d8 <alt_get_fd+0x90>
    {
      alt_fd_list[i].dev = dev;
 b007094:	0402c034 	movhi	r16,2816
 b007098:	841fa504 	addi	r16,r16,32404
 b00709c:	e0bffc17 	ldw	r2,-16(fp)
 b0070a0:	01400304 	movi	r5,12
 b0070a4:	1009883a 	mov	r4,r2
 b0070a8:	b0030100 	call	b003010 <__mulsi3>
 b0070ac:	8085883a 	add	r2,r16,r2
 b0070b0:	e0fffe17 	ldw	r3,-8(fp)
 b0070b4:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
 b0070b8:	d0e00817 	ldw	r3,-32736(gp)
 b0070bc:	e0bffc17 	ldw	r2,-16(fp)
 b0070c0:	1880020e 	bge	r3,r2,b0070cc <alt_get_fd+0x84>
      {
        alt_max_fd = i;
 b0070c4:	e0bffc17 	ldw	r2,-16(fp)
 b0070c8:	d0a00815 	stw	r2,-32736(gp)
      }
      rc = i;
 b0070cc:	e0bffc17 	ldw	r2,-16(fp)
 b0070d0:	e0bffd15 	stw	r2,-12(fp)
      goto alt_get_fd_exit;
 b0070d4:	00000606 	br	b0070f0 <alt_get_fd+0xa8>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 b0070d8:	e0bffc17 	ldw	r2,-16(fp)
 b0070dc:	10800044 	addi	r2,r2,1
 b0070e0:	e0bffc15 	stw	r2,-16(fp)
 b0070e4:	e0bffc17 	ldw	r2,-16(fp)
 b0070e8:	10800810 	cmplti	r2,r2,32
 b0070ec:	103fe01e 	bne	r2,zero,b007070 <__alt_mem_flash+0xff006070>
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);

  return rc;
 b0070f0:	e0bffd17 	ldw	r2,-12(fp)
}
 b0070f4:	e6ffff04 	addi	sp,fp,-4
 b0070f8:	dfc00217 	ldw	ra,8(sp)
 b0070fc:	df000117 	ldw	fp,4(sp)
 b007100:	dc000017 	ldw	r16,0(sp)
 b007104:	dec00304 	addi	sp,sp,12
 b007108:	f800283a 	ret

0b00710c <alt_exception_cause_generated_bad_addr>:
 * Return: 1: BADADDR (bad_addr argument to handler) is valid
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
 b00710c:	defffe04 	addi	sp,sp,-8
 b007110:	df000115 	stw	fp,4(sp)
 b007114:	df000104 	addi	fp,sp,4
 b007118:	e13fff15 	stw	r4,-4(fp)
  switch (cause) {
 b00711c:	e0bfff17 	ldw	r2,-4(fp)
 b007120:	10bffe84 	addi	r2,r2,-6
 b007124:	10c00428 	cmpgeui	r3,r2,16
 b007128:	18001a1e 	bne	r3,zero,b007194 <alt_exception_cause_generated_bad_addr+0x88>
 b00712c:	100690ba 	slli	r3,r2,2
 b007130:	0082c034 	movhi	r2,2816
 b007134:	109c5104 	addi	r2,r2,28996
 b007138:	1885883a 	add	r2,r3,r2
 b00713c:	10800017 	ldw	r2,0(r2)
 b007140:	1000683a 	jmp	r2
 b007144:	0b007184 	addi	r12,at,454
 b007148:	0b007184 	addi	r12,at,454
 b00714c:	0b007194 	ori	r12,at,454
 b007150:	0b007194 	ori	r12,at,454
 b007154:	0b007194 	ori	r12,at,454
 b007158:	0b007184 	addi	r12,at,454
 b00715c:	0b00718c 	andi	r12,at,454
 b007160:	0b007194 	ori	r12,at,454
 b007164:	0b007184 	addi	r12,at,454
 b007168:	0b007184 	addi	r12,at,454
 b00716c:	0b007194 	ori	r12,at,454
 b007170:	0b007184 	addi	r12,at,454
 b007174:	0b00718c 	andi	r12,at,454
 b007178:	0b007194 	ori	r12,at,454
 b00717c:	0b007194 	ori	r12,at,454
 b007180:	0b007184 	addi	r12,at,454
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
 b007184:	00800044 	movi	r2,1
 b007188:	00000306 	br	b007198 <alt_exception_cause_generated_bad_addr+0x8c>

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
 b00718c:	0005883a 	mov	r2,zero
 b007190:	00000106 	br	b007198 <alt_exception_cause_generated_bad_addr+0x8c>

  default:
    return 0;
 b007194:	0005883a 	mov	r2,zero
  }
}
 b007198:	e037883a 	mov	sp,fp
 b00719c:	df000017 	ldw	fp,0(sp)
 b0071a0:	dec00104 	addi	sp,sp,4
 b0071a4:	f800283a 	ret

0b0071a8 <atexit>:
 b0071a8:	200b883a 	mov	r5,r4
 b0071ac:	000f883a 	mov	r7,zero
 b0071b0:	000d883a 	mov	r6,zero
 b0071b4:	0009883a 	mov	r4,zero
 b0071b8:	b0073081 	jmpi	b007308 <__register_exitproc>

0b0071bc <exit>:
 b0071bc:	defffe04 	addi	sp,sp,-8
 b0071c0:	000b883a 	mov	r5,zero
 b0071c4:	dc000015 	stw	r16,0(sp)
 b0071c8:	dfc00115 	stw	ra,4(sp)
 b0071cc:	2021883a 	mov	r16,r4
 b0071d0:	b0074200 	call	b007420 <__call_exitprocs>
 b0071d4:	0082c074 	movhi	r2,2817
 b0071d8:	10a48c04 	addi	r2,r2,-28112
 b0071dc:	11000017 	ldw	r4,0(r2)
 b0071e0:	20800f17 	ldw	r2,60(r4)
 b0071e4:	10000126 	beq	r2,zero,b0071ec <exit+0x30>
 b0071e8:	103ee83a 	callr	r2
 b0071ec:	8009883a 	mov	r4,r16
 b0071f0:	b0075a00 	call	b0075a0 <_exit>

0b0071f4 <memcmp>:
 b0071f4:	01c000c4 	movi	r7,3
 b0071f8:	3980192e 	bgeu	r7,r6,b007260 <memcmp+0x6c>
 b0071fc:	2144b03a 	or	r2,r4,r5
 b007200:	11c4703a 	and	r2,r2,r7
 b007204:	10000f26 	beq	r2,zero,b007244 <memcmp+0x50>
 b007208:	20800003 	ldbu	r2,0(r4)
 b00720c:	28c00003 	ldbu	r3,0(r5)
 b007210:	10c0151e 	bne	r2,r3,b007268 <memcmp+0x74>
 b007214:	31bfff84 	addi	r6,r6,-2
 b007218:	01ffffc4 	movi	r7,-1
 b00721c:	00000406 	br	b007230 <memcmp+0x3c>
 b007220:	20800003 	ldbu	r2,0(r4)
 b007224:	28c00003 	ldbu	r3,0(r5)
 b007228:	31bfffc4 	addi	r6,r6,-1
 b00722c:	10c00e1e 	bne	r2,r3,b007268 <memcmp+0x74>
 b007230:	21000044 	addi	r4,r4,1
 b007234:	29400044 	addi	r5,r5,1
 b007238:	31fff91e 	bne	r6,r7,b007220 <__alt_mem_flash+0xff006220>
 b00723c:	0005883a 	mov	r2,zero
 b007240:	f800283a 	ret
 b007244:	20c00017 	ldw	r3,0(r4)
 b007248:	28800017 	ldw	r2,0(r5)
 b00724c:	18bfee1e 	bne	r3,r2,b007208 <__alt_mem_flash+0xff006208>
 b007250:	31bfff04 	addi	r6,r6,-4
 b007254:	21000104 	addi	r4,r4,4
 b007258:	29400104 	addi	r5,r5,4
 b00725c:	39bff936 	bltu	r7,r6,b007244 <__alt_mem_flash+0xff006244>
 b007260:	303fe91e 	bne	r6,zero,b007208 <__alt_mem_flash+0xff006208>
 b007264:	003ff506 	br	b00723c <__alt_mem_flash+0xff00623c>
 b007268:	10c5c83a 	sub	r2,r2,r3
 b00726c:	f800283a 	ret

0b007270 <strlen>:
 b007270:	208000cc 	andi	r2,r4,3
 b007274:	10002026 	beq	r2,zero,b0072f8 <strlen+0x88>
 b007278:	20800007 	ldb	r2,0(r4)
 b00727c:	10002026 	beq	r2,zero,b007300 <strlen+0x90>
 b007280:	2005883a 	mov	r2,r4
 b007284:	00000206 	br	b007290 <strlen+0x20>
 b007288:	10c00007 	ldb	r3,0(r2)
 b00728c:	18001826 	beq	r3,zero,b0072f0 <strlen+0x80>
 b007290:	10800044 	addi	r2,r2,1
 b007294:	10c000cc 	andi	r3,r2,3
 b007298:	183ffb1e 	bne	r3,zero,b007288 <__alt_mem_flash+0xff006288>
 b00729c:	10c00017 	ldw	r3,0(r2)
 b0072a0:	01ffbff4 	movhi	r7,65279
 b0072a4:	39ffbfc4 	addi	r7,r7,-257
 b0072a8:	00ca303a 	nor	r5,zero,r3
 b0072ac:	01a02074 	movhi	r6,32897
 b0072b0:	19c7883a 	add	r3,r3,r7
 b0072b4:	31a02004 	addi	r6,r6,-32640
 b0072b8:	1946703a 	and	r3,r3,r5
 b0072bc:	1986703a 	and	r3,r3,r6
 b0072c0:	1800091e 	bne	r3,zero,b0072e8 <strlen+0x78>
 b0072c4:	10800104 	addi	r2,r2,4
 b0072c8:	10c00017 	ldw	r3,0(r2)
 b0072cc:	19cb883a 	add	r5,r3,r7
 b0072d0:	00c6303a 	nor	r3,zero,r3
 b0072d4:	28c6703a 	and	r3,r5,r3
 b0072d8:	1986703a 	and	r3,r3,r6
 b0072dc:	183ff926 	beq	r3,zero,b0072c4 <__alt_mem_flash+0xff0062c4>
 b0072e0:	00000106 	br	b0072e8 <strlen+0x78>
 b0072e4:	10800044 	addi	r2,r2,1
 b0072e8:	10c00007 	ldb	r3,0(r2)
 b0072ec:	183ffd1e 	bne	r3,zero,b0072e4 <__alt_mem_flash+0xff0062e4>
 b0072f0:	1105c83a 	sub	r2,r2,r4
 b0072f4:	f800283a 	ret
 b0072f8:	2005883a 	mov	r2,r4
 b0072fc:	003fe706 	br	b00729c <__alt_mem_flash+0xff00629c>
 b007300:	0005883a 	mov	r2,zero
 b007304:	f800283a 	ret

0b007308 <__register_exitproc>:
 b007308:	defffa04 	addi	sp,sp,-24
 b00730c:	dc000315 	stw	r16,12(sp)
 b007310:	0402c074 	movhi	r16,2817
 b007314:	84248c04 	addi	r16,r16,-28112
 b007318:	80c00017 	ldw	r3,0(r16)
 b00731c:	dc400415 	stw	r17,16(sp)
 b007320:	dfc00515 	stw	ra,20(sp)
 b007324:	18805217 	ldw	r2,328(r3)
 b007328:	2023883a 	mov	r17,r4
 b00732c:	10003726 	beq	r2,zero,b00740c <__register_exitproc+0x104>
 b007330:	10c00117 	ldw	r3,4(r2)
 b007334:	010007c4 	movi	r4,31
 b007338:	20c00e16 	blt	r4,r3,b007374 <__register_exitproc+0x6c>
 b00733c:	1a000044 	addi	r8,r3,1
 b007340:	8800221e 	bne	r17,zero,b0073cc <__register_exitproc+0xc4>
 b007344:	18c00084 	addi	r3,r3,2
 b007348:	18c7883a 	add	r3,r3,r3
 b00734c:	18c7883a 	add	r3,r3,r3
 b007350:	12000115 	stw	r8,4(r2)
 b007354:	10c7883a 	add	r3,r2,r3
 b007358:	19400015 	stw	r5,0(r3)
 b00735c:	0005883a 	mov	r2,zero
 b007360:	dfc00517 	ldw	ra,20(sp)
 b007364:	dc400417 	ldw	r17,16(sp)
 b007368:	dc000317 	ldw	r16,12(sp)
 b00736c:	dec00604 	addi	sp,sp,24
 b007370:	f800283a 	ret
 b007374:	00800034 	movhi	r2,0
 b007378:	10800004 	addi	r2,r2,0
 b00737c:	10002626 	beq	r2,zero,b007418 <__register_exitproc+0x110>
 b007380:	01006404 	movi	r4,400
 b007384:	d9400015 	stw	r5,0(sp)
 b007388:	d9800115 	stw	r6,4(sp)
 b00738c:	d9c00215 	stw	r7,8(sp)
 b007390:	00000000 	call	0 <__alt_mem_onchip-0x4000000>
 b007394:	d9400017 	ldw	r5,0(sp)
 b007398:	d9800117 	ldw	r6,4(sp)
 b00739c:	d9c00217 	ldw	r7,8(sp)
 b0073a0:	10001d26 	beq	r2,zero,b007418 <__register_exitproc+0x110>
 b0073a4:	81000017 	ldw	r4,0(r16)
 b0073a8:	10000115 	stw	zero,4(r2)
 b0073ac:	02000044 	movi	r8,1
 b0073b0:	22405217 	ldw	r9,328(r4)
 b0073b4:	0007883a 	mov	r3,zero
 b0073b8:	12400015 	stw	r9,0(r2)
 b0073bc:	20805215 	stw	r2,328(r4)
 b0073c0:	10006215 	stw	zero,392(r2)
 b0073c4:	10006315 	stw	zero,396(r2)
 b0073c8:	883fde26 	beq	r17,zero,b007344 <__alt_mem_flash+0xff006344>
 b0073cc:	18c9883a 	add	r4,r3,r3
 b0073d0:	2109883a 	add	r4,r4,r4
 b0073d4:	1109883a 	add	r4,r2,r4
 b0073d8:	21802215 	stw	r6,136(r4)
 b0073dc:	01800044 	movi	r6,1
 b0073e0:	12406217 	ldw	r9,392(r2)
 b0073e4:	30cc983a 	sll	r6,r6,r3
 b0073e8:	4992b03a 	or	r9,r9,r6
 b0073ec:	12406215 	stw	r9,392(r2)
 b0073f0:	21c04215 	stw	r7,264(r4)
 b0073f4:	01000084 	movi	r4,2
 b0073f8:	893fd21e 	bne	r17,r4,b007344 <__alt_mem_flash+0xff006344>
 b0073fc:	11006317 	ldw	r4,396(r2)
 b007400:	218cb03a 	or	r6,r4,r6
 b007404:	11806315 	stw	r6,396(r2)
 b007408:	003fce06 	br	b007344 <__alt_mem_flash+0xff006344>
 b00740c:	18805304 	addi	r2,r3,332
 b007410:	18805215 	stw	r2,328(r3)
 b007414:	003fc606 	br	b007330 <__alt_mem_flash+0xff006330>
 b007418:	00bfffc4 	movi	r2,-1
 b00741c:	003fd006 	br	b007360 <__alt_mem_flash+0xff006360>

0b007420 <__call_exitprocs>:
 b007420:	defff504 	addi	sp,sp,-44
 b007424:	df000915 	stw	fp,36(sp)
 b007428:	dd400615 	stw	r21,24(sp)
 b00742c:	dc800315 	stw	r18,12(sp)
 b007430:	dfc00a15 	stw	ra,40(sp)
 b007434:	ddc00815 	stw	r23,32(sp)
 b007438:	dd800715 	stw	r22,28(sp)
 b00743c:	dd000515 	stw	r20,20(sp)
 b007440:	dcc00415 	stw	r19,16(sp)
 b007444:	dc400215 	stw	r17,8(sp)
 b007448:	dc000115 	stw	r16,4(sp)
 b00744c:	d9000015 	stw	r4,0(sp)
 b007450:	2839883a 	mov	fp,r5
 b007454:	04800044 	movi	r18,1
 b007458:	057fffc4 	movi	r21,-1
 b00745c:	0082c074 	movhi	r2,2817
 b007460:	10a48c04 	addi	r2,r2,-28112
 b007464:	12000017 	ldw	r8,0(r2)
 b007468:	45005217 	ldw	r20,328(r8)
 b00746c:	44c05204 	addi	r19,r8,328
 b007470:	a0001c26 	beq	r20,zero,b0074e4 <__call_exitprocs+0xc4>
 b007474:	a0800117 	ldw	r2,4(r20)
 b007478:	15ffffc4 	addi	r23,r2,-1
 b00747c:	b8000d16 	blt	r23,zero,b0074b4 <__call_exitprocs+0x94>
 b007480:	14000044 	addi	r16,r2,1
 b007484:	8421883a 	add	r16,r16,r16
 b007488:	8421883a 	add	r16,r16,r16
 b00748c:	84402004 	addi	r17,r16,128
 b007490:	a463883a 	add	r17,r20,r17
 b007494:	a421883a 	add	r16,r20,r16
 b007498:	e0001e26 	beq	fp,zero,b007514 <__call_exitprocs+0xf4>
 b00749c:	80804017 	ldw	r2,256(r16)
 b0074a0:	e0801c26 	beq	fp,r2,b007514 <__call_exitprocs+0xf4>
 b0074a4:	bdffffc4 	addi	r23,r23,-1
 b0074a8:	843fff04 	addi	r16,r16,-4
 b0074ac:	8c7fff04 	addi	r17,r17,-4
 b0074b0:	bd7ff91e 	bne	r23,r21,b007498 <__alt_mem_flash+0xff006498>
 b0074b4:	00800034 	movhi	r2,0
 b0074b8:	10800004 	addi	r2,r2,0
 b0074bc:	10000926 	beq	r2,zero,b0074e4 <__call_exitprocs+0xc4>
 b0074c0:	a0800117 	ldw	r2,4(r20)
 b0074c4:	1000301e 	bne	r2,zero,b007588 <__call_exitprocs+0x168>
 b0074c8:	a0800017 	ldw	r2,0(r20)
 b0074cc:	10003226 	beq	r2,zero,b007598 <__call_exitprocs+0x178>
 b0074d0:	a009883a 	mov	r4,r20
 b0074d4:	98800015 	stw	r2,0(r19)
 b0074d8:	00000000 	call	0 <__alt_mem_onchip-0x4000000>
 b0074dc:	9d000017 	ldw	r20,0(r19)
 b0074e0:	a03fe41e 	bne	r20,zero,b007474 <__alt_mem_flash+0xff006474>
 b0074e4:	dfc00a17 	ldw	ra,40(sp)
 b0074e8:	df000917 	ldw	fp,36(sp)
 b0074ec:	ddc00817 	ldw	r23,32(sp)
 b0074f0:	dd800717 	ldw	r22,28(sp)
 b0074f4:	dd400617 	ldw	r21,24(sp)
 b0074f8:	dd000517 	ldw	r20,20(sp)
 b0074fc:	dcc00417 	ldw	r19,16(sp)
 b007500:	dc800317 	ldw	r18,12(sp)
 b007504:	dc400217 	ldw	r17,8(sp)
 b007508:	dc000117 	ldw	r16,4(sp)
 b00750c:	dec00b04 	addi	sp,sp,44
 b007510:	f800283a 	ret
 b007514:	a0800117 	ldw	r2,4(r20)
 b007518:	80c00017 	ldw	r3,0(r16)
 b00751c:	10bfffc4 	addi	r2,r2,-1
 b007520:	15c01426 	beq	r2,r23,b007574 <__call_exitprocs+0x154>
 b007524:	80000015 	stw	zero,0(r16)
 b007528:	183fde26 	beq	r3,zero,b0074a4 <__alt_mem_flash+0xff0064a4>
 b00752c:	95c8983a 	sll	r4,r18,r23
 b007530:	a0806217 	ldw	r2,392(r20)
 b007534:	a5800117 	ldw	r22,4(r20)
 b007538:	2084703a 	and	r2,r4,r2
 b00753c:	10000b26 	beq	r2,zero,b00756c <__call_exitprocs+0x14c>
 b007540:	a0806317 	ldw	r2,396(r20)
 b007544:	2088703a 	and	r4,r4,r2
 b007548:	20000c1e 	bne	r4,zero,b00757c <__call_exitprocs+0x15c>
 b00754c:	89400017 	ldw	r5,0(r17)
 b007550:	d9000017 	ldw	r4,0(sp)
 b007554:	183ee83a 	callr	r3
 b007558:	a0800117 	ldw	r2,4(r20)
 b00755c:	15bfbf1e 	bne	r2,r22,b00745c <__alt_mem_flash+0xff00645c>
 b007560:	98800017 	ldw	r2,0(r19)
 b007564:	153fcf26 	beq	r2,r20,b0074a4 <__alt_mem_flash+0xff0064a4>
 b007568:	003fbc06 	br	b00745c <__alt_mem_flash+0xff00645c>
 b00756c:	183ee83a 	callr	r3
 b007570:	003ff906 	br	b007558 <__alt_mem_flash+0xff006558>
 b007574:	a5c00115 	stw	r23,4(r20)
 b007578:	003feb06 	br	b007528 <__alt_mem_flash+0xff006528>
 b00757c:	89000017 	ldw	r4,0(r17)
 b007580:	183ee83a 	callr	r3
 b007584:	003ff406 	br	b007558 <__alt_mem_flash+0xff006558>
 b007588:	a0800017 	ldw	r2,0(r20)
 b00758c:	a027883a 	mov	r19,r20
 b007590:	1029883a 	mov	r20,r2
 b007594:	003fb606 	br	b007470 <__alt_mem_flash+0xff006470>
 b007598:	0005883a 	mov	r2,zero
 b00759c:	003ffb06 	br	b00758c <__alt_mem_flash+0xff00658c>

0b0075a0 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
 b0075a0:	defffd04 	addi	sp,sp,-12
 b0075a4:	df000215 	stw	fp,8(sp)
 b0075a8:	df000204 	addi	fp,sp,8
 b0075ac:	e13fff15 	stw	r4,-4(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
 b0075b0:	0001883a 	nop
 b0075b4:	e0bfff17 	ldw	r2,-4(fp)
 b0075b8:	e0bffe15 	stw	r2,-8(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
 b0075bc:	e0bffe17 	ldw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
 b0075c0:	10000226 	beq	r2,zero,b0075cc <_exit+0x2c>
    ALT_SIM_FAIL();
 b0075c4:	002af070 	cmpltui	zero,zero,43969
 b0075c8:	00000106 	br	b0075d0 <_exit+0x30>
  } else {
    ALT_SIM_PASS();
 b0075cc:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
 b0075d0:	003fff06 	br	b0075d0 <__alt_mem_flash+0xff0065d0>
